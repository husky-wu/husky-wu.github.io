<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HuskyWuの博客</title>
  <icon>https://www.gravatar.com/avatar/677a3831b4f8567bbc2750dafb4fa06e</icon>
  <subtitle>Huskyの技术分享</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://husky-wu.github.io/"/>
  <updated>2020-12-29T07:05:47.943Z</updated>
  <id>https://husky-wu.github.io/</id>
  
  <author>
    <name>HuskyWu</name>
    <email>beantech@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据混合存储</title>
    <link href="https://husky-wu.github.io/2020/12/29/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E6%95%B0%E6%8D%AE%E6%B7%B7%E5%90%88%E5%AD%98%E5%82%A8/"/>
    <id>https://husky-wu.github.io/2020/12/29/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E6%95%B0%E6%8D%AE%E6%B7%B7%E5%90%88%E5%AD%98%E5%82%A8/</id>
    <published>2020-12-29T07:00:03.000Z</published>
    <updated>2020-12-29T07:05:47.943Z</updated>
    
    <content type="html"><![CDATA[<p>课程链接：</p><p><a href="https://developer.aliyun.com/course/32?spm=a2c6h.17661847.0.0.42686fb2saW1fD" target="_blank" rel="noopener">https://developer.aliyun.com/course/32?spm=a2c6h.17661847.0.0.42686fb2saW1fD</a></p><p><a href="https://developer.aliyun.com/lesson_32_642#_642" target="_blank" rel="noopener">https://developer.aliyun.com/lesson_32_642#_642</a></p><p><img src="../%E6%95%B0%E6%8D%AE%E6%B7%B7%E5%90%88%E5%AD%98%E5%82%A8/image-20201229150055974.png" alt="image-20201229150055974" title="null"></p><p>当前存储架构中：内存+本地存储才能达到极致性能</p><p>从前：</p><p><img src="../%E6%95%B0%E6%8D%AE%E6%B7%B7%E5%90%88%E5%AD%98%E5%82%A8/image-20201229150148077.png" alt="image-20201229150148077" title="null"></p><p>当前</p><p><img src="../%E6%95%B0%E6%8D%AE%E6%B7%B7%E5%90%88%E5%AD%98%E5%82%A8/image-20201229150203677.png" alt="image-20201229150203677" title="null"></p><p>移动数据时</p><p><img src="../%E6%95%B0%E6%8D%AE%E6%B7%B7%E5%90%88%E5%AD%98%E5%82%A8/image-20201229150415502.png" alt="image-20201229150415502" title="null"></p><p>连续写入数据时，写入SSD，后续再同步到sata盘中</p><p><img src="../%E6%95%B0%E6%8D%AE%E6%B7%B7%E5%90%88%E5%AD%98%E5%82%A8/image-20201229150515483.png" alt="image-20201229150515483" title="null"></p><p><img src="../%E6%95%B0%E6%8D%AE%E6%B7%B7%E5%90%88%E5%AD%98%E5%82%A8/image-20201229150526791.png" alt="image-20201229150526791" title="null"></p><p>RAMCLOOUD内存存储</p><p><img src="../%E6%95%B0%E6%8D%AE%E6%B7%B7%E5%90%88%E5%AD%98%E5%82%A8/image-20201229150547244.png" alt="image-20201229150547244" title="null"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;课程链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.aliyun.com/course/32?spm=a2c6h.17661847.0.0.42686fb2saW1fD&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https:
      
    
    </summary>
    
    
      <category term="分布式存储" scheme="https://husky-wu.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    
      <category term="分布式" scheme="https://husky-wu.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="https://husky-wu.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="分布式存储" scheme="https://husky-wu.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>元数据管理的可扩展性</title>
    <link href="https://husky-wu.github.io/2020/12/29/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7/"/>
    <id>https://husky-wu.github.io/2020/12/29/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7/</id>
    <published>2020-12-29T06:53:35.000Z</published>
    <updated>2020-12-29T06:59:35.753Z</updated>
    
    <content type="html"><![CDATA[<p>课程链接：</p><p><a href="https://developer.aliyun.com/course/32?spm=a2c6h.17661847.0.0.42686fb2saW1fD" target="_blank" rel="noopener">https://developer.aliyun.com/course/32?spm=a2c6h.17661847.0.0.42686fb2saW1fD</a></p><p><a href="https://developer.aliyun.com/lesson_32_641#_641" target="_blank" rel="noopener">https://developer.aliyun.com/lesson_32_641#_641</a></p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7/image-20201229145809484.png" alt="image-20201229145809484" title="null"></p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7/image-20201229145847014.png" alt="image-20201229145847014" title="null"></p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7/image-20201229145915281.png" alt="image-20201229145915281" title="null"></p><p>动态分块</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;课程链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.aliyun.com/course/32?spm=a2c6h.17661847.0.0.42686fb2saW1fD&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https:
      
    
    </summary>
    
    
      <category term="分布式存储" scheme="https://husky-wu.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    
      <category term="分布式" scheme="https://husky-wu.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="https://husky-wu.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="分布式存储" scheme="https://husky-wu.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>元数据管理的高可用性</title>
    <link href="https://husky-wu.github.io/2020/12/29/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/"/>
    <id>https://husky-wu.github.io/2020/12/29/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/</id>
    <published>2020-12-29T06:32:25.000Z</published>
    <updated>2020-12-29T06:53:05.466Z</updated>
    
    <content type="html"><![CDATA[<p>课程链接：</p><p><a href="https://developer.aliyun.com/course/32?spm=a2c6h.17661847.0.0.42686fb2saW1fD" target="_blank" rel="noopener">https://developer.aliyun.com/course/32?spm=a2c6h.17661847.0.0.42686fb2saW1fD</a></p><p><a href="https://developer.aliyun.com/lesson_32_640#_640" target="_blank" rel="noopener">https://developer.aliyun.com/lesson_32_640#_640</a></p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/image-20201229143335480.png" alt="image-20201229143335480" title="null"></p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/image-20201229143348235.png" alt="image-20201229143348235" title="null"></p><p>主从方式</p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/image-20201229143420012.png" alt="image-20201229143420012" title="null"></p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/image-20201229143434662.png" alt="image-20201229143434662" title="null"></p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/image-20201229143456067.png" alt="image-20201229143456067" title="null"></p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/image-20201229143610485.png" alt="image-20201229143610485" title="null"></p><p>分布式协议</p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/image-20201229143516471.png" alt="image-20201229143516471" title="null"></p><p>主从方式和分布式协议对比</p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/image-20201229143646282.png" alt="image-20201229143646282" title="null"></p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/image-20201229143657168.png" alt="image-20201229143657168" title="null"></p><p>HDFS NAMENODE 共享存储</p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/image-20201229143724494.png" alt="image-20201229143724494" title="null"></p><p>盘古 元数据服务  Raft</p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/image-20201229143757833.png" alt="image-20201229143757833" title="null"></p><p>选举状态</p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/image-20201229144001997.png" alt="image-20201229144001997" title="null"></p><p>发起选举请求</p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/image-20201229144017791.png" alt="image-20201229144017791" title="null"></p><p>其他节点接收到请求将进入锁定状态</p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/image-20201229144031224.png" alt="image-20201229144031224" title="null"></p><p>如果一个节点的请求被大多数节点接受，则发起publish，将自己的选举结果发送给其余节点</p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/image-20201229144142825.png" alt="image-20201229144142825" title="null"></p><p>锁定中的elector接收到publish通知则变为secondary状态</p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/image-20201229144251549.png" alt="image-20201229144251549" title="null"></p><p>发送出publish请求后，节点进入primary状态，并提供主节点服务</p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/image-20201229144357899.png" alt="image-20201229144357899" title="null"></p><p>主节点与辅助节点间有心跳连接，如果主节点异常，心跳丢失，从节点接收不到心跳会认为主节点宕机</p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/image-20201229144551139.png" alt="image-20201229144551139" title="null"></p><p>从节点会降级为选举状态，重新进行选举</p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/image-20201229144622545.png" alt="image-20201229144622545" title="null"></p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/image-20201229144643267.png" alt="image-20201229144643267" title="null"></p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/image-20201229144652189.png" alt="image-20201229144652189" title="null"></p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/image-20201229144659694.png" alt="image-20201229144659694" title="null"></p><p>之前异常的节点恢复后如何重新加入集群</p><p>依旧会选举自己为主节点发起propose</p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/image-20201229144738763.png" alt="image-20201229144738763" title="null"></p><p>当前主节点拒绝该请求，同时将自己是主节点这个信息publish给elector节点</p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/image-20201229144811943.png" alt="image-20201229144811943" title="null"></p><p>让其升级为secondary状态，重新加入服务</p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/image-20201229144914718.png" alt="image-20201229144914718" title="null"></p><p>Ceph Metadata Server</p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/image-20201229144954863.png" alt="image-20201229144954863" title="null"></p><p>数据一致性的保证</p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/image-20201229145019814.png" alt="image-20201229145019814" title="null"></p><p>Paxos</p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/image-20201229145111257.png" alt="image-20201229145111257" title="null"></p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/image-20201229145142337.png" alt="image-20201229145142337" title="null"></p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/image-20201229145212782.png" alt="image-20201229145212782" title="null"></p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/image-20201229145222215.png" alt="image-20201229145222215" title="null"></p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/image-20201229145231700.png" alt="image-20201229145231700" title="null"></p><p>Raft协议演示过程：</p><p><a href="https://raftconsensus.github.io/" target="_blank" rel="noopener">https://raftconsensus.github.io/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;课程链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.aliyun.com/course/32?spm=a2c6h.17661847.0.0.42686fb2saW1fD&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https:
      
    
    </summary>
    
    
      <category term="分布式存储" scheme="https://husky-wu.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    
      <category term="分布式" scheme="https://husky-wu.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="https://husky-wu.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="分布式存储" scheme="https://husky-wu.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统功能设计-ErasureCoding</title>
    <link href="https://husky-wu.github.io/2020/12/29/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-ErasureCoding/"/>
    <id>https://husky-wu.github.io/2020/12/29/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-ErasureCoding/</id>
    <published>2020-12-29T06:01:18.000Z</published>
    <updated>2020-12-29T06:31:37.434Z</updated>
    
    <content type="html"><![CDATA[<p>课程链接：</p><p><a href="https://developer.aliyun.com/course/32?spm=a2c6h.17661847.0.0.42686fb2saW1fD" target="_blank" rel="noopener">https://developer.aliyun.com/course/32?spm=a2c6h.17661847.0.0.42686fb2saW1fD</a></p><p><a href="https://developer.aliyun.com/lesson_32_639#_639" target="_blank" rel="noopener">https://developer.aliyun.com/lesson_32_639#_639</a></p><p>ErasureCoding数据压缩存储</p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-ErasureCoding/image-20201229142934482.png" alt="image-20201229142934482" title="null"></p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-ErasureCoding/image-20201229143017282.png" alt="image-20201229143017282" title="null"></p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-ErasureCoding/image-20201229143039900.png" alt="image-20201229143039900" title="null"></p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-ErasureCoding/image-20201229143108800.png" alt="image-20201229143108800" title="null"></p><p>劣势：当出现异常节点时，比较耗费网络节点流量</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;课程链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.aliyun.com/course/32?spm=a2c6h.17661847.0.0.42686fb2saW1fD&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https:
      
    
    </summary>
    
    
      <category term="分布式存储" scheme="https://husky-wu.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    
      <category term="分布式" scheme="https://husky-wu.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="https://husky-wu.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="分布式存储" scheme="https://husky-wu.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统功能设计-GC</title>
    <link href="https://husky-wu.github.io/2020/12/29/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-GC/"/>
    <id>https://husky-wu.github.io/2020/12/29/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-GC/</id>
    <published>2020-12-29T05:57:07.000Z</published>
    <updated>2020-12-29T06:00:46.866Z</updated>
    
    <content type="html"><![CDATA[<p>课程链接：</p><p><a href="https://developer.aliyun.com/course/32?spm=a2c6h.17661847.0.0.42686fb2saW1fD" target="_blank" rel="noopener">https://developer.aliyun.com/course/32?spm=a2c6h.17661847.0.0.42686fb2saW1fD</a></p><p><a href="https://developer.aliyun.com/lesson_32_638#_638" target="_blank" rel="noopener">https://developer.aliyun.com/lesson_32_638#_638</a></p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-GC/image-20201229135817761.png" alt="image-20201229135817761" title="null"></p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-GC/image-20201229135829989.png" alt="image-20201229135829989" title="null"></p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-GC/image-20201229135843596.png" alt="image-20201229135843596" title="null"></p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-GC/image-20201229135920043.png" alt="image-20201229135920043" title="null"></p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-GC/image-20201229135931511.png" alt="image-20201229135931511" title="null"></p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-GC/image-20201229140013784.png" alt="image-20201229140013784" title="null"></p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-GC/image-20201229140031002.png" alt="image-20201229140031002" title="null"></p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-GC/image-20201229140043476.png" alt="image-20201229140043476" title="null"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;课程链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.aliyun.com/course/32?spm=a2c6h.17661847.0.0.42686fb2saW1fD&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https:
      
    
    </summary>
    
    
      <category term="分布式存储" scheme="https://husky-wu.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    
      <category term="分布式" scheme="https://husky-wu.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="https://husky-wu.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="分布式存储" scheme="https://husky-wu.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统功能设计-Rebalance</title>
    <link href="https://husky-wu.github.io/2020/12/29/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-Rebalance/"/>
    <id>https://husky-wu.github.io/2020/12/29/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-Rebalance/</id>
    <published>2020-12-29T05:53:57.000Z</published>
    <updated>2020-12-29T05:55:42.993Z</updated>
    
    <content type="html"><![CDATA[<p>课程链接：</p><p><a href="https://developer.aliyun.com/course/32?spm=a2c6h.17661847.0.0.42686fb2saW1fD" target="_blank" rel="noopener">https://developer.aliyun.com/course/32?spm=a2c6h.17661847.0.0.42686fb2saW1fD</a></p><p><a href="https://developer.aliyun.com/lesson_32_637#_637" target="_blank" rel="noopener">https://developer.aliyun.com/lesson_32_637#_637</a></p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-Rebalance/image-20201229135442950.png" alt="image-20201229135442950" title="null"></p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-Rebalance/image-20201229135452256.png" alt="image-20201229135452256" title="null"></p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-Rebalance/image-20201229135500251.png" alt="image-20201229135500251" title="null"></p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-Rebalance/image-20201229135515211.png" alt="image-20201229135515211" title="null"></p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-Rebalance/image-20201229135535576.png" alt="image-20201229135535576" title="null"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;课程链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.aliyun.com/course/32?spm=a2c6h.17661847.0.0.42686fb2saW1fD&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https:
      
    
    </summary>
    
    
      <category term="分布式存储" scheme="https://husky-wu.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    
      <category term="分布式" scheme="https://husky-wu.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="https://husky-wu.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="分布式存储" scheme="https://husky-wu.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统功能设计-Replication</title>
    <link href="https://husky-wu.github.io/2020/12/29/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-Replication/"/>
    <id>https://husky-wu.github.io/2020/12/29/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-Replication/</id>
    <published>2020-12-29T05:47:30.000Z</published>
    <updated>2020-12-29T05:53:26.960Z</updated>
    
    <content type="html"><![CDATA[<p>课程链接：</p><p><a href="https://developer.aliyun.com/course/32?spm=a2c6h.17661847.0.0.42686fb2saW1fD" target="_blank" rel="noopener">https://developer.aliyun.com/course/32?spm=a2c6h.17661847.0.0.42686fb2saW1fD</a></p><p><a href="https://developer.aliyun.com/lesson_32_636#_636" target="_blank" rel="noopener">https://developer.aliyun.com/lesson_32_636#_636</a></p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-Replication/image-20201229134817085.png" alt="image-20201229134817085" title="null"></p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-Replication/image-20201229134834078.png" alt="image-20201229134834078" title="null"></p><p>如何保证数据不丢失</p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-Replication/image-20201229134856431.png" alt="image-20201229134856431" title="null"></p><p>如何及时发现磁盘错误？</p><p>盘古中每隔15s会回报一次在从上的心跳</p><p>当发现错误后，会去访问master获取从盘中错误文件的信息，并发起较高优先级的恢复</p><p>复制中需要考虑网络流量</p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-Replication/image-20201229135132635.png" alt="image-20201229135132635" title="null"></p><p>流量控制-防止复制风暴，不能因为</p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-Replication/image-20201229135302163.png" alt="image-20201229135302163" title="null"></p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-Replication/image-20201229135324663.png" alt="image-20201229135324663" title="null"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;课程链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.aliyun.com/course/32?spm=a2c6h.17661847.0.0.42686fb2saW1fD&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https:
      
    
    </summary>
    
    
      <category term="分布式存储" scheme="https://husky-wu.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    
      <category term="分布式" scheme="https://husky-wu.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="https://husky-wu.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="分布式存储" scheme="https://husky-wu.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统功能设计-Checksum</title>
    <link href="https://husky-wu.github.io/2020/12/29/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-Checksum/"/>
    <id>https://husky-wu.github.io/2020/12/29/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-Checksum/</id>
    <published>2020-12-29T05:38:23.000Z</published>
    <updated>2020-12-29T05:48:02.056Z</updated>
    
    <content type="html"><![CDATA[<p>课程链接：</p><p><a href="https://developer.aliyun.com/course/32?spm=a2c6h.17661847.0.0.42686fb2saW1fD" target="_blank" rel="noopener">https://developer.aliyun.com/course/32?spm=a2c6h.17661847.0.0.42686fb2saW1fD</a></p><p>https:/developer.aliyun.com/lesson_32_635#_635</p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-Checksum/image-20201229133923948.png" alt="image-20201229133923948" title="null"></p><p>数据包将会构造三元组</p><p>放在buffer中 记录length数据长度 进行CRC校验</p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-Checksum/image-20201229133959862.png" alt="image-20201229133959862" title="null"></p><p>在网络传输中由于数据包可能比较大，将会把这个数据包进行网络分包处理，</p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-Checksum/image-20201229134212309.png" alt="image-20201229134212309" title="null"></p><p>每个分包都会构造这样的三元组</p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-Checksum/image-20201229134254498.png" alt="image-20201229134254498" title="null"></p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-Checksum/image-20201229134306108.png" alt="image-20201229134306108" title="null"></p><p>传输中以及传输完成后均要对分包以及合并后的整包的CRC值进行校验</p><p>CRC值将会和数据一起存储于磁盘中</p><p>为保证在使用过程中磁盘数据的一致性以及可用性，将会启用checksum进程，间断性的对数据块中的CRC值进行校验</p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-Checksum/image-20201229134540981.png" alt="image-20201229134540981" title="null"></p><p>如有错误将通知盘古进行修复</p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-Checksum/image-20201229134605042.png" alt="image-20201229134605042" title="null"></p><p>弊端：</p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-Checksum/image-20201229134648105.png" alt="image-20201229134648105" title="null"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;课程链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.aliyun.com/course/32?spm=a2c6h.17661847.0.0.42686fb2saW1fD&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https:
      
    
    </summary>
    
    
      <category term="分布式存储" scheme="https://husky-wu.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    
      <category term="分布式" scheme="https://husky-wu.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="https://husky-wu.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="分布式存储" scheme="https://husky-wu.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统功能设计-QoS</title>
    <link href="https://husky-wu.github.io/2020/12/29/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-QoS/"/>
    <id>https://husky-wu.github.io/2020/12/29/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-QoS/</id>
    <published>2020-12-29T05:34:27.000Z</published>
    <updated>2020-12-29T05:37:56.878Z</updated>
    
    <content type="html"><![CDATA[<p>课程链接：</p><p><a href="https://developer.aliyun.com/course/32?spm=a2c6h.17661847.0.0.42686fb2saW1fD" target="_blank" rel="noopener">https://developer.aliyun.com/course/32?spm=a2c6h.17661847.0.0.42686fb2saW1fD</a></p><p><a href="https://developer.aliyun.com/lesson_32_634?spm=5176.10731542.0.0.622d12a7NMPHbC#_634" target="_blank" rel="noopener">https://developer.aliyun.com/lesson_32_634?spm=5176.10731542.0.0.622d12a7NMPHbC#_634</a></p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-QoS/image-20201229133533202.png" alt="image-20201229133533202" title="null"></p><p>多用户共存的QoS请求</p><p>每个用户用户组都将会标记权重</p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-QoS/image-20201229133613445.png" alt="image-20201229133613445" title="null"></p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-QoS/image-20201229133622010.png" alt="image-20201229133622010" title="null"></p><p>采用轮询方式从不同用户的请求池中执行请求，以保证每个用户的访问质量</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;课程链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.aliyun.com/course/32?spm=a2c6h.17661847.0.0.42686fb2saW1fD&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https:
      
    
    </summary>
    
    
      <category term="分布式存储" scheme="https://husky-wu.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    
      <category term="分布式" scheme="https://husky-wu.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="https://husky-wu.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="分布式存储" scheme="https://husky-wu.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统功能设计-读取流程</title>
    <link href="https://husky-wu.github.io/2020/12/29/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-%E8%AF%BB%E5%8F%96%E6%B5%81%E7%A8%8B/"/>
    <id>https://husky-wu.github.io/2020/12/29/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-%E8%AF%BB%E5%8F%96%E6%B5%81%E7%A8%8B/</id>
    <published>2020-12-29T05:27:11.000Z</published>
    <updated>2020-12-29T05:34:51.543Z</updated>
    
    <content type="html"><![CDATA[<p>课程链接：</p><p><a href="https://developer.aliyun.com/course/32?spm=a2c6h.17661847.0.0.42686fb2saW1fD" target="_blank" rel="noopener">https://developer.aliyun.com/course/32?spm=a2c6h.17661847.0.0.42686fb2saW1fD</a></p><p><a href="https://developer.aliyun.com/lesson_32_633#_633" target="_blank" rel="noopener">https://developer.aliyun.com/lesson_32_633#_633</a></p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-%E8%AF%BB%E5%8F%96%E6%B5%81%E7%A8%8B/image-20201229132824442.png" alt="image-20201229132824442" title="null"></p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-%E8%AF%BB%E5%8F%96%E6%B5%81%E7%A8%8B/image-20201229132945223.png" alt="image-20201229132945223" title="null"></p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-%E8%AF%BB%E5%8F%96%E6%B5%81%E7%A8%8B/image-20201229133010826.png" alt="image-20201229133010826" title="null"></p><p>backupread解决慢节点</p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-%E8%AF%BB%E5%8F%96%E6%B5%81%E7%A8%8B/image-20201229133049912.png" alt="image-20201229133049912" title="null"></p><p>读流程优化-规避慢节点</p><p>间段性统计返回期望</p><p>优先选择请求返回期望小的节点</p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-%E8%AF%BB%E5%8F%96%E6%B5%81%E7%A8%8B/image-20201229133147508.png" alt="image-20201229133147508" title="null"></p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-%E8%AF%BB%E5%8F%96%E6%B5%81%E7%A8%8B/image-20201229133257577.png" alt="image-20201229133257577" title="null"></p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-%E8%AF%BB%E5%8F%96%E6%B5%81%E7%A8%8B/image-20201229133318207.png" alt="image-20201229133318207" title="null"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;课程链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.aliyun.com/course/32?spm=a2c6h.17661847.0.0.42686fb2saW1fD&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https:
      
    
    </summary>
    
    
      <category term="分布式存储" scheme="https://husky-wu.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    
      <category term="分布式" scheme="https://husky-wu.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="https://husky-wu.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="分布式存储" scheme="https://husky-wu.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统功能设计-写入流程</title>
    <link href="https://husky-wu.github.io/2020/12/29/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-%E5%86%99%E5%85%A5%E6%B5%81%E7%A8%8B/"/>
    <id>https://husky-wu.github.io/2020/12/29/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-%E5%86%99%E5%85%A5%E6%B5%81%E7%A8%8B/</id>
    <published>2020-12-29T05:17:44.000Z</published>
    <updated>2020-12-29T05:26:21.599Z</updated>
    
    <content type="html"><![CDATA[<p>课程链接：</p><p><a href="https://developer.aliyun.com/course/32?spm=a2c6h.17661847.0.0.42686fb2saW1fD" target="_blank" rel="noopener">https://developer.aliyun.com/course/32?spm=a2c6h.17661847.0.0.42686fb2saW1fD</a></p><p><a href="https://developer.aliyun.com/lesson_32_617?spm=5176.10731542.0.0.2d7a12a7E2TEQx#_617" target="_blank" rel="noopener">https://developer.aliyun.com/lesson_32_617?spm=5176.10731542.0.0.2d7a12a7E2TEQx#_617</a></p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-%E5%86%99%E5%85%A5%E6%B5%81%E7%A8%8B/image-20201229132013769.png" alt="image-20201229132013769" title="null"></p><p>链式写入流程</p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-%E5%86%99%E5%85%A5%E6%B5%81%E7%A8%8B/image-20201229131942815.png" alt="image-20201229131942815" title="null"></p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-%E5%86%99%E5%85%A5%E6%B5%81%E7%A8%8B/image-20201229132059438.png" alt="image-20201229132059438" title="null"></p><p>主从模式</p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-%E5%86%99%E5%85%A5%E6%B5%81%E7%A8%8B/image-20201229132129245.png" alt="image-20201229132129245" title="null"></p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-%E5%86%99%E5%85%A5%E6%B5%81%E7%A8%8B/image-20201229132208625.png" alt="image-20201229132208625" title="null"></p><p>异常情况-链式写入</p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-%E5%86%99%E5%85%A5%E6%B5%81%E7%A8%8B/image-20201229132242014.png" alt="image-20201229132242014" title="null"></p><p>第二种处理方式</p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-%E5%86%99%E5%85%A5%E6%B5%81%E7%A8%8B/image-20201229132314189.png" alt="image-20201229132314189" title="null"></p><p>异常情况-链式写入</p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-%E5%86%99%E5%85%A5%E6%B5%81%E7%A8%8B/image-20201229132354545.png" alt="image-20201229132354545" title="null"></p><p>总结：</p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-%E5%86%99%E5%85%A5%E6%B5%81%E7%A8%8B/image-20201229132426423.png" alt="image-20201229132426423" title="null"></p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-%E5%86%99%E5%85%A5%E6%B5%81%E7%A8%8B/image-20201229132435673.png" alt="image-20201229132435673" title="null"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;课程链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.aliyun.com/course/32?spm=a2c6h.17661847.0.0.42686fb2saW1fD&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https:
      
    
    </summary>
    
    
      <category term="分布式存储" scheme="https://husky-wu.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    
      <category term="分布式" scheme="https://husky-wu.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="https://husky-wu.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="分布式存储" scheme="https://husky-wu.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB体系结构</title>
    <link href="https://husky-wu.github.io/2020/12/28/MongoDB/MongoDB%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    <id>https://husky-wu.github.io/2020/12/28/MongoDB/MongoDB%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</id>
    <published>2020-12-28T02:30:30.000Z</published>
    <updated>2020-12-28T02:31:10.960Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="MongoDB" scheme="https://husky-wu.github.io/categories/MongoDB/"/>
    
    
      <category term="MongoDB" scheme="https://husky-wu.github.io/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>自动运维平台</title>
    <link href="https://husky-wu.github.io/2020/12/28/%E8%87%AA%E5%8A%A8%E8%BF%90%E7%BB%B4%E5%B9%B3%E5%8F%B0/%E8%87%AA%E5%8A%A8%E8%BF%90%E7%BB%B4%E5%B9%B3%E5%8F%B0/"/>
    <id>https://husky-wu.github.io/2020/12/28/%E8%87%AA%E5%8A%A8%E8%BF%90%E7%BB%B4%E5%B9%B3%E5%8F%B0/%E8%87%AA%E5%8A%A8%E8%BF%90%E7%BB%B4%E5%B9%B3%E5%8F%B0/</id>
    <published>2020-12-28T02:10:27.000Z</published>
    <updated>2020-12-28T02:22:31.416Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th>工具名称</th><th>官方网址</th><th>git地址</th></tr></thead><tbody><tr><td>Inception+Yearing</td><td><a href="http://python.yearning.io/" target="_blank" rel="noopener">http://python.yearning.io/</a></td><td><a href="https://github.com/cookieY/inception-document" target="_blank" rel="noopener">https://github.com/cookieY/inception-document</a></td></tr><tr><td>Archery</td><td><a href="https://archerydms.com/" target="_blank" rel="noopener">https://archerydms.com/</a></td><td><a href="https://github.com/hhyo/Archery" target="_blank" rel="noopener">https://github.com/hhyo/Archery</a></td></tr><tr><td>soar</td><td></td><td><a href="https://github.com/XiaoMi/soar/blob/master/doc/config.md" target="_blank" rel="noopener">https://github.com/XiaoMi/soar/blob/master/doc/config.md</a></td></tr><tr><td>soar-php</td><td></td><td><a href="https://github.com/guanguans/soar-php" target="_blank" rel="noopener">https://github.com/guanguans/soar-php</a></td></tr></tbody></table><p><strong>Archery</strong></p><p><img src="../%E8%87%AA%E5%8A%A8%E8%BF%90%E7%BB%B4%E5%B9%B3%E5%8F%B0/Archery.png" alt="Archery" title="null"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;工具名称&lt;/th&gt;
&lt;th&gt;官方网址&lt;/th&gt;
&lt;th&gt;git地址&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;Inception+Yearing&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;http://py
      
    
    </summary>
    
    
      <category term="自动运维平台" scheme="https://husky-wu.github.io/categories/%E8%87%AA%E5%8A%A8%E8%BF%90%E7%BB%B4%E5%B9%B3%E5%8F%B0/"/>
    
    
      <category term="自动运维平台" scheme="https://husky-wu.github.io/tags/%E8%87%AA%E5%8A%A8%E8%BF%90%E7%BB%B4%E5%B9%B3%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>OracleDG概念与进程解析</title>
    <link href="https://husky-wu.github.io/2020/12/19/Oracle/OracleDG%E6%A6%82%E5%BF%B5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E8%A7%A3%E6%9E%90/"/>
    <id>https://husky-wu.github.io/2020/12/19/Oracle/OracleDG%E6%A6%82%E5%BF%B5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E8%A7%A3%E6%9E%90/</id>
    <published>2020-12-19T03:56:50.000Z</published>
    <updated>2020-12-19T04:03:49.226Z</updated>
    
    <content type="html"><![CDATA[<p>RAC，Data Gurad，Stream 是Oracle高可用性体系中的三种工具，每个工具即可以独立应用，也可以相互配合。他们各自的侧重点不同，适用场景也不同。</p><p>RAC它的强项在于<strong>解决单点故障和负载均衡</strong>，因此RAC方案常用于7*24的核心系统，但RAC方案中的数据只有一份，尽管可以通过RAID等机制可以避免存储故障，但是数据本身是没有冗余的，容易形成单点故障。</p><p>Data Gurad通过冗余数据来<strong>提供数据保护</strong>，Data Gurad 通过日志同步机制保证冗余数据和主数据之前的同步，这种同步可以是实时，延时，同步，异步多种形式。Data Gurad常用于异地容灾和小企业的高可用性方案，虽然可以在Standby机器上执行只读查询，从而分散Primary数据库的性能压力，但是Data Gurad决不是性能解决方案。</p><p>Stream是以Oracle Advanced Queue为基础实现的<strong>数据同步</strong>，提供了多种级别的<strong>灵活配置</strong>，并且Oracle提供了丰富的API等开发支持，Stream更适用在应用层面的数据共享。</p><h3 id="一．-Data-Guard-架构"><a href="#一．-Data-Guard-架构" class="headerlink" title="一． Data Guard 架构"></a>一． Data Guard 架构</h3><p>DG架构可以按照功能分成3个部分：</p><p>1） 日志发送（Redo Send）</p><p>2） 日志接收（Redo Receive）</p><p>3） 日志应用（Redo Apply）</p><p>\1. 日志发送（Redo Send）</p><p>Primary Database运行过程中，会源源不断地产生Redo日志，这些日志需要发送到Standy Database。这个发送动作可以由Primary Database的LGWR或者ARCH进程完成，不同的归档目的地可以使用不同的方法，但是对于一个目的地，只能选用一种方法。选择哪个进程对数据保护能力和系统可用性有很大区别。 </p><p>1.1 使用ARCH 进程</p><p>1）Primary Database不断产生Redo Log，这些日志被LGWR进程写到联机日志。</p><p>2）当一组联机日志被写满后，会发生日志切换（Log Switch）并且会触发本地归档，本地归档位置是采用LOG_ARCHIVE_DEST_1=’LOCATION=/path’这种格式定义的。</p><p>如：alter system set log_archive_dest_1 = ‘LOCATION=/u01/arch’ scope=both;</p><p>3）完成本地归档后，联机日志就可以被覆盖重用。</p><p>4）ARCH 进程通过Net把归档日志发送给Standby Database的RFS（Remote File Server）进程。</p><p>5）Standby Database端的RFS进程把接收的日志写入到归档日志。</p><p>6）Standby Database端的MRP(Managed Recovery Process)进程（Redo Apply）或者LSP 进程（SQL Apply）在Standby Database上应用这些日志，进而同步数据。</p><p>用ARCH模式传输不写入备机的重做日志（Standby Redologs），直接保存成归档文件存放于Standby端。</p><p>说明：</p><p>逻辑Standby接收后将其转换成SQL语句，在Standby数据库上执行SQL语句实现同步，这种方式叫SQL Apply。</p><p>物理Standby接收完Primary数据库生成的REDO数据后，以介质恢复的方式实现同步，这种方式也叫Redo Apply。</p><p>注意：创建逻辑Standby数据库要先创建一个物理Standby数据库，然后再将其转换成逻辑Standby数据库。</p><p>使用ARCH进程传递最大问题在于： Primary Database只有在发生归档时才会发送日志到Standby Database。如果Primary Database异常宕机，联机日志中的Redo内容就会丢失，因此使用ARCH进程无法避免数据丢失的问题，要想避免数据丢失，就必须使用LGWR，而使用LGWR 又分SYNC（同步）和ASYNC（异步）两种方式。</p><p>在缺省方式下，Primary Database使用的是ARCH进程，参数设置如下：</p><p>alter system set log_archive_dest_2 = ‘SERVICE=ST’ scope=both;</p><p>1.2 使用LGWR 进程的SYNC 方式</p><p>1）Primary Database 产生的Redo 日志要同时写道日志文件和网络。也就是说LGWR进程把日志写到本地日志文件的同时还要发送给本地的LNSn进程（LGWR Network Server Process），再由LNSn（LGWR Network Server process）进程把日志通过网络发送给远程的目的地，每个远程目的地对应一个LNS进程，多个LNS进程能够并行工作。</p><p>2）LGWR 必须等待写入本地日志文件操作和通过LNSn进程的网络传送都成功，Primary Database上的事务才能提交，这也是SYNC的含义所在。</p><p>3）Standby Database的RFS进程把接收到的日志写入到Standby Redo Log日志中。</p><p>4）Primary Database的日志切换也会触发Standby Database上的日志切换，即Standby Database对Standby RedoLog的归档，然后触发Standby Database的MRP或者LSP进程恢复归档日志。</p><p>因为Primary Database 的Redo是实时传递的，于是Standby Database端可以使用两种恢复方法： </p><p>实时恢复（Real-Time Apply）：只要RFS把日志写入Standby Redo Log就会立即进行恢复；</p><p>归档恢复：在完成对Standby RedoLog归档才触发恢复。</p><p> Primary Database默认使用ARCH进程，如果使用LGWR进程必须明确指定。使用LGWR SYNC方式时，可以同时使用NET_TIMEOUT参数，这个参数单位是秒，代表如果多长时间内网络发送没有响应，LGWR 进程会抛出错误。示例如下：</p><p>alter system set log_archive_dest_2 = ‘SERVICE=ST LGWR SYNC NET_TIMEOUT=30’ scope=both;</p><p>1.3 使用LGWR进程的ASYNC 方式</p><p>使用LGWR SYNC方法的可能问题在于，如果日志发送给Standby Database过程失败，LGWR进程就会报错。也就是说Primary Database的LGWR 进程依赖于网络状况，有时这种要求可能过于苛刻，这时就可以使用LGWR ASYNC方式。 它的工作机制如下：</p><p>1） Primary Database 一段产生Redo 日志后，LGWR 把日志同时提交给日志文件和本地LNS 进程，但是LGWR进程只需成功写入日志文件就可以，不必等待LNSn进程的网络传送成功。</p><p>2） LNSn进程异步地把日志内容发送到Standby Database。多个LNSn进程可以并发发送。</p><p>3） Primary Database的Online Redo Log 写满后发生Log Switch触发归档操作，也触发Standby Database对Standby Redo Log 的归档；然后触发MRP或者LSP 进程恢复归档日志。</p><p>因为LGWR进程不会等待LNSn进程的响应结果，所以配置LGWR ASYNC方式时不需要NET_TIMEOUT参数。示例如下：</p><p>alter system set log_archive_dest_2 = ‘SERVICE=ST LGWR ASYNC ‘ scope=both;</p><p>\2. 日志接收（Redo Receive）</p><p>Standby Database的RFS（Remote File Server）进程接收到日志后，就把日志写到Standby Redo Log或者Archived Log文件中，具体写入哪个文件，取决于Primary的日志传送方式和Standby database的位置。如果写到Standby Redo Log文件中，则当Primary Database发生日志切换时，也会触发Standby Database上的Standby Redo Log的日志切换，并把这个Standby Redo Log归档。如果是写到Archived Log，那么这个动作本身也可以看作是个归档操作。</p><p>在日志接收中，需要注意的是归档日志会被放在什么位置：</p><p>1） 如果配置了STANDBY_ARCHIVE_DEST参数，则使用该参数指定的目录。</p><p>2） 如果某个LOG_ARCHIVE_DEST_n参数明确定义了VALID_FOR=(STANDBY_LOGFILE,*)选项，则使用这个参数指定的目录。</p><p>3） 如果数据库的COMPATIBLE参数大于等于10.0，则选取任意一个LOG_ARCHIVE_DEST_n的值。</p><p>4） 如果STANDBY_ARCHIVE_DEST和LOG_ARCHIVE_DEST_n参数都没有配置，使用缺省的STANDBY_ARCHIVE_DEST参数值缺省值是$ORACLE_HOME/dbs/arc.</p><p>\3. 日志应用（Redo Apply）</p><p>日志应用服务，就是在Standby Database上重演Primary Database日志，从而实现两个数据库的数据同步。根据Standby Database重演日志方式的不同，可分为物理Standby（Physical Standby）和逻辑Standby（Logical Standby）。</p><p>Physical Standby使用的是Media Recovery 技术，在数据块级别进行恢复，这种方式没有数据类型的限制，可以保证两个数据库完全一致。Physical Standby数据库只能在Mount 状态下进行恢复，也可以是打开，但只能已只读方式打开，并且打开时不能执行恢复操作。</p><p>Logical Standby 使用的是Logminer 技术，通过把日志内容还原成SQL 语句，然后SQL引擎执行这些语句，Logminer Standby不支持所有数据类型，可以在视图DBA_LOGSTDBY_UNSUPPORTED 中查看不支持的数据类型，如果使用了这种数据类型，则不能保证数据库完全一致。Logical Standby数据库可以在恢复的同时进行读写操作。</p><p>Standby数据库的相关进程读取接收到的REDO数据（可能来自于Standby端的归档文件，也可能来自于Standby Redologs），再将其写入Standby数据库。保存之后数据又是怎么生成的呢？两种方式：物理Standby通过REDO应用，逻辑Standby通过SQL应用</p><p>根据Redo Apply发生的时间可以分成两种： </p><p>一种是实时应用（Real-Time Apply）， 这种方式必须Standby Redo Log，每当日志被写入Standby Redo Log时，就会触发恢复，使用这种方式的好处在与可以减少数据库切换（Switchover 或者Failover）的时间，因为切换时间主要用在剩余日志的恢复上。 </p><p>另一种是归档时应用，这种方式在Primary Database发生日志切换，触发Standby Database 归档操作，归档完成后触发恢复。 这也是默认的恢复方式。</p><p>  非实时日志应用</p><p><img src="../OracleDG%E6%A6%82%E5%BF%B5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E8%A7%A3%E6%9E%90/1526366j2766t27clfeeut.png" alt="img" title="null"></p><p>实时日志应用</p><p><img src="../OracleDG%E6%A6%82%E5%BF%B5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E8%A7%A3%E6%9E%90/152740j244fzfdj3hjaw04.png" alt="img" title="null"></p><p>如果是Physical Standby，可以使用下面命令启用Real-Time：</p><p>Alter database recover managed standby database using current logfile;</p><p>如果是Logical Standby，可以使用下面命令启用Real-Time：</p><p>Alter database start logical standby apply immediate;</p><p>查看是否使用Real-Time apply：</p><p>Select recovery_mode from v$archive_dest_status;</p><p>SQL&gt; set wrap off<br>SQL&gt; select process,status,thread#,sequence#,client_pid from v$managed_standby;</p><p>PROCESS  STATUS     THREAD# SEQUENCE#    CLIENT_PID</p><hr><p>ARCH   CONNECTED       0     0                 240<br>ARCH   CONNECTED       0     0                196<br>ARCH   CONNECTED       0     0                1944<br>ARCH   CONNECTED       0     0                3956<br>MRP0   WAIT_FOR_LOG     1   30843              N/A<br>RFS    RECEIVING          1   30838            2620<br>RFS    RECEIVING          1   30837            2612<br>RFS    RECEIVING          1   30833            2652<br>RFS    ATTACHED          1   30841             2628<br>RFS    ATTACHED          1   30835             2604<br>RFS    ATTACHED          1   30842            2608</p><p>已选择11行。 </p><h3 id="二．-数据保护模式"><a href="#二．-数据保护模式" class="headerlink" title="二． 数据保护模式"></a>二． 数据保护模式</h3><p>Data Guard 允许定义3钟数据保护模式，分别是最大保护（Maximum Protection），最大可用（Maximum Availability）和 最大性能（Maximum Performance）。</p><p>\1. 最大保护（Maximum Protection）</p><p>这种模式能够确保绝无数据丢失。要实现这一步当然是有代价的，它要求所有的事务在提交前其REDO不仅被写入到本地的Online Redologs，还要同时写入到Standby数据库的Standby Redologs，并确认REDO数据至少在一个Standby数据库中可用（如果有多个的话），然后才会在Primary数据库上提交。如果出现了什么故障导致Standby数据库不可用的话（比如网络中断），Primary数据库会被Shutdown，以防止数据丢失。</p><p>使用这种方式要求Standby Database必须配置Standby RedoLog，而Primary Database必须使用LGWR，SYNC，AFFIRM方式归档到Standby Database.</p><p>\2. 最高可用性（Maximum availability）</p><p>这种模式在不影响Primary数据库可用前提下，提供最高级别的数据保护策略。其实现方式与最大保护模式类似，也是要求本地事务在提交前必须至少写入一台Standby数据库的Standby Redologs中，不过与最大保护模式不同的是，如果出现故障导致Standby数据库无法访问，Primary数据库并不会被Shutdown，而是自动转为最高性能模式，等Standby数据库恢复正常之后，Primary数据库又会自动转换成最高可用性模式。</p><p>这种方式虽然会尽量避免数据丢失，但不能绝对保证数据完全一致。这种方式要求Standby Database 必须配置Standby Redo Log，而Primary Database必须使用LGWR，SYNC，AFFIRM 方式归档到Standby Database.</p><p>\3. 最高性能（Maximum performance）</p><p>缺省模式。 这种模式在不影响Primary数据库性能前提下，提供最高级别的数据保护策略。事务可以随时提交，当前Primary数据库的REDO数据至少需要写入一个Standby数据库，不过这种写入可以是不同步的。如果网络条件理想的话，这种模式能够提供类似最高可用性的数据保护，而仅对Primary数据库的性能有轻微影响。这也是创建Standby数据库时，系统的默认保护模式。</p><p>这种方式可以使用LGWR ASYNC 或者 ARCH 进程实现，Standby Database也不要求使用Standby Redo Log。</p><p>\4. 修改数据保护模式步骤</p><p>1）关闭数据库，重启到Mount 状态，如果是RAC，需要关闭所有实例，然后只启动一个实例到mount状态。</p><p>2）修改模式：</p><p>语法：ALTER DATABASE SET STANDBY DATABASE TO MAXIMIZE {PROTECTION | AVAILABILITY | PERFORMANCE}; </p><p>如：SQL&gt;ALTER DATABASE SET STANDBY DATABASE TO MAXIMIZE PROTECTION;</p><p>3) 打开数据库： alter database open;</p><p>4) 确认修改数据保护模式：</p><p>SQL&gt;select protection_mode,protection_level from v$database; </p><h3 id="三．-自动裂缝检测和解决"><a href="#三．-自动裂缝检测和解决" class="headerlink" title="三． 自动裂缝检测和解决"></a>三． 自动裂缝检测和解决</h3><p>当Primary Database的某些日志没有成功发送到Standby Database，这时候发生了归档裂缝（Archive Gap）。</p><p>缺失的这些日志就是裂缝（Gap）。Data Guard能够自动检测，解决归档裂缝，不需要DBA的介入。这需要配置FAL_CLIENT，FAL_SERVER 这两个参数（FAL: Fetch Archive Log）。</p><p>从FAL 这个名字可以看出，这个过程是Standby Database主动发起的“取”日志的过程，Standby Database 就是FAL_CLIENT. 它是从FAL_SERVER中取这些Gap， 10g中，这个FAL_SERVER可以是Primary Database， 也可以是其他的Standby Database。</p><p>如：FAL_SERVER=’PR1,ST1,ST2’;</p><p>FAL_CLIENT和FAL_SERVER两个参数都是Oracle Net Name。FAL_CLIENT 通过网络向FAL_SERVER发送请求，FAL_SERVER通过网络向FAL_CLIENT发送缺失的日志。 但是这两个连接不一定是一个连接。 因此FAL_CLIENT向FAL_SERVER发送请求时，会携带FAL_CLIENT参数值，用来告诉FAL_SERVER应该向哪里发送缺少的日志。 这个参数值也是一个Oracle Net Name，这个Name是在FAL_SERVER上定义的，用来指向FAL_CLIENT.</p><p>当然，除了自动地日志缺失解决，DBA 也可以手工解决。 具体操作步骤如下：</p><p>1） 查看是否有日志GAP： </p><p>SQL&gt; SELECT UNIQUE THREAD#, MAX(SEQUENCE#) OVER(PARTITION BY THREAD#) LAST FROM V$ARCHIVED_LOG; </p><p>SQL&gt; SELECT THREAD#, LOW_SEQUENCE#, HIGH_SEQUENCE# FROM V$ARCHIVE_GAP; </p><p>2） 如果有，则拷贝过来</p><p>3） 手工的注册这些日志： </p><p>SQL&gt; ALTER DATABASE REGISTER LOGFILE ‘路径’; </p><h3 id="四．-指定日志发送对象"><a href="#四．-指定日志发送对象" class="headerlink" title="四． 指定日志发送对象"></a>四． 指定日志发送对象</h3><p>1．VALID_FOR属性指定传输及接收对象</p><p>LOG_ARCHIVE_DEST_n参数中的VALID_FOR属性，用来指定传输的内容。从字面理解VALID_FOR就是基于那谁有效，该属性有两个参数值需要指定：REDO_LOG_TYPE和DATABASE_ROLE，我们基本上可以将其理解为：发送指定角色生成的指定类型的日志文件，该参数的主要目的是为了确保，一旦发生角色切换操作后数据库的正常运转。</p><p>其中，REDO_LOG_TYPE和DATABASE_ROLE两个参数可供选择的参数值如下：</p><p>REDO_LOG_TYPE：可设置为ONLINE_LOGFILE、STANDBY_LOGFILE、ALL_LOGFILES。 </p><p>DATABASE_ROLE：可设置为PRIMARY_ROLE、STANDBY_ROLE、ALL_ROLES。 </p><p>注意：VALID_FOR参数默认值是：VALID_FOR=（ALL_LOGFILES,ALL_ROLES）。 </p><p>推荐手动设置该参数而不要使用默认值，在某些情况下默认的参数值不一定合适，如逻辑Standby在默认情况下就处于OPEN READ WRITE模式，不仅有REDO数据而且还包含多种日志文件（Online Redologs、Archived Redologs及Standby Redologs）。</p><p>默认情况下，逻辑Standby数据库生成的归档文件和接收到的归档文件在相同的路径下，这既不便于管理，也极有可能带来一些隐患。建议对每个LOG_ARCHIVE_DEST_n参数设置合适的VALID_FOR属性。本地生成的归档文件和接收到的归档文件最好分别保存于不同路径下。</p><p>2．通过DB_UNIQUE_NAME属性指定数据库</p><p>DB_UNIQUE_NAME属性是10g版本新增加的一个关键字，在之前版本并没有这一说法。该属性的作用是指定唯一的Oracle数据库名称，也正因有了DB_UNIQUE_NAME，REDO数据在传输过程中才能确认传输到DBA希望被传输到的数据库上。</p><p>当然要确保REDO数据被传输到指定服务器，除了在LOG_ARCHIVE_DEST_n参数中指定正确DB_UNIQUE_NAME属性之外，还有一个初始化参数LOG_ARCHIVE_CONFIG也需要进行正确的配置。该参数除了指定Data Guard环境中的唯一数据库名外，还包括几个属性，用来控制REDO数据的传输和接收：</p><p>SEND：允许数据库发送数据到远端。</p><p>RECEIVE：允许Standby接收来自其他数据库的数据。</p><p>NOSEND,NORECEIVE：自然就是禁止喽。</p><p>例如，设置Primary数据库不接收任何归档数据，可以做如下的设置：</p><p>LOG_ARCHIVE_CONFIG=’NORECEIVE,DG_CONFIG= (PRI,ST) ‘ </p><p>如果做了如上的设置，如果该服务器发生了角色切换，那它也没有接收REDO数据的能力。</p><h3 id="五．-Data-Guard环境应配置的初始化参数"><a href="#五．-Data-Guard环境应配置的初始化参数" class="headerlink" title="五． Data Guard环境应配置的初始化参数"></a>五． Data Guard环境应配置的初始化参数</h3><table><thead><tr><th>下列参数为Primary角色相关的初始化参数</th><th></th></tr></thead><tbody><tr><td>DB_NAME</td><td>注意保持同一个Data Guard中所有数据库DB_NAME相同例如：DB_NAME=Dave</td></tr><tr><td>DB_UNIQUE_NAME</td><td>为每一个数据库指定一个唯一的名称，该参数一经指定不会再发生变化，除非DBA主动修改它例如：DB_UNIQUE_NAME=DavePre</td></tr><tr><td>LOG_ARCHIVE_CONFIG</td><td>该参数用来控制从远端数据库接收或发送REDO数据，通过DG_CONFIG属性罗列同一个Data Guard中所有DB_UNIQUE_NAME（含Primary数据库和Standby数据库），以逗号分隔，SEND/NOSEND属性控制是否可以发送，RECEIVE/NORECEIVE属性控制是否能够接收例如：LOG_ARCHIVE_CONFIG=’DG_CONFIG=(DavePre,DaveDG)’</td></tr><tr><td>LOG_ARCHIVE_DEST_n</td><td>归档文件的生成路径。该参数非常重要，并且属性和子参数也特别多(可以直接查询Oracle官方文档。Data Guard白皮书第14章专门介绍了该参数各属性及子参数的功能和设置)。例如：LOG_ARCHIVE_DEST_1=’LOCATION=l:/oracle/oradata/Dave VALID_FOR=(ALL_LOGFILES,ALL_ROLES) DB_UNIQUE_NAME=DavePre’</td></tr><tr><td>LOG_ARCHIVE_DEST_STATE_n</td><td>是否允许REDO传输服务传输REDO数据到指定的路径。该参数共拥有4个属性值，功能各不相同。</td></tr><tr><td>REMOTE_LOGIN_PASSWORDFILE</td><td>推荐设置参数值为EXCLUSIVE或者SHARED，注意保证相同Data Guard配置中所有DB服务器SYS密码相同</td></tr><tr><td>以下参数为与Standby角色相关的参数（建议在Primary数据库的初始化参数中也进行设置，这样即使发  生角色切换，新的Standby也能直接正常运行）</td><td></td></tr><tr><td>FAL_SERVER</td><td>指定一个Net服务名，该参数值对应的数据库应为Primary角色。当本地数据库为Standby角色时，如果发现存在归档中断的情况，该参数用来指定获取中断的归档文件的服务器例如：FAL_SERVER=DavePre提示：FAL是Fetch Archived Log的缩写FAL_SERVER参数支持多个参数值的哟，相互间以逗号分隔</td></tr><tr><td>FAL_CLIENT</td><td>又指定一个Net服务名，该参数对应数据库应为Standby角色。当本地数据库以Primary角色运行时，向参数值中指定的站点发送中断的归档文件例如：FAL_CLIENT=DaveDGFAL_CLIENT参数也支持多个参数值，相互间以逗号分隔。</td></tr><tr><td>DB_FILE_NAME_CONVERT</td><td>Standby数据库的数据文件路径与Primary数据库数据文件路径不一致时，可以通过设置DB_FILE_NAME_CONVERT参数的方式让其自动转换。该参数值应该成对出现，前面的值表示转换前的形式，后面的值表示转换后的形式例如：DB_FILE_NAME_CONVERT=’f:/oradata/DavePre’,’l:/oradata/DaveDG’</td></tr><tr><td>LOG_FILE_NAME_CONVERT</td><td>使用方式与上相同，只不过LOG_FILE_NAME_CONVERT专用来转换日志文件路径例如：LOG_FILE_NAME_CONVERT=’f:/oradata/DavePre’,’l:/oradata/DaveDG’</td></tr><tr><td>STANDBY_FILE_MANAGEMENT</td><td>如果Primary数据库数据文件发生修改（如新建、重命名等）则按照本参数的设置在Standby数据库中作相应修改。设为AUTO表示自动管理。设为MANUAL表示需要手工管理例如：STANDBY_FILE_MANAGEMENT=AUTO</td></tr></tbody></table><p>对于归档失败的处理，LOG_ARCHIVE_DEST_n参数有几个属性，可以用来控制归档过程中出现故障时应该采取的措施。</p><p>1．REOPEN 指定时间后再次尝试归档</p><p>使用REOPEN=seconds（默认为300秒）属性，在指定时间重复尝试向归档目的地进行归档操作，如果该参数值设置为0，则一旦失败就不会再尝试重新连接并发送，直到下次REDO数据再被归档时会重新尝试。</p><p>例如，设置REOPEN为100秒：</p><p>LOG_ARCHIVE_DEST_2=’SERVICE=DavePrimary LGWR ASYNC REOPEN=100’ </p><p>2．ALTERNATE 指定替补的归档目的地</p><p>ALTERNATE属性定义一个替补的归档目的地，所谓替补就是一旦主归档目的地因各种原因无法使用，则临时向ALTERNATE属性中指定的路径写。</p><p>例如：</p><p>LOG_ARCHIVE_DEST_1=’LOCATION=/disk1 ALTERNATE=LOG_ARCHIVE_DEST_2’ </p><p>LOG_ARCHIVE_DEST_STATE_1=ENABLE </p><p>LOG_ARCHIVE_DEST_2=’LOCATION=/disk2’ </p><p>LOG_ARCHIVE_DEST_STATE_2=ALTERNATE </p><p>上述参数设置归档路径为/disk1，当/disk1路径下无法成功归档时，自动尝试向/disk2路径下归档文件。</p><p>从功能上来看，REOPEN与ALTERNATE是有一定重复的，不过需要注意一点，REOPEN属性比ALTERNATE属性的优先级要高，如果你指定REOPEN属性的值&gt;0，则LGWR（或ARCn）进程会首先尝试向主归档目的地写入，直到达到最大重试次数，如果仍然写入失败，才会向ALTERNATE属性指定的路径写。</p><p>3．MAX_FAILURE 控制失败尝试次数</p><p>用REOPEN指定失败后重新尝试的时间周期，MAX_FAILURE则控制失败尝试的次数。</p><p>例如，设置LOG_ARCHIVE_DEST_1在本地归档文件时，如果遇到错误，则每隔100秒尝试一次，共尝试不超过3次，设置如下：</p><p>LOG_ARCHIVE_DEST_1=’LOCATION=E:/ora10g/oradata/jsspdg/ REOPEN=100 MAX_FAILURE=3’ </p><h3 id="六．-物理Standby-和逻辑Standby-的区别"><a href="#六．-物理Standby-和逻辑Standby-的区别" class="headerlink" title="六． 物理Standby 和逻辑Standby 的区别"></a>六． 物理Standby 和逻辑Standby 的区别</h3><p>Standby数据库类型分为两类：物理Standby和逻辑Standby。</p><p>1．物理Standby</p><p>我们知道物理Standby与Primary数据库完全一模一样，DG通过REDO应用来维护物理Standby数据库。</p><p>通常在物理Standby没有执行REDO应用操作的时候，可以将物理Standby数据库以READ ONLY模式打开，如果数据库中指定了Flashback Area的话，甚至还可以被临时性的置为READ WRITE模式，操作完之后再通过Flashback Database特性恢复回READ WRITE前的状态，以便继续接收Primary端发送的REDO并应用。</p><p>REDO应用。物理Standby通过REDO应用来保持与Primary数据库的一致性，所谓的REDO应用，实质是通过Oracle的恢复机制，应用归档文件（或Standby Redologs文件）中的REDO数据。恢复操作属于块对块的应用。如果正在执行REDO应用的操作，Oracle数据库就不能被Open。</p><p>READ ONLY模式打开。以READ ONLY模式打开后，可以在Standby数据库执行查询或备份等操作（变相减轻Primary数据库压力）。此时Standby数据库仍然能够继续接收Primary数据库发送的REDO数据，不过并不会应用，直到Standby数据库重新恢复REDO应用。</p><p>也就是说在READ ONLY模式下不能执行REDO应用，REDO应用时数据库肯定处于未打开状态。如果需要的话，你可以在两种状态间转换，如先应用REDO，然后将数据库置为READ ONLY状态，需要与Primary同步时再次执行REDO应用命令，切换回REDO应用状态。</p><p>提 示： Oracle 11g版本中增强物理Standby的应用功能，在11g版本中，物理Standby可以在OPEN READ ONLY模式下继续应用REDO数据，这就极大地提升了物理Standby数据库的应用场合。</p><p>READ WRITE模式打开。如果以READ WRITE模式打开，那么Standby数据库将暂停从Primary数据库接收REDO数据，并且暂时失去灾难保护的功能。当然，以READ WRITE模式打开也并非一无是处，如你可能需要临时调试一些数据，但又不方便在正式库中操作，那就可以临时将Standby数据库置为READ WRITE模式，操作完之后将数据库闪回到操作前的状态（闪回之后，Data Guard会自动同步，不需要重建物理Standby，不过如果从另一个方向看，没有启动闪回，那就回不到READ WRITE前的状态了）。</p><p>物理Standby特点如下：</p><p>（1）灾难恢复及高可用性。物理Standby提供了一个健全、高效的灾难恢复，以及高可用性的解决方案。更加易于管理switchover/failover角色转换及在更短的计划内或计划外停机时间。</p><p>（2）数据保护。使用物理Standby数据库，DG能够确保即使面对无法预料的灾害也能够不丢失数据。前面也提到物理Standby是基于块对块的复制，因此与对象、语句无关，Primary数据库上有什么，物理Standby数据库端也会有什么。</p><p>（3）分担Primary数据库压力。通过将一些备份任务、仅查询的需求转移到物理Standby数据库，可以有效节省Primary数据库的CPU及I/O资源。</p><p>（4）提升性能。物理Standby所使用的REDO应用技术使用最底层的恢复机制，这种机制能够绕过SQL级代码层，因此效率最高。</p><p>2．逻辑Standby</p><p>逻辑Standby也要通过Primary数据库（或其备份，或其复制库，如物理Standby）创建，因此在创建之初与物理Standby数据库类似。不过由于逻辑Standby通过SQL应用的方式应用REDO数据，因此逻辑Standby的物理文件结构，甚至数据的逻辑结构都可以与Primary不一致。</p><p>与物理Standby不同，逻辑Standby正常情况下是以READ WRITE模式打开，用户可以在任何时候访问逻辑Standby数据库，就是说逻辑Standby是在OPEN状态执行SQL应用。同样有利也有弊，由于SQL应用自身特点，逻辑Standby对于某些数据类型及一些DDL/DML语句会有操作上的限制。可以在视图DBA_LOGSTDBY_UNSUPPORTED 中查看不支持的数据类型，如果使用了这种数据类型，则不能保证数据库完全一致。</p><p>逻辑Standby 的读写打开可以使它做报表系统，这样减轻系统的压力。</p><p>除了上述物理Standby中提到的类似灾难恢复、高可用性及数据保护等特点之外，逻辑Standby还有下列一些特点：</p><p>（1）有效地利用备机的硬件资源。除灾难恢复外，逻辑Standby数据库还可用于其他业务需求。如通过在Standby数据库创建额外的索引、物化视图等提高查询性能并满足特定业务需要；又如创建新的SCHEMA（该SCHEMA在Primary数据库端并不存在），然后在这些SCHEMA中执行那些不适于在Primary数据库端执行的DDL或者DML操作等。</p><p>（2）分担Primary数据库压力。逻辑Standby数据库可以在保持与Primary同步时仍然置于打开状态，这使得逻辑Standby数据库能够同时用于数据保护和报表操作，从而将主数据库从报表和查询任务中解脱出来，节约宝贵的 CPU和I/O资源。</p><p>（3）平滑升级。可以通过逻辑Standby来实现如跨版本升级，为数据库打补丁等操作。应该说应用的空间很大，而带来的风险却很小（前提是如果你拥有足够的技术实力。另外虽然物理Standby也能够实现一些升级操作，但如果跨平台的话恐怕就力不从心了，所以此项没有作为物理Standby的特点列出），我个人认为这是一种值得可行的在线的滚动的平滑的升级方式，如果你的应用支持创建逻辑Standby的话。</p><h3 id="七．-Log应用服务（Log-Apply-Services）"><a href="#七．-Log应用服务（Log-Apply-Services）" class="headerlink" title="七． Log应用服务（Log Apply Services）"></a>七． Log应用服务（Log Apply Services）</h3><p>Data Guard通过应用REDO维持Primary数据库与各Standby数据库之间的一致性，在后台默默无闻地支撑着的就是传说中的Log应用服务。Log应用服务又分以下两种方式：</p><p>REDO应用：物理Standby数据库专用，通过介质恢复的方式保持与Primary数据库的同步。</p><p>SQL应用：逻辑Standby数据库专用，核心是通过LogMiner分析出SQL语句在Standby端执行。</p><p>因此物理Standby在应用REDO数据时必须是MOUNT状态，而逻辑Standby则是以READ WRITE模式打开并应用REDO数据，不过被维护的对象默认处于只读状态，无法在逻辑Standby端直接修改。</p><p>7.1 Log应用服务配置选项</p><p>默认情况下，Log应用服务会等待单个归档文件全部接收之后再启动应用，如果Standby数据库配置了Standby Redologs，就可以打开实时应用（Real-Time Apply），这样Data Guard就不需要再等待接收完归档文件，只要RFS进程将REDO数据写入Standby Redologs，即可通过MRP/LSP实时写向Standby数据库。</p><p>7.1.1．REDO数据实时应用</p><p>启动实时应用的优势在于，REDO数据不需要等待归档完成，接收到即可被应用，这样执行角色切换时，操作能够执行得更快，因为日志是被即时应用的。</p><p>要启动实时应用也简单，前提是Standby数据库端配置了Standby Redologs。</p><p>物理Standby要启用实时应用，要在启动REDO应用的语句后附加USING CURRENT LOGFIE子句，例如：</p><p>SQL&gt; ALTER DATABASE RECOVER MANAGED STANDBY DATABASE USING CURRENT LOGFILE ; </p><p>逻辑Standby要启用实时应用，只需要在启动REDO应用的语句后附加IMMEDIATE子句即可，例如：</p><p>SQL&gt; ALTER DATABASE START LOGICAL STANDBY APPLY IMMEDIATE; </p><p>7.1.2．REDO数据延迟应用</p><p>有实时就有延迟，某些情况下你可能不希望Standby数据库与Primary太过同步，那就可以在Primary数据库端发送REDO数据的相应LOG_ARCHIVE_DEST_n参数中指定DELAY属性（单位为分钟，如果指定了DELAY属性，但没有指定值，则默认是30分钟）。</p><p>注意：该属性并不是说延迟发送REDO数据到Standby，而是指明归档到Standby后，开始应用的时间。</p><p>例如：设置LOG_ARCHIVE_DEST_3的DELAY属性为15分钟：</p><p>SQL&gt; ALTER SYSTEM SET LOG_ARCHIVE_DEST_3=’SERVICE=DavePrimary ARCH VALID_ FOR= </p><p>(ONLINE_LOGFILES, PRIMARY_ROLE) DB_UNIQUE_NAME=Dave DELAY=15’; </p><p>不过，如果DBA在启动REDO应用时指定了实时应用，那么即使在LOG_ ARCHIVE_DEST_n参数中指定了DELAY属性，Standby数据库也会忽略DELAY属性。</p><p>另外，Standby端还可以在启动REDO应用时，通过附加NODELAY子句的方式，取消延迟应用。</p><p>物理Standby可以通过下列语句取消延迟应用：</p><p>SQL&gt; ALTER DATABASE RECOVER MANAGED STANDBY DATABASE NODELAY; </p><p>逻辑Standby可以通过下列语句取消延迟应用：</p><p>SQL&gt; ALTER DATABASE START LOGICAL STANDBY APPLY NODELAY; </p><p>一般设置延迟应用的需求都是基于容错方面的考虑，如Primary数据库端由于误操作，数据被意外修改或删除，只要Standby数据库尚未应用这些修改，你就可以快速从Standby数据库中恢复这部分数据。不过自Oracle从9i版本开始提供FLASHBACK特性之后，对于误操作使用FLASHBACK特性进行恢复，显然更加方便快捷，因此DELAY方式延迟应用已经非常少见了。</p><p>7.2 应用REDO数据到Standby数据库</p><p>7.2.1．物理Standby应用REDO数据</p><p>物理Standby启动REDO应用，数据库要处于MOUNT状态或是OPEN READ ONLY状态，启动REDO应用的命令相信大家已经非常熟悉了。</p><p>前台应用：</p><p>SQL&gt; ALTER DATABASE RECOVER MANAGED STANDBY DATABASE; </p><p>语句执行完成后，不会将控制权返回到命令行窗口，除非你手动中止应用。在这种情况下如果还需要对数据库进行操作，只能新开一个命令行连接，在Oracle 8i刚推出Standby特性时（那时不叫Data Guard），只提供了这种方式。</p><p>后台应用：</p><p>SQL&gt; ALTER DATABASE RECOVER MANAGED STANDBY DATABASE DISCONNECT; </p><p>这是现在比较通用的方式，语句执行完后，控制权自动返回到当前的命令行模式，REDO应用以后台进程运行。</p><p>启动实时应用，附加USING CURRENT LOGFILE子句即可：</p><p>SQL&gt; ALTER DATABASE RECOVER MANAGED STANDBY DATABASE USING CURRENT LOGFILE; </p><p>如果要停止REDO应用，执行下列语句即可：</p><p>SQL&gt; ALTER DATABASE RECOVER MANAGED STANDBY DATABASE CANCEL; </p><p>7.2.2．逻辑Standby应用REDO数据</p><p>SQL应用的原理是将接收到的REDO数据转换成SQL语句在逻辑Standby数据库端执行，因此逻辑Standby需要启动至OPEN状态。</p><p>（1）启动SQL应用。逻辑Standby数据库启动SQL应用没有前、后台运行之说，语句执行完之后，控制权就会自动返回当前命令行窗口。</p><p>要启动SQL应用，直接执行下列语句即可：</p><p>SQL&gt; ALTER DATABASE START LOGICAL STANDBY APPLY; </p><p>如果要启动实时应用，附加IMMEDIATE子句即可，例如：</p><p>SQL&gt; ALTER DATABASE START LOGICAL STANDBY APPLY IMMEDIATE; </p><p>（2）停止SQL应用，如：</p><p>SQL&gt; ALTER DATABASE STOP LOGICAL STANDBY APPLY; </p><p>由于是执行SQL语句的方式应用REDO数据，因此上述语句的执行需要等待当前执行的SQL触发的事务结束，才能真正停止REDO应用的状态。</p><p>如果不考虑事务执行情况，马上停止REDO应用，可以通过下列的语句来完成：</p><p>SQL&gt; ALTER DATABASE ABORT LOGICAL STANDBY APPLY; </p><h3 id="–核心进程介绍"><a href="#–核心进程介绍" class="headerlink" title="–核心进程介绍"></a>–核心进程介绍</h3><p><strong>RFS：remote file server。</strong><br>该进程是standby库接受来自primary库lgwr进程触发的redo信息并且写入到standby redo log中。RFS进程无疑是要和其他进程配合的，也就是传输的进程。那这里就需要上篇的知识了，我们知道触发同步可能由ARCH或者是LGWR进程触发的，两者是不同的。如果是LGWR进程触发，那10g前的话也是由LGWR进程负责传输redo信息，RFS进程负责接收redo信息写入standby redo log中，10g之后则由LNSn进程完成；如果是ARCH进程触发，也就是归档日志传输的话，那就是由ARCH进程负责传输，RFS进程负责接收，然后写入指定的归档位置，然后再应用的。那这里不同的设置也决定了参数LOG_ARCHIVE_DEST_n的不同设置。详细见下。</p><p><strong>LNSn：</strong>LGWR触发以后真正负责传输的进程，包括初始化网络I/O等一些列功能。</p><p><strong>MRP：</strong>managed recovery process，简单来说就是物理standby是通过这个进程来实现数据的同步的，直接通过standby redo log或者是归档日志（取决于模式不同）来进行的一个数据恢复。</p><p><strong>LSP：</strong>logical standby process：逻辑standby的方式，和上面的一样，只不过当中多了一步将redo信息转换成sql语句再恢复。也可以从这里看出逻辑standby和物理standby的不同。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;RAC，Data Gurad，Stream 是Oracle高可用性体系中的三种工具，每个工具即可以独立应用，也可以相互配合。他们各自的侧重点不同，适用场景也不同。&lt;/p&gt;
&lt;p&gt;RAC它的强项在于&lt;strong&gt;解决单点故障和负载均衡&lt;/strong&gt;，因此RAC方案常用于
      
    
    </summary>
    
    
      <category term="Oracle" scheme="https://husky-wu.github.io/categories/Oracle/"/>
    
    
      <category term="Oracle" scheme="https://husky-wu.github.io/tags/Oracle/"/>
    
  </entry>
  
  <entry>
    <title>数据库建表-SQL-索引规范</title>
    <link href="https://husky-wu.github.io/2020/12/19/MySQL/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BB%BA%E8%A1%A8-SQL-%E7%B4%A2%E5%BC%95%E8%A7%84%E8%8C%83/"/>
    <id>https://husky-wu.github.io/2020/12/19/MySQL/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BB%BA%E8%A1%A8-SQL-%E7%B4%A2%E5%BC%95%E8%A7%84%E8%8C%83/</id>
    <published>2020-12-18T17:25:59.000Z</published>
    <updated>2020-12-28T02:28:44.074Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>因为工作岗位的原因，负责制定了关于后端组数据库的规约规范，作为所有产品线的规范，历经几版的修改，最终形成下边的文本。</p><p>规范在整个后端执行也有大半年的时间，对于整个团队在开发阶段就减少不恰当的建表语句、错误SQL、错误的索引有积极的意义，故分享出来给大家参考。</p><p>下边分为<strong>建表规约、SQL规约、索引规约</strong>三个部分，每部分的每一条都有<strong>强制、建议</strong>两个级别，大家在参考时，根据自己公司的情况来权衡。</p><h2 id="一、建表规约"><a href="#一、建表规约" class="headerlink" title="一、建表规约"></a><strong>一、建表规约</strong></h2><p><strong>【强制】（1） 存储引擎必须使用InnoDB</strong></p><blockquote><p><strong>解读：</strong>InnoDB支持事物、行级锁、并发性能更好，CPU及内存缓存页优化使得资源利用率更高。</p></blockquote><p><strong>【强制】（2）每张表必须设置一个主键ID，且这个主键ID使用自增主键（在满足需要的情况下尽量短），除非在分库分表环境下</strong></p><blockquote><p><strong>解读：</strong>由于InnoDB组织数据的方式决定了需要有一个主键，而且若是这个主键ID是单调递增的可以有效提高插入的性能，避免过多的页分裂、减少表碎片提高空间的使用率。 而在分库分表环境下，则需要统一来分配各个表中的主键值，从而避免整个逻辑表中主键重复。</p></blockquote><p><strong>【强制】（3）必须使用utf8mb4字符集</strong></p><blockquote><p><strong>解读：</strong>在Mysql中的UTF-8并非“真正的UTF-8”，而utf8mb4”才是真正的“UTF-8”。</p></blockquote><p><strong>【强制】（4） 数据库表、表字段必须加入中文注释</strong></p><blockquote><p><strong>解读：</strong>大家都别懒。</p></blockquote><p><strong>【强制】（5） 库名、表名、字段名均小写，下划线风格，不超过32个字符，必须见名知意，禁止拼音英文混用</strong></p><blockquote><p><strong>解读：</strong>约定。</p></blockquote><p><strong>【强制】（6）单表列数目必须小于30，若超过则应该考虑将表拆分</strong></p><blockquote><p><strong>解读：</strong>单表列数太多使得Mysql服务器处理InnoDB返回数据之间的映射成本太高。</p></blockquote><p><strong>【强制】（7）禁止使用外键，如果有外键完整性约束，需要应用程序控制</strong></p><blockquote><p><strong>解读：</strong>外键会导致表与表之间耦合，UPDATE与DELETE操作都会涉及相关联的表，十分影响SQL的性能，甚至会造成死锁。</p></blockquote><p><strong>【强制】（8）必须把字段定义为NOT NULL并且提供默认值</strong></p><blockquote><p><strong>解读：</strong> </p></blockquote><ul><li>NULL的列使索引/索引统计/值比较都更加复杂，对MySQL来说更难优化；</li><li>NULL这种类型Msql内部需要进行特殊处理，增加数据库处理记录的复杂性；同等条件下，表中有较多空字段的时候，数据库的处理性能会降低很多；</li><li>NULL值需要更多的存储空，无论是表还是索引中每行中的NULL的列都需要额外的空间来标识。</li></ul><p><strong>【强制】（9）禁用保留字，如DESC、RANGE、MARCH等，请参考Mysql官方保留字</strong></p><p><strong>【强制】（10）如果存储的字符串长度几乎相等，使用CHAR定长字符串类型。</strong></p><blockquote><p><strong>解读：</strong>能够减少空间碎片，节省存储空间。</p></blockquote><p><strong>【建议】（11）在一些场景下，考虑使用TIMESTAMP代替DATETIME</strong></p><blockquote><p><strong>解读：</strong></p></blockquote><ul><li>这两种类型的都能表达”yyyy-MM-dd HH:mm:ss”格式的时间，TIMESTAMP只需要占用4个字节的长度，可以存储的范围为(1970-2038)年，在各个时区，所展示的时间是不一样的；</li><li>而DATETIME类型占用8个字节，对时区不敏感，可以存储的范围为(1001-9999)年。</li></ul><p><strong>*** **【建议】（12）当心自动生成的Schema，建议所有的Schema手动编写</strong></p><blockquote><p><strong>解读：</strong>对于一些数据库客户端不要太过信任。</p></blockquote><h2 id="二、SQL规约"><a href="#二、SQL规约" class="headerlink" title="二、SQL规约"></a><strong>二、SQL规约</strong></h2><p><strong>【建议】 (1) 为了充分利用缓存，不允许使用自定义函数、存储函数、用户变量</strong></p><blockquote><p><strong>解读：</strong>如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表、Mysql库中的系统表，其查询结果都不会被缓存。比如函数NOW()或者CURRENT_DATE()会因为不同的查询时间，返回不同的查询结果。</p></blockquote><p><strong>【强制】（2）在查询中指定所需的列，而不是直接使用“ *”返回所有的列</strong></p><blockquote><p><strong>解读：</strong></p></blockquote><ul><li>读取不需要的列会增加CPU、IO、NET消耗；</li><li>不能有效的利用覆盖索引。</li></ul><p><strong>【强制】（3）不允许使用属性隐式转换</strong></p><blockquote><p><strong>解读：</strong>假设我们在手机号列上添加了索引，然后执行下面的SQL会发生什么？explain SELECT user_name FROM parent WHERE phone=13812345678; 很明显就是索引不生效，会全表扫描。</p></blockquote><p><strong>【建议】（4）在WHERE条件的属性上使用函数或者表达式</strong></p><blockquote><p><strong>解读：</strong>Mysql无法自动解析这种表达式，无法使用到索引。</p></blockquote><p><strong>【强制】（5）禁止使用外键与级联，一切外键概念必须在应用层解决</strong></p><blockquote><p><strong>解读：</strong>外键与级联更新适用于单机低并发，不适合分布式、高并发集群;级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。</p></blockquote><p><strong>【建议】（6）应尽量避免在WHERE子句中使用or作为连接条件</strong></p><blockquote><p><strong>解读：</strong>根据情况可以选择使用UNION ALL来代替OR。</p></blockquote><p><strong>【强制】（7）不允许使用%开头的模糊查询</strong></p><blockquote><p><strong>解读：</strong>根据索引的最左前缀原理，%开头的模糊查询无法使用索引，可以使用ES来做检索。</p></blockquote><h2 id="三、索引规约"><a href="#三、索引规约" class="headerlink" title="三、索引规约"></a><strong>三、索引规约</strong></h2><p><strong>【建议】（1）避免在更新比较频繁、区分度不高的列上单独建立索引</strong></p><blockquote><p><strong>解读：</strong>区分度不高的列单独创建索引的优化效果很小，但是较为频繁的更新则会让索引的维护成本更高。</p></blockquote><p><strong>【强制】（2） JOIN的表不允许超过五个。需要JOIN的字段，数据类型必须绝对一致; 多表关联查询时，保证被关联的字段需要有索引</strong></p><blockquote><p><strong>解读：</strong>太多表的JOIN会让Mysql的优化器更难权衡出一个“最佳”的执行计划（可能性为表数量的阶乘），同时要注意关联字段的类型、长度、字符编码等等是否一致。</p></blockquote><p><strong>【强制】（3）在一个联合索引中，若第一列索引区分度等于1，那么则不需要建立联合索引</strong></p><blockquote><p><strong>解读：</strong>索引通过第一列就能够完全定位的数据，所以联合索引的后边部分是不需要的。</p></blockquote><p><strong>【强制】（4）建立联合索引时，必须将区分度更高的字段放在左边</strong></p><blockquote><p><strong>解读：</strong>区分度更高的列放在左边，能够在一开始就有效的过滤掉无用数据。提高索引的效率，相应我们在Mapper中编写SQL的WHERE条件中有多个条件时，需要先看看当前表是否有现成的联合索引直接使用，注意各个条件的顺序尽量和索引的顺序一致。</p></blockquote><p><strong>【建议】（5）利用覆盖索引来进行查询操作，避免回表</strong></p><blockquote><p><strong>解读：</strong>覆盖查询即是查询只需要通过索引即可拿到所需DATA，而不再需要再次回表查询，所以效率相对很高。我们在使用EXPLAIN的结果，extra列会出现：”using index”。这里也要强调一下不要使用“SELECT * ”，否则几乎不可能使用到覆盖索引。</p></blockquote><p><strong>【建议】（6）在较长VARCHAR字段,例如VARCHAR(100)上建立索引时，应指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度即可</strong></p><blockquote><p><strong>解读：</strong>索引的长度与区分度是一对矛盾体，一般对字符串类型数据，若长度为20的索引，区分度会高达90%以上，则可以考虑创建长度例为20的索引，而非全字段索引。例如可以使用SELECT COUNT(DISTINCT LEFT(lesson_code, 20)) / COUNT(*) FROM lesson;来确定lesson_code字段字符长度为20时文本区分度。</p></blockquote><p><strong>【建议】（7）如果有ORDER BY的场景，请注意利用索引的有序性。ORDER BY最后的字段是联合索引的一部分，并且放在索引组合顺序的最后，避免出现file_sort的情况，影响查询性能。</strong></p><blockquote><p><strong>解读：</strong> </p></blockquote><ul><li>假设有查询条件为WHERE a=? and b=? ORDER BY c；存在索引：a_b_c，则此时可以利用索引排序；</li><li>反例：在查询条件中包含了范围查询，那么索引有序性无法利用，如:WHERE a&gt;10 ORDER BY b; 索引a_b无法排序。</li></ul><p><strong>【建议】（8）在where中索引的列不能某个表达式的一部分，也不能是函数的参数</strong></p><blockquote><p><strong>解读：</strong>即是某列上已经添加了索引，但是若此列成为表达式的一部分、或者是函数的参数，Mysql无法将此列单独解析出来，索引也不会生效。</p></blockquote><p><strong>【建议】 （9）我们在where条件中使用范围查询时，索引最多用于一个范围条件，超过一个则后边的不走索引</strong></p><blockquote><p><strong>解读：</strong>Mysql能够使用多个范围条件里边的最左边的第一个范围查询，但是后边的范围查询则无法使用。</p></blockquote><p><strong>【建议】 （10）在多个表进行外连接时，表之间的关联字段类型必须完全一致</strong></p><blockquote><p><strong>解读：</strong>当两个表进行Join时，字段类型若没有完全一致，则加索引也不会生效，这里的完全一致包括但不限于字段类型、字段长度、字符集、collection等等。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;因为工作岗位的原因，负责制定了关于后端组数据库的规约规范，作为所有产品线的规范，历经几版的修改，最终形成下边的文本。&lt;/p&gt;
&lt;p&gt;规范在整
      
    
    </summary>
    
    
      <category term="MySQL" scheme="https://husky-wu.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://husky-wu.github.io/tags/MySQL/"/>
    
      <category term="数据库" scheme="https://husky-wu.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Oracle" scheme="https://husky-wu.github.io/tags/Oracle/"/>
    
      <category term="SQL server" scheme="https://husky-wu.github.io/tags/SQL-server/"/>
    
  </entry>
  
  <entry>
    <title>MySQL体系结构及存储引擎</title>
    <link href="https://husky-wu.github.io/2020/12/18/MySQL/MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/"/>
    <id>https://husky-wu.github.io/2020/12/18/MySQL/MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/</id>
    <published>2020-12-18T07:47:57.000Z</published>
    <updated>2020-12-28T02:28:33.390Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL体系结构"><a href="#MySQL体系结构" class="headerlink" title="MySQL体系结构"></a>MySQL体系结构</h2><p><img src="../MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/mysql%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9B%BE.jpg" alt title="null"></p><p>连接者：不同语言的代码程序和mysql的交互（SQL交互）<br><strong>1、连接池</strong> 管理、缓冲用户的连接，线程处理等需要缓存的需求<br><strong>2、管理服务和工具组件</strong> 系统管理和控制工具，例如备份恢复、Mysql复制、集群等<br><strong>3、sql接口</strong> 接受用户的SQL命令，并且返回用户需要查询的结果<br><strong>4、查询解析器</strong> SQL命令传递到解析器的时候会被解析器验证和解析(权限、语法结构)<br><strong>5、查询优化器</strong> SQL语句在查询之前会使用查询优化器对查询进行优化<br>select id,name from user where age = 40;<br>a、这个select 查询先根据where 语句进行选取，而不是先将表全部查询出来以后再进行age过滤<br>b、这个select查询先根据id和name进行属性投影，而不是将属性全部取出以后再进行过滤<br>c、将这两个查询条件联接起来生成最终查询结果<br><strong>6、缓存</strong> 如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据<br><strong>7、插入式存储引擎</strong> 存储引擎说白了就是如何管理操作数据（存储数据、如何更新、查询数据等）的一种方法。因为在关系数据库中数据的存储是以表的形式存储的，所以存储引擎也可以称为表类型（即存储和操作此表的类型）</p><p>说明：<br>在Oracle 和SQL Server等数据库中，所有数据存储管理机制都是一样的。而MySql数据库提供了多种存储引擎。<br>用户可以根据不同的需求为数据表选择不同的存储引擎，用户也可以根据自己的需要编写自己的存储引擎。<br>甚至一个库中不同的表使用不同的存储引擎，这些都是允许的。</p><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p><img src="../MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%8A%9F%E8%83%BD.jpg" alt title="null"></p><h3 id="MyISAM存储引擎"><a href="#MyISAM存储引擎" class="headerlink" title="MyISAM存储引擎"></a>MyISAM存储引擎</h3><p>由于该存储引擎不支持事务、也不支持外键，所以访问速度较快。因此当对事务完整性没有要求并以访问为主的应用适合使用该存储引擎。适合olap（在线分析处理），其中myd:放数据文件，myi:放索引文件</p><h3 id="InnoDB存储引擎"><a href="#InnoDB存储引擎" class="headerlink" title="InnoDB存储引擎"></a>InnoDB存储引擎</h3><p>mysql 5.5版本以后默认的存储引擎<br>由于该存储引擎在事务上具有优势，即支持具有提交、回滚及崩溃恢复能力等事务特性，所以比MyISAM存储引擎占用更多的磁盘空间。因此当需要频繁的更新、删除操作，同时还对事务的完整性要求较高，需要实现并发控制，建议选择。</p><p>面向oltp(online transaction processing)、行锁、支持外键、非锁定读、默认采用repeatable级别（可重复读）通过next-keylocking策略避免幻读、插入缓冲、二次写、自适应哈希索引、预读。</p><h3 id="MEMORY存储引擎"><a href="#MEMORY存储引擎" class="headerlink" title="MEMORY存储引擎"></a>MEMORY存储引擎</h3><p>MEMORY存储引擎存储数据的位置是内存，因此访问速度最快，但是安全上没有保障。适合于需要快速的访问或临时表。 数据存放在内存中，表锁，并发性能差，默认使用哈希索引</p><h3 id="BLACKHOLE存储引擎"><a href="#BLACKHOLE存储引擎" class="headerlink" title="BLACKHOLE存储引擎"></a>BLACKHOLE存储引擎</h3><p>黑洞存储引擎，写入的任何数据都会消失，可以应用于主备复制中的分发主库。</p><h3 id="NDB存储引擎"><a href="#NDB存储引擎" class="headerlink" title="NDB存储引擎"></a>NDB存储引擎</h3><p>集群存储引擎，share nothing，可提高可用性</p><h3 id="Archive存储引擎"><a href="#Archive存储引擎" class="headerlink" title="Archive存储引擎"></a>Archive存储引擎</h3><p>只支持insert和select zlib算法压缩1：10，适合存储归档数据如日志等、行锁</p><h2 id="物理文件"><a href="#物理文件" class="headerlink" title="物理文件"></a>物理文件</h2><p>物理文件包括：日志文件，数据文件，配置文件，pid文件,socket文件等</p><h3 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h3><p> <img src="../MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/logfile.png" alt="img" title="null"></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">error </span>log  错误日志    排错  /var/log/mysqld.log【默认开启】</span><br><span class="line">bin log    二进制日志  备份  增量备份 DDL DML DCL</span><br><span class="line">Relay log  中继日志    复制  接收 replication master</span><br><span class="line">slow log   慢查询日志  调优  查询时间超过指定值</span><br></pre></td></tr></table></figure><h4 id="Error-Log"><a href="#Error-Log" class="headerlink" title="Error Log"></a>Error Log</h4><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">log</span>-<span class="built_in">error</span>=/<span class="built_in">var</span>/<span class="built_in">log</span>/mysqld.<span class="built_in">log</span></span><br></pre></td></tr></table></figure><h4 id="Binary-Log"><a href="#Binary-Log" class="headerlink" title="Binary Log"></a>Binary Log</h4><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">log</span>-bin=/var/<span class="built_in">log</span>/mysql-bin/bin.<span class="built_in">log</span></span><br><span class="line">server-<span class="built_in">id</span>=<span class="number">2</span> <span class="number">5.7</span>.x版本后</span><br></pre></td></tr></table></figure><h4 id="Slow-Query-Log"><a href="#Slow-Query-Log" class="headerlink" title="Slow Query Log"></a>Slow Query Log</h4><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">slow_query_log</span>=<span class="number">1</span>|<span class="number">0</span></span><br><span class="line"><span class="attr">slow_query_log_file</span>=/var/log/mysql-slow/slow.log</span><br><span class="line"><span class="attr">long_query_time</span>=<span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/etc/<span class="keyword">my</span>.cnf—&gt;/etc/mysql/<span class="keyword">my</span>.cnf—&gt;/usr/etc/<span class="keyword">my</span>.cnf—&gt; ~/.<span class="keyword">my</span>.cnf</span><br><span class="line">如果冲突，以最后一个读取的为准</span><br><span class="line">[mysqld]组中包括了mysqld服务启动时的初始化参数</span><br><span class="line">[client]组中包含着客户端工具程序可以读取的参数，此外还有其他针对各个客户端软件的特定参数组等</span><br></pre></td></tr></table></figure><h3 id="数据文件"><a href="#数据文件" class="headerlink" title="数据文件"></a>数据文件</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1、<span class="selector-class">.frm</span>文件</span><br><span class="line">不论是什么存储引擎，每一个表都会有一个以表名命名的<span class="selector-class">.frm</span>文件，与表相关的元数据（<span class="selector-tag">meta</span>)信息都存放在此文件中，包括表结构的定义信息等。</span><br><span class="line">2、<span class="selector-class">.MYD</span>文件</span><br><span class="line"><span class="selector-tag">myisam</span>存储引擎专用，存放<span class="selector-tag">myisam</span>表的数据（<span class="selector-tag">data</span>)。每一个<span class="selector-tag">myisam</span>表都会有一个<span class="selector-class">.MYD</span>文件与之呼应，同样存放在所属数据库的目录下</span><br><span class="line">3、<span class="selector-class">.MYI</span>文件</span><br><span class="line">也是<span class="selector-tag">myisam</span>存储引擎专用，存放<span class="selector-tag">myisam</span>表的索引相关信息。对于<span class="selector-tag">myisam</span>存储引擎来说，可以被缓存(<span class="selector-tag">cache</span>)的内容主要就是来源于<span class="selector-class">.MYI</span>文件中。</span><br><span class="line">每一个<span class="selector-tag">myisam</span>表对应一个<span class="selector-class">.MYI</span>文件，其存放的位置和<span class="selector-class">.frm</span>及<span class="selector-class">.MYD</span>一样</span><br><span class="line">4、<span class="selector-class">.ibd</span>文件和<span class="selector-tag">ibdata</span>文件</span><br><span class="line">存放<span class="selector-tag">innoDB</span>的数据文件（包括索引）。<span class="selector-tag">innoDB</span>存储引擎有两种表空间方式：独享表空间和共享表空间。</span><br><span class="line">独享表空间：使用<span class="selector-class">.ibd</span>文件来存放数据，且每个表一个<span class="selector-class">.ibd</span>文件，文件存放在和<span class="selector-tag">myisam</span>数据相同的位置。</span><br><span class="line">共享表空间：使用<span class="selector-class">.ibdata</span>文件，所有表共同使用一个（或多个，自行配置）<span class="selector-tag">ibdata</span>文件。</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">ibdata1</span>:系统表空间（数据文件）<span class="selector-tag">undo</span> 段</span><br><span class="line"><span class="selector-tag">ib_logfile0</span>   <span class="selector-tag">redlog</span>文件  一组</span><br><span class="line"><span class="selector-tag">ib_logfile1</span></span><br><span class="line"></span><br><span class="line">5、<span class="selector-tag">db</span><span class="selector-class">.opt</span>文件    此文件在每一个自建的库里都会有，记录这个库的默认使用的字符集和校验规。</span><br></pre></td></tr></table></figure><h3 id="pid文件"><a href="#pid文件" class="headerlink" title="pid文件"></a>pid文件</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pid文件是mysqld应用程序在Unix/Linux环境下的一个进程文件，和许多其他Unix/Linux服务端程序一样，它存放着自己的进程<span class="built_in">id</span></span><br></pre></td></tr></table></figure><h3 id="socket文件"><a href="#socket文件" class="headerlink" title="socket文件"></a>socket文件</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">socket</span>文件也是在Unix/Linux环境下才有的，用户在Unix/Linux环境下客户端连接可以不通过TCP/<span class="built_in">IP</span>网络而直接使用Unix Socket来连接mysql.</span><br></pre></td></tr></table></figure><h2 id="区分数据库、数据库实例、数据库服务器"><a href="#区分数据库、数据库实例、数据库服务器" class="headerlink" title="区分数据库、数据库实例、数据库服务器"></a>区分数据库、数据库实例、数据库服务器</h2><h3 id="数据库（database）"><a href="#数据库（database）" class="headerlink" title="数据库（database）"></a>数据库（database）</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数据库（<span class="selector-tag">database</span>）：</span><br><span class="line">操作系统或存储上的数据文件的集合。<span class="selector-tag">mysql</span>数据库中，数据库文件可以是* <span class="selector-class">.frm</span>、*<span class="selector-class">.MYD</span>、*<span class="selector-class">.MYI</span>、*<span class="selector-class">.ibd</span>等结尾的文件，</span><br><span class="line">不同存储引擎文件类型不同。</span><br></pre></td></tr></table></figure><h3 id="数据库实例（instance）"><a href="#数据库实例（instance）" class="headerlink" title="数据库实例（instance）"></a>数据库实例（instance）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">由后台进程或者线程以及一个共享内存区组成。共享内存可以被运行的后台线程所共享。</span><br><span class="line">需要注意：数据库实例才是真正操作数据库的。</span><br><span class="line">    </span><br><span class="line">数据库和数据库实例的关系：</span><br><span class="line">通常情况下，数据库实例和数据库是一一对应的关系，也就是一个数据库实例对应一个数据库；</span><br><span class="line">但是，在集群环境中存在多个数据库实例共同使用一个数据库。</span><br></pre></td></tr></table></figure><h3 id="数据库服务器-database-server"><a href="#数据库服务器-database-server" class="headerlink" title="数据库服务器(database server)"></a>数据库服务器(database server)</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数据库服务器(database server)：部署安装数据库实例的服务器。</span><br><span class="line">mysql中的逻辑对象:</span><br><span class="line">mysqld_process+memory+datafile|<span class="type">logfile</span>|<span class="type">pidfile</span>...---&gt;库－－＞表－－＞记录（由行与列组成）</span><br></pre></td></tr></table></figure><h2 id="MySQL数据库的帮助"><a href="#MySQL数据库的帮助" class="headerlink" title="MySQL数据库的帮助"></a><strong>MySQL数据库的帮助</strong></h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、官档</span><br><span class="line"><span class="number">2</span>、man 文档</span><br><span class="line"><span class="number">3</span>、命令行下的帮助文件      <span class="comment">--oracle命令行没有，需要去查官方文档</span></span><br><span class="line">mysql &gt; help;</span><br><span class="line">mysql &gt; help <span class="keyword">create</span> <span class="keyword">table</span>;</span><br><span class="line">mysql&gt; ? contents</span><br><span class="line">        <span class="comment">--分了很多类</span></span><br><span class="line">   Account Management</span><br><span class="line">   Administration</span><br><span class="line">   Data Definition</span><br><span class="line">   Data Manipulation</span><br><span class="line">   Data <span class="keyword">Types</span></span><br><span class="line">   <span class="keyword">Functions</span></span><br><span class="line">   <span class="keyword">Functions</span> <span class="keyword">and</span> Modifiers <span class="keyword">for</span> Use <span class="keyword">with</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">   Geographic Features</span><br><span class="line">   <span class="keyword">Language</span> Structure</span><br><span class="line">   <span class="keyword">Storage</span> Engines</span><br><span class="line">   Stored <span class="keyword">Routines</span></span><br><span class="line">   <span class="keyword">Table</span> Maintenance</span><br><span class="line">   Transactions</span><br><span class="line">   Triggers</span><br><span class="line"></span><br><span class="line">mysql&gt; ? Account Management    <span class="comment">--一级一级的向内部查</span></span><br><span class="line"></span><br><span class="line">mysql&gt; ? <span class="keyword">CREATE</span> <span class="keyword">USER</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;MySQL体系结构&quot;&gt;&lt;a href=&quot;#MySQL体系结构&quot; class=&quot;headerlink&quot; title=&quot;MySQL体系结构&quot;&gt;&lt;/a&gt;MySQL体系结构&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;../MySQL%E4%BD%93%E7%B3%BB%E7%BB
      
    
    </summary>
    
    
      <category term="MySQL" scheme="https://husky-wu.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://husky-wu.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL常见报错</title>
    <link href="https://husky-wu.github.io/2020/12/18/MySQL/MySQL%E5%B8%B8%E8%A7%81%E6%8A%A5%E9%94%99/"/>
    <id>https://husky-wu.github.io/2020/12/18/MySQL/MySQL%E5%B8%B8%E8%A7%81%E6%8A%A5%E9%94%99/</id>
    <published>2020-12-18T07:47:57.000Z</published>
    <updated>2020-12-28T02:28:39.988Z</updated>
    
    <content type="html"><![CDATA[<p>  附录MYSQL ERROR CODE含义表 （转载至网上（<a href="http://hchmsguo.iteye.com/blog/969761））：" target="_blank" rel="noopener">http://hchmsguo.iteye.com/blog/969761））：</a></p><p> 1005：创建表失败</p><p>1006：创建数据库失败</p><p>1007：数据库已存在，创建数据库失败</p><p>1008：数据库不存在，删除数据库失败</p><p>1009：不能删除数据库文件导致删除数据库失败</p><p>1010：不能删除数据目录导致删除数据库失败</p><p>1011：删除数据库文件失败</p><p>1012：不能读取系统表中的记录</p><p>1020：记录已被其他用户修改</p><p>1021：硬盘剩余空间不足，请加大硬盘可用空间</p><p>1022：关键字重复，更改记录失败</p><p>1023：关闭时发生错误</p><p>1024：读文件错误</p><p>1025：更改名字时发生错误</p><p>1026：写文件错误</p><p>1032：记录不存在</p><p>1036：数据表是只读的，不能对它进行修改</p><p>1037：系统内存不足，请重启数据库或重启服务器</p><p>1038：用于排序的内存不足，请增大排序缓冲区</p><p>1040：已到达数据库的最大连接数，请加大数据库可用连接数</p><p>1041：系统内存不足</p><p>1042：无效的主机名</p><p>1043：无效连接</p><p>1044：当前用户没有访问数据库的权限</p><p>1045：不能连接数据库，用户名或密码错误</p><p>1048：字段不能为空</p><p>1049：数据库不存在</p><p>1050：数据表已存在</p><p>1051：数据表不存在</p><p>1054：字段不存在</p><p>1065：无效的SQL语句，SQL语句为空</p><p>1081：不能建立Socket连接</p><p>1114：数据表已满，不能容纳任何记录</p><p>1116：打开的数据表太多</p><p>1129：数据库出现异常，请重启数据库</p><p>1130：连接数据库失败，没有连接数据库的权限</p><p>1133：数据库用户不存在</p><p>1141：当前用户无权访问数据库</p><p>1142：当前用户无权访问数据表</p><p>1143：当前用户无权访问数据表中的字段</p><p>1146：数据表不存在</p><p>1147：未定义用户对数据表的访问权限</p><p>1149：SQL语句语法错误</p><p>1158：网络错误，出现读错误，请检查网络连接状况</p><p>1159：网络错误，读超时，请检查网络连接状况</p><p>1160：网络错误，出现写错误，请检查网络连接状况</p><p>1161：网络错误，写超时，请检查网络连接状况</p><p>1062：字段值重复，入库失败</p><p>1169：字段值重复，更新记录失败</p><p>1177：打开数据表失败</p><p>1180：提交事务失败</p><p>1181：回滚事务失败</p><p>1203：当前用户和数据库建立的连接已到达数据库的最大连接数，请增大可用的数据库连接数或重启数据库</p><p>1205：加锁超时</p><p>1211：当前用户没有创建用户的权限</p><p>1216：外键约束检查失败，更新子表记录失败</p><p>1217：外键约束检查失败，删除或修改主表记录失败</p><p>1226：当前用户使用的资源已超过所允许的资源，请重启数据库或重启服务器</p><p>1227：权限不足，您无权进行此操作</p><p>1235：MySQL版本过低，不具有本功能</p><p>错误：1236 SQLSTATE: HY000 (ER_MASTER_FATAL_ERROR_READING_BINLOG) 消息：从二进制日志读取数据时，获得来自主服务器的致命错误%d: ’%s’。</p><p>错误：1237 SQLSTATE: HY000 (ER_SLAVE_IGNORED_TABLE) 消息：由于“replicate-*-table”规则，从SQL线程忽略了查询。。</p><p>错误：1238 SQLSTATE: HY000 (ER_INCORRECT_GLOBAL_LOCAL_VAR) 消息：变量’%s’是一种%s变量。</p><p>错误：1239 SQLSTATE: 42000 (ER_WRONG_FK_DEF) 消息：对于 ’%s’: %s， 外键定义不正确。 [Page]</p><p>错误：1240 SQLSTATE: HY000 (ER_KEY_REF_DO_NOT_MATCH_TABLE_REF) 消息：键引用和表引用不匹配。</p><p>错误：1241 SQLSTATE: 21000 (ER_OPERAND_COLUMNS) 消息：操作数应包含%d列。</p><p>错误：1242 SQLSTATE: 21000 (ER_SUBQUERY_NO_1_ROW) 消息：子查询返回1行以上。</p><p>错误：1243 SQLSTATE: HY000 (ER_UNKNOWN_STMT_HANDLER) 消息：指定给%s的未知预处理语句句柄。</p><p>错误：1244 SQLSTATE: HY000 (ER_CORRUPT_HELP_DB) 消息：帮助数据库崩溃或不存在。</p><p>错误：1245 SQLSTATE: HY000 (ER_CYCLIC_REFERENCE) 消息：对子查询的循环引用。</p><p>错误：1246 SQLSTATE: HY000 (ER_AUTO_CONVERT) 消息：将列’%s’从%s转换为%s。</p><p>错误：1247 SQLSTATE: 42S22 (ER_ILLEGAL_REFERENCE) 消息：引用’%s’不被支持 (%s)。</p><p>错误：1248 SQLSTATE: 42000 (ER_DERIVED_MUST_HAVE_ALIAS) 消息：所有的导出表必须有自己的别名。</p><p>错误：1249 SQLSTATE: 01000 (ER_SELECT_REDUCED) 消息：在优化期间简化了选择%u。</p><p>错误：1250 SQLSTATE: 42000 (ER_TABLENAME_NOT_ALLOWED_HERE) 消息：来自某一SELECT的表’%s’不能在%s中使用。</p><p>错误：1251 SQLSTATE: 08004 (ER_NOT_SUPPORTED_AUTH_MODE) 消息：客户端不支持服务器请求的鉴定协议，请考虑升级MySQL客户端。</p><p>错误：1252 SQLSTATE: 42000 (ER_SPATIAL_CANT_HAVE_NULL) 消息：SPATIAL索引的所有部分必须是NOT NULL。</p><p>错误：1253 SQLSTATE: 42000 (ER_COLLATION_CHARSET_MISMATCH) 消息：对于CHARACTER SET ’%s’，COLLATION ’%s’无效。</p><p>错误：1254 SQLSTATE: HY000 (ER_SLAVE_WAS_RUNNING) 消息：从服务器正在运行。</p><p>错误：1255 SQLSTATE: HY000 (ER_SLAVE_WAS_NOT_RUNNING) 消息：从服务器已停止。</p><p>错误：1256 SQLSTATE: HY000 (ER_TOO_BIG_FOR_UNCOMPRESS) 消息：解压的数据过大，最大大小为%d（也可能是，解压数据的长度已损坏）。</p><p>错误：1257 SQLSTATE: HY000 (ER_ZLIB_Z_MEM_ERROR) 消息：ZLIB，无足够内存。</p><p>错误：1258 SQLSTATE: HY000 (ER_ZLIB_Z_BUF_ERROR) 消息：ZLIB，输出缓冲区内无足够空间（也可能是，解压数据的长度已损坏）。</p><p>错误：1259 SQLSTATE: HY000 (ER_ZLIB_Z_DATA_ERROR) 消息：ZLIB，输入数据已损坏。</p><p>错误：1260 SQLSTATE: HY000 (ER_CUT_VALUE_GROUP_CONCAT) 消息：%d行被GROUP_CONCAT()截去。</p><p>错误：1261 SQLSTATE: 01000 (ER_WARN_TOO_FEW_RECORDS) 消息：行%ld不包含所有列的数据。</p><p>错误：1262 SQLSTATE: 01000 (ER_WARN_TOO_MANY_RECORDS) 消息：行%ld被解短，它包含的数据大于输入列中的数据。</p><p>错误：1263 SQLSTATE: 22004 (ER_WARN_NULL_TO_NOTNULL) 消息：列被设为默认值，在行%ld上将NULL提供给了NOT NULL列。</p><p>错误：1264 SQLSTATE: 22003 (ER_WARN_DATA_OUT_OF_RANGE) 消息：为行%ld上的列’%s’调整超出范围的值。</p><p>错误：1265 SQLSTATE: 01000 (WARN_DATA_TRUNCATED) 消息：为行%ld上的列’%s’截短数据。</p><p>错误：1266 SQLSTATE: HY000 (ER_WARN_USING_OTHER_HANDLER) 消息：为表%s使用存储引擎%s。 [Page]</p><p>错误：1267 SQLSTATE: HY000 (ER_CANT_AGGREGATE_2COLLATIONS) 消息：对于操作’%s’，非法混合了校对(%s,%s)和(%s,%s)。</p><p>错误：1268 SQLSTATE: HY000 (ER_DROP_USER) 消息：无法撤销1个或多个请求的用户。</p><p>错误：1269 SQLSTATE: HY000 (ER_REVOKE_GRANTS) 消息：无法撤销所有权限，为1个或多个请求的用户授权。</p><p>错误：1270 SQLSTATE: HY000 (ER_CANT_AGGREGATE_3COLLATIONS) 消息：对于操作’%s’，非法混合了校对(%s,%s)、(%s,%s)和(%s,%s)。</p><p>错误：1271 SQLSTATE: HY000 (ER_CANT_AGGREGATE_NCOLLATIONS) 消息：对于操作’%s’，非法混合了校对。</p><p>错误：1272 SQLSTATE: HY000 (ER_VARIABLE_IS_NOT_STRUCT) 消息：变量’%s’不是变量组分（不能用作XXXX.variable_name）。</p><p>错误：1273 SQLSTATE: HY000 (ER_UNKNOWN_COLLATION) 消息：未知校对’%s’。</p><p>错误：1274 SQLSTATE: HY000 (ER_SLAVE_IGNORED_SSL_PARAMS) 消息：由于该MySQL从服务器是在不支持SSL的情况下编译的，CHANGE MASTER中的SSL参数被忽略，随后，如果启动了具备SSL功能的MySQL，可使用这些参数。</p><p>错误：1275 SQLSTATE: HY000 (ER_SERVER_IS_IN_SECURE_AUTH_MODE) 消息：服务器正运行在“–secure-auth”模式下，但 ’%s’@’%s’ 有1个采用旧格式的密码，请将密码更改为新格式。</p><p>错误：1276 SQLSTATE: HY000 (ER_WARN_FIELD_RESOLVED) 消息：SELECT #%d的字段或引用’%s%s%s%s%s’是在SELECT #%d中确定的。</p><p>错误：1277 SQLSTATE: HY000 (ER_BAD_SLAVE_UNTIL_COND) 消息：对于START SLAVE UNTIL，不正确的参数或参数组合。</p><p>错误：1278 SQLSTATE: HY000 (ER_MISSING_SKIP_SLAVE) 消息：与START SLAVE UNTIL一起执行按步复制时，建议使用“–skip-slave-start”，否则，如果发生未预料的从服务器mysqld重启，间出现问题。</p><p>错误：1279 SQLSTATE: HY000 (ER_UNTIL_COND_IGNORED) 消息：SQL线程未启动，因而UNTIL选项被忽略。</p><p>错误：1280 SQLSTATE: 42000 (ER_WRONG_NAME_FOR_INDEX) 消息：不正确的索引名’%s’。</p><p>错误：1281 SQLSTATE: 42000 (ER_WRONG_NAME_FOR_CATALOG) 消息：不正确的目录名’%s’。</p><p>错误：1282 SQLSTATE: HY000 (ER_WARN_QC_RESIZE) 消息：查询高速缓冲设置大小%lu时失败，新的查询高速缓冲的大小是%lu。</p><p>错误：1283 SQLSTATE: HY000 (ER_BAD_FT_COLUMN) 消息：列’%s’不能是FULLTEXT索引的一部分。</p><p>错误：1284 SQLSTATE: HY000 (ER_UNKNOWN_KEY_CACHE) 消息：未知的键高速缓冲’%s’。</p><p>错误：1285 SQLSTATE: HY000 (ER_WARN_HOSTNAME_WONT_WORK) 消息：MySQL是在“–skip-name-resolve”模式下启动的，必须在不使用该开关的情况下重启它，以便该授权能起作用。</p><p>错误：1286 SQLSTATE: 42000 (ER_UNKNOWN_STORAGE_ENGINE) 消息：未知的表引擎’%s’。</p><p>错误：1287 SQLSTATE: HY000 (ER_WARN_DEPRECATED_SYNTAX) 消息：’%s’已过时，请使用’%s’取而代之。</p><p>错误：1288 SQLSTATE: HY000 (ER_NON_UPDATABLE_TABLE) 消息：%s的目标表%s不可更新。</p><p>错误：1289 SQLSTATE: HY000 (ER_FEATURE_DISABLED) 消息：’%s’特性已被禁止，要想使其工作，需要用’%s’创建MySQL。 [Page]</p><p>错误：1290 SQLSTATE: HY000 (ER_OPTION_PREVENTS_STATEMENT) 消息：MySQL正使用%s选项运行，因此不能执行该语句。</p><p>错误：1291 SQLSTATE: HY000 (ER_DUPLICATED_VALUE_IN_TYPE) 消息：列’%s’在%s中有重复值’%s’。</p><p>错误：1292 SQLSTATE: 22007 (ER_TRUNCATED_WRONG_VALUE) 消息：截短了不正确的%s值: ’%s’</p><p>错误：1293 SQLSTATE: HY000 (ER_TOO_MUCH_AUTO_TIMESTAMP_COLS) 消息：不正确的表定义，在DEFAULT或ON UPDATE子句中，对于CURRENT_TIMESTAMP，只能有一个TIMESTAMP列。</p><p>错误：1294 SQLSTATE: HY000 (ER_INVALID_ON_UPDATE) 消息：对于’%s’列，ON UPDATE子句无效</p><p>错误：1295 SQLSTATE: HY000 (ER_UNSUPPORTED_PS) 消息：在预处理语句协议中，尚不支持该命令。</p><p>错误：1296 SQLSTATE: HY000 (ER_GET_ERRMSG) 消息：从%s获得错误%d ’%s’。</p><p>错误：1297 SQLSTATE: HY000 (ER_GET_TEMPORARY_ERRMSG) 消息：从%s获得临时错误%d ’%s’。</p><p>错误：1298 SQLSTATE: HY000 (ER_UNKNOWN_TIME_ZONE) 消息：未知或不正确的时区: ’%s’</p><p>错误：1299 SQLSTATE: HY000 (ER_WARN_INVALID_TIMESTAMP) 消息：在行%ld的列’%s’中存在无效的TIMESTAMP值。</p><p>错误：1300 SQLSTATE: HY000 (ER_INVALID_CHARACTER_STRING) 消息：无效的%s字符串: ’%s’</p><p>错误：1301 SQLSTATE: HY000 (ER_WARN_ALLOWED_PACKET_OVERFLOWED) 消息：%s()的结果大于max_allowed_packet (%ld)，已截短</p><p>错误：1302 SQLSTATE: HY000 (ER_CONFLICTING_DECLARATIONS) 消息：冲突声明：’%s%s’和’%s%s’</p><p>错误：1303 SQLSTATE: 2F003 (ER_SP_NO_RECURSIVE_CREATE) 消息：不能从另一个存储子程序中创建%s。</p><p>错误：1304 SQLSTATE: 42000 (ER_SP_ALREADY_EXISTS) 消息：%s %s已存在。</p><p>错误：1305 SQLSTATE: 42000 (ER_SP_DOES_NOT_EXIST) 消息：%s %s不存在。</p><p>错误：1306 SQLSTATE: HY000 (ER_SP_DROP_FAILED) 消息：DROP %s %s失败</p><p>错误：1307 SQLSTATE: HY000 (ER_SP_STORE_FAILED) 消息：CREATE %s %s失败。</p><p>错误：1308 SQLSTATE: 42000 (ER_SP_LILABEL_MISMATCH) 消息：%s无匹配标签: %s</p><p>错误：1309 SQLSTATE: 42000 (ER_SP_LABEL_REDEFINE) 消息：重新定义标签%s</p><p>错误：1310 SQLSTATE: 42000 (ER_SP_LABEL_MISMATCH) 消息：末端标签%s无匹配项</p><p>错误：1311 SQLSTATE: 01000 (ER_SP_UNINIT_VAR) 消息：正在引用未初始化的变量%s。</p><p>错误：1312 SQLSTATE: 0A000 (ER_SP_BADSELECT) 消息：PROCEDURE %s不能在给定场景下返回结果集。</p><p>错误：1313 SQLSTATE: 42000 (ER_SP_BADRETURN) 消息：仅在FUNCTION中允许RETURN。</p><p>错误：1314 SQLSTATE: 0A000 (ER_SP_BADSTATEMENT) 消息：在存储程序中不允许%s。</p><p>错误：1315 SQLSTATE: 42000 (ER_UPDATE_LOG_DEPRECATED_IGNORED) 消息：更新日志已被放弃，并用二进制日志取代，SET SQL_LOG_UPDATE被忽略。</p><p>错误：1316 SQLSTATE: 42000 (ER_UPDATE_LOG_DEPRECATED_TRANSLATED) 消息：更新日志已被放弃，并用二进制日志取代，SET SQL_LOG_UPDATE已被截短为SET SQL_LOG_BIN。 [Page]</p><p>错误：1317 SQLSTATE: 70100 (ER_QUERY_INTERRUPTED) 消息：查询执行被中断。</p><p>错误：1318 SQLSTATE: 42000 (ER_SP_WRONG_NO_OF_ARGS) 消息：对于%s %s，参量数目不正确，预期为%u，但却是%u。</p><p>错误：1319 SQLSTATE: 42000 (ER_SP_COND_MISMATCH) 消息：未定义的CONDITION: %s</p><p>错误：1320 SQLSTATE: 42000 (ER_SP_NORETURN) 消息：在FUNCTION %s中未发现RETURN。</p><p>错误：1321 SQLSTATE: 2F005 (ER_SP_NORETURNEND) 消息：FUNCTION %s结束时缺少RETURN。</p><p>错误：1322 SQLSTATE: 42000 (ER_SP_BAD_CURSOR_QUERY) 消息：光标语句必须是SELECT。</p><p>错误：1323 SQLSTATE: 42000 (ER_SP_BAD_CURSOR_SELECT) 消息：光标SELECT不得有INTO。</p><p>错误：1324 SQLSTATE: 42000 (ER_SP_CURSOR_MISMATCH) 消息：未定义的CURSOR: %s</p><p>错误：1325 SQLSTATE: 24000 (ER_SP_CURSOR_ALREADY_OPEN) 消息：光标已打开</p><p>错误：1326 SQLSTATE: 24000 (ER_SP_CURSOR_NOT_OPEN) 消息：光标未打开</p><p>错误：1327 SQLSTATE: 42000 (ER_SP_UNDECLARED_VAR) 消息：未声明的变量：%s</p><p>错误：1328 SQLSTATE: HY000 (ER_SP_WRONG_NO_OF_FETCH_ARGS) 消息：不正确的FETCH变量数目。</p><p>错误：1329 SQLSTATE: 02000 (ER_SP_FETCH_NO_DATA) 消息：FETCH无数据。</p><p>错误：1330 SQLSTATE: 42000 (ER_SP_DUP_PARAM) 消息：重复参数: %s</p><p>错误：1331 SQLSTATE: 42000 (ER_SP_DUP_VAR) 消息：重复变量: %s 错误：1332 SQLSTATE: 42000 (ER_SP_DUP_COND) 消息：重复条件: %s</p><p>错误：1333 SQLSTATE: 42000 (ER_SP_DUP_CURS) 消息：重复光标: %s</p><p>错误：1334 SQLSTATE: HY000 (ER_SP_CANT_ALTER) 消息：ALTER %s %s失败。</p><p>错误：1335 SQLSTATE: 0A000 (ER_SP_SUBSELECT_NYI) 消息：不支持Subselect值。</p><p>错误：1336 SQLSTATE: 0A000 (ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG) 消息：在存储函数或触发程序中，不允许%s。</p><p>错误：1337 SQLSTATE: 42000 (ER_SP_VARCOND_AFTER_CURSHNDLR) 消息：光标或句柄声明后面的变量或条件声明。</p><p>错误：1338 SQLSTATE: 42000 (ER_SP_CURSOR_AFTER_HANDLER) 消息：句柄声明后面的光标声明。</p><p>错误：1339 SQLSTATE: 20000 (ER_SP_CASE_NOT_FOUND) 消息：对于CASE语句，未发现Case。</p><p>错误：1340 SQLSTATE: HY000 (ER_FPARSER_TOO_BIG_FILE) 消息：配置文件’%s’过大。</p><p>错误：1341 SQLSTATE: HY000 (ER_FPARSER_BAD_HEADER) 消息：文件’%s’中存在残缺的文件类型标题。</p><p>错误：1342 SQLSTATE: HY000 (ER_FPARSER_EOF_IN_COMMENT) 消息：解析’%s’时，文件意外结束。</p><p>错误：1343 SQLSTATE: HY000 (ER_FPARSER_ERROR_IN_PARAMETER) 消息：解析参数’%s’时出错（行：’%s’）。</p><p>错误：1344 SQLSTATE: HY000 (ER_FPARSER_EOF_IN_UNKNOWN_PARAMETER) 消息：跳过未知参数’%s’时，文件意外结束。</p><p>错误：1345 SQLSTATE: HY000 (ER_VIEW_NO_EXPLAIN) 消息：EXPLAIN/SHOW无法发出，缺少对基本表的权限。</p><p>错误：1346 SQLSTATE: HY000 (ER_FRM_UNKNOWN_TYPE) 消息：文件’%s’在其题头中有未知的类型’%s’。 [Page]</p><p>错误：1347 SQLSTATE: HY000 (ER_WRONG_OBJECT) 消息：’%s.%s’不是%s。</p><p>错误：1348 SQLSTATE: HY000 (ER_NONUPDATEABLE_COLUMN) 消息：列’%s’不可更新。</p><p>错误：1349 SQLSTATE: HY000 (ER_VIEW_SELECT_DERIVED) 消息：视图的SELECT在FROM子句中包含子查询。</p><p>错误：1350 SQLSTATE: HY000 (ER_VIEW_SELECT_CLAUSE) 消息：视图的SELECT包含’%s’子句。</p><p>错误：1351 SQLSTATE: HY000 (ER_VIEW_SELECT_VARIABLE) 消息：视图的SELECT包含1个变量或参数。</p><p>错误：1352 SQLSTATE: HY000 (ER_VIEW_SELECT_TMPTABLE) 消息：视图的SELECT引用了临时表’%s’。</p><p>错误：1353 SQLSTATE: HY000 (ER_VIEW_WRONG_LIST) 消息：视图的SELECT和视图的字段列表有不同的列计数。</p><p>错误：1354 SQLSTATE: HY000 (ER_WARN_VIEW_MERGE) 消息：此时，不能在这里使用视图合并算法（假定未定义算法）。</p><p>错误：1355 SQLSTATE: HY000 (ER_WARN_VIEW_WITHOUT_KEY) 消息：正在更新的视图没有其基本表的完整键。</p><p>错误：1356 SQLSTATE: HY000 (ER_VIEW_INVALID) 消息：视图’%s.%s’引用了无效的表、列、或函数，或视图的定义程序／调用程序缺少使用它们的权限。</p><p>错误：1357 SQLSTATE: HY000 (ER_SP_NO_DROP_SP) 消息：无法从另一个存储子程序中撤销或更改%s。</p><p>错误：1358 SQLSTATE: HY000 (ER_SP_GOTO_IN_HNDLR) 消息：在存储子程序句柄中不允许GOTO。</p><p>错误：1359 SQLSTATE: HY000 (ER_TRG_ALREADY_EXISTS) 消息：触发程序已存在。</p><p>错误：1360 SQLSTATE: HY000 (ER_TRG_DOES_NOT_EXIST) 消息：触发程序不存在。</p><p>错误：1361 SQLSTATE: HY000 (ER_TRG_ON_VIEW_OR_TEMP_TABLE) 消息：触发程序的’%s’是视图或临时表。</p><p>错误：1362 SQLSTATE: HY000 (ER_TRG_CANT_CHANGE_ROW) 消息：在%strigger中，不允许更新%s行。</p><p>错误：1363 SQLSTATE: HY000 (ER_TRG_NO_SUCH_ROW_IN_TRG) 消息：在%s触发程序中没有%s行。</p><p>错误：1364 SQLSTATE: HY000 (ER_NO_DEFAULT_FOR_FIELD) 消息：字段’%s’没有默认值。</p><p>错误：1365 SQLSTATE: 22012 (ER_DIVISION_BY_ZERO) 消息：被0除。</p><p>错误：1366 SQLSTATE: HY000 (ER_TRUNCATED_WRONG_VALUE_FOR_FIELD) 消息：不正确的%s值，’%s’，对于行%ld 上的列’%s’。</p><p>错误：1367 SQLSTATE: 22007 (ER_ILLEGAL_VALUE_FOR_TYPE) 消息：解析过程中发现非法%s ’%s’值。</p><p>错误：1368 SQLSTATE: HY000 (ER_VIEW_NONUPD_CHECK) 消息：不可更新视图’%s.%s’上的CHECK OPTION。</p><p>错误：1369 SQLSTATE: HY000 (ER_VIEW_CHECK_FAILED) 消息：CHECK OPTION失败，’%s.%s’</p><p>错误：1370 SQLSTATE: 42000 (ER_PROCACCESS_DENIED_ERROR) 消息：对于子程序’%s’，拒绝用户 ’%s’@’%s’ 使用%s命令。</p><p>错误：1371 SQLSTATE: HY000 (ER_RELAY_LOG_FAIL) 消息：清除旧中继日志失败，%s</p><p>错误：1372 SQLSTATE: HY000 (ER_PASSWD_LENGTH) 消息：密码混编应是%d位的十六进制数。</p><p>错误：1373 SQLSTATE: HY000 (ER_UNKNOWN_TARGET_BINLOG) 消息：在binlog索引中未发现目标日志。 [Page]</p><p>错误：1374 SQLSTATE: HY000 (ER_IO_ERR_LOG_INDEX_READ) 消息：读取日志索引文件时出现I/O错误。</p><p>错误：1375 SQLSTATE: HY000 (ER_BINLOG_PURGE_PROHIBITED) 消息：服务器配置不允许binlog清除。</p><p>错误：1376 SQLSTATE: HY000 (ER_FSEEK_FAIL) 消息：fseek()失败。</p><p>错误：1377 SQLSTATE: HY000 (ER_BINLOG_PURGE_FATAL_ERR) 消息：在日志清除过程中出现致命错误。</p><p>错误：1378 SQLSTATE: HY000 (ER_LOG_IN_USE) 消息：可清除的日志正在使用，不能清除。</p><p>错误：1379 SQLSTATE: HY000 (ER_LOG_PURGE_UNKNOWN_ERR) 消息：在日志清除过程中出现未知错误。</p><p>错误：1380 SQLSTATE: HY000 (ER_RELAY_LOG_INIT) 消息：初始化中继日志位置失败，%s</p><p>错误：1381 SQLSTATE: HY000 (ER_NO_BINARY_LOGGING) 消息：未使用二进制日志功能。</p><p>错误：1382 SQLSTATE: HY000 (ER_RESERVED_SYNTAX) 消息：’%s’语法保留给MySQL服务器内部使用。</p><p>错误：1383 SQLSTATE: HY000 (ER_WSAS_FAILED) 消息：WSAStartup失败。</p><p>错误：1384 SQLSTATE: HY000 (ER_DIFF_GROUPS_PROC) 消息：尚不能用不同的组处理过程。</p><p>错误：1385 SQLSTATE: HY000 (ER_NO_GROUP_FOR_PROC) 消息：对于该过程，SELECT必须有1个组。</p><p>错误：1386 SQLSTATE: HY000 (ER_ORDER_WITH_PROC) 消息：不能与该过程一起使用ORDER子句。</p><p>错误：1387 SQLSTATE: HY000 (ER_LOGGING_PROHIBIT_CHANGING_OF) 消息：二进制日志功能和复制功能禁止更改全局服务器%s。</p><p>错误：1388 SQLSTATE: HY000 (ER_NO_FILE_MAPPING) 消息：无法映射文件: %s, errno: %d</p><p>错误：1389 SQLSTATE: HY000 (ER_WRONG_MAGIC) 消息：%s中有错</p><p>错误：1390 SQLSTATE: HY000 (ER_PS_MANY_PARAM) 消息：预处理语句包含过多的占位符。</p><p>错误：1391 SQLSTATE: HY000 (ER_KEY_PART_0) 消息：键部分’%s’的长度不能为0。</p><p>错误：1392 SQLSTATE: HY000 (ER_VIEW_CHECKSUM) 消息：视图文本校验和失败。</p><p>错误：1393 SQLSTATE: HY000 (ER_VIEW_MULTIUPDATE) 消息：无法通过联合视图’%s.%s’更改1个以上的基本表。</p><p>错误：1394 SQLSTATE: HY000 (ER_VIEW_NO_INSERT_FIELD_LIST) 消息：不能在没有字段列表的情况下插入联合视图’%s.%s’。</p><p>错误：1395 SQLSTATE: HY000 (ER_VIEW_DELETE_MERGE_VIEW) 消息：不能从联合视图’%s.%s’中删除。</p><p>错误：1396 SQLSTATE: HY000 (ER_CANNOT_USER) 消息：对于%s的操作%s失败。</p><p>错误：1397 SQLSTATE: XAE04 (ER_XAER_NOTA) 消息：XAER_NOTA: 未知XID</p><p>错误：1398 SQLSTATE: XAE05 (ER_XAER_INVAL) 消息：XAER_INVAL: 无效参量（或不支持的命令）</p><p>错误：1399 SQLSTATE: XAE07 (ER_XAER_RMFAIL) 消息：XAER_RMFAIL: 当全局事务处于%s状态时，不能执行命令。</p><p>错误：1400 SQLSTATE: XAE09 (ER_XAER_OUTSIDE) 消息：XAER_OUTSIDE: 某些工作是在全局事务外完成的。</p><p>错误：1401 SQLSTATE: XAE03 (ER_XAER_RMERR) 消息：XAER_RMERR: 在事务分支中出现致命错误，请检查数据一致性。</p><p>错误：1402 SQLSTATE: XA100 (ER_XA_RBROLLBACK) 消息：XA_RBROLLBACK: 回滚了事务分支。 [Page]</p><p>错误：1403 SQLSTATE: 42000 (ER_NONEXISTING_PROC_GRANT) 消息：在子程序’%s’上没有为主机’%s’上的用户’%s’定义的这类授权。</p><p>错误：1404 SQLSTATE: HY000 (ER_PROC_AUTO_GRANT_FAIL) 消息：无法授予EXECUTE和ALTER ROUTINE权限。</p><p>错误：1405 SQLSTATE: HY000 (ER_PROC_AUTO_REVOKE_FAIL) 消息：无法撤销已放弃子程序上的所有权限。</p><p>错误：1406 SQLSTATE: 22001 (ER_DATA_TOO_LONG) 消息：对于行%ld上的列’%s’来说，数据过长。</p><p>错误：1407 SQLSTATE: 42000 (ER_SP_BAD_SQLSTATE) 消息：不良SQLSTATE: ’%s’</p><p>错误：1408 SQLSTATE: HY000 (ER_STARTUP) 消息：%s，连接就绪；版本，’%s’；套接字，’%s’；端口，%d %s</p><p>错误：1409 SQLSTATE: HY000 (ER_LOAD_FROM_FIXED_SIZE_ROWS_TO_VAR) 消息：不能从具有固定大小行的文件中将值加载到变量。</p><p>错误：1410 SQLSTATE: 42000 (ER_CANT_CREATE_USER_WITH_GRANT) 消息：不允许用GRANT创建用户。</p><p>错误：1411 SQLSTATE: HY000 (ER_WRONG_VALUE_FOR_TYPE) 消息：不正确的%s值，’%s’，对于函数%s</p><p>错误：1412 SQLSTATE: HY000 (ER_TABLE_DEF_CHANGED) 消息：表定义已更改，请再次尝试事务。</p><p>错误：1413 SQLSTATE: 42000 (ER_SP_DUP_HANDLER) 消息：在相同块中声明了重复句柄。</p><p>错误：1414 SQLSTATE: 42000 (ER_SP_NOT_VAR_ARG) 消息：子程序%s的OUT或INOUT参量不是变量。</p><p>错误：1415 SQLSTATE: 0A000 (ER_SP_NO_RETSET) 消息：不允许从%s返回结果集。</p><p>错误：1416 SQLSTATE: 22003 (ER_CANT_CREATE_GEOMETRY_OBJECT) 消息：不能从发送给GEOMETRY字段的数据中获取几何对象。</p><p>错误：1417 SQLSTATE: HY000 (ER_FAILED_ROUTINE_BREAK_BINLOG) 消息：1个子程序失败，在其声明没有NO SQL或READS SQL DATA，而且二进制日志功能已启用，如果更新了非事务性表，二进制日志将丢失其变化信息。</p><p>错误：1418 SQLSTATE: HY000 (ER_BINLOG_UNSAFE_ROUTINE) 消息：在该子程序的在其声明没有DETERMINISTIC、NO SQL或READS SQL DATA，而且二进制日志功能已启用（你或许打算使用不太安全的log_bin_trust_routine_creators变量）。</p><p>错误：1419 SQLSTATE: HY000 (ER_BINLOG_CREATE_ROUTINE_NEED_SUPER) 消息：你没有SUPER权限，而且二进制日志功能已启用（你或许打算使用不太安全的log_bin_trust_routine_creators变 量）。</p><p>错误：1420 SQLSTATE: HY000 (ER_EXEC_STMT_WITH_OPEN_CURSOR) 消息：不能执行该预处理语句，该预处理语句有与之相关的打开光标。请复位语句并再次执行。</p><p>错误：1421 SQLSTATE: HY000 (ER_STMT_HAS_NO_OPEN_CURSOR) 消息：语句(%lu)没有打开的光标。</p><p>错误：1422 SQLSTATE: HY000 (ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG) 消息：在存储函数或触发程序中，不允许显式或隐式提交。</p><p>错误：1423 SQLSTATE: HY000 (ER_NO_DEFAULT_FOR_VIEW_FIELD) 消息：视图’%s.%s’基本表的字段没有默认值。</p><p>错误：1424 SQLSTATE: HY000 (ER_SP_NO_RECURSION) 消息：不允许递归存储子程序。 [Page]</p><p>错误：1425 SQLSTATE: 42000 (ER_TOO_BIG_SCALE) 消息：为列’%s’指定了过大的标度%d。最大为%d。</p><p>错误：1426 SQLSTATE: 42000 (ER_TOO_BIG_PRECISION) 消息：为列’%s’指定了过高的精度%d。最大为%d。</p><p>错误：1427 SQLSTATE: 42000 (ER_M_BIGGER_THAN_D) 消息：对于float(M,D)、double(M,D)或decimal(M,D)，M必须&gt;= D (列’%s’)。</p><p>错误：1428 SQLSTATE: HY000 (ER_WRONG_LOCK_OF_SYSTEM_TABLE) 消息：不能将系统’%s.%s’表的写锁定与其他表结合起来。</p><p>错误：1429 SQLSTATE: HY000 (ER_CONNECT_TO_FOREIGN_DATA_SOURCE) 消息：无法连接到外部数据源，数据库’%s’！</p><p>错误：1430 SQLSTATE: HY000 (ER_QUERY_ON_FOREIGN_DATA_SOURCE) 消息：处理作用在外部数据源上的查询时出现问题。数据源错误：’%s’</p><p>错误：1431 SQLSTATE: HY000 (ER_FOREIGN_DATA_SOURCE_DOESNT_EXIST) 消息：你试图引用的外部数据源不存在。数据源错误：’%s’</p><p>错误：1432 SQLSTATE: HY000 (ER_FOREIGN_DATA_STRING_INVALID_CANT_CREATE) 消息：无法创建联合表。数据源连接字符串’%s’格式不正确。</p><p>错误：1433 SQLSTATE: HY000 (ER_FOREIGN_DATA_STRING_INVALID) 消息：数据源连接字符串’%s’格式不正确。</p><p>错误：1434 SQLSTATE: HY000 (ER_CANT_CREATE_FEDERATED_TABLE) 消息：无法创建联合表。外部数据源错误：’%s’</p><p>错误：1435 SQLSTATE: HY000 (ER_TRG_IN_WRONG_SCHEMA) 消息：触发程序位于错误的方案中。</p><p>错误：1436 SQLSTATE: HY000 (ER_STACK_OVERRUN_NEED_MORE) 消息：线程堆栈溢出，%ld字节堆栈用了%ld字节，并需要%ld字节。请使用’mysqld -O thread_stack=#’指定更大的堆栈。</p><p>错误：1437 SQLSTATE: 42000 (ER_TOO_LONG_BODY) 消息：’%s’的子程序主体过长。</p><p>错误：1438 SQLSTATE: HY000 (ER_WARN_CANT_DROP_DEFAULT_KEYCACHE) 消息：无法撤销默认的keycache。</p><p>错误：1439 SQLSTATE: 42000 (ER_TOO_BIG_DISPLAYWIDTH) 消息：对于列’%s’，显示宽度超出范围(max = %d)</p><p>错误：1440 SQLSTATE: XAE08 (ER_XAER_DUPID) 消息：XAER_DUPID: XID已存在</p><p>错误：1441 SQLSTATE: 22008 (ER_DATETIME_FUNCTION_OVERFLOW) 消息：日期时间函数，%s字段溢出。</p><p>错误：1442 SQLSTATE: HY000 (ER_CANT_UPDATE_USED_TABLE_IN_SF_OR_TRG) 消息：由于它已被调用了该存储函数／触发程序的语句使用，不能在存储函数／触发程序中更新表’%s’。</p><p>错误：1443 SQLSTATE: HY000 (ER_VIEW_PREVENT_UPDATE) 消息：表’%s’的定义不允许在表’%s上执行操作%s。</p><p>错误：1444 SQLSTATE: HY000 (ER_PS_NO_RECURSION) 消息：预处理语句包含引用了相同语句的存储子程序调用。不允许以这类递归方式执行预处理语句。</p><p>错误：1445 SQLSTATE: HY000 (ER_SP_CANT_SET_AUTOCOMMIT) 消息：不允许从存储函数或触发程序设置autocommit。</p><p>错误：1446 SQLSTATE: HY000 (ER_NO_VIEW_USER) 消息：视图定义人不完全合格。</p><p>错误：1447 SQLSTATE: HY000 (ER_VIEW_FRM_NO_USER) 消息：视图%s.%s没有定义人信息（旧的表格式）。当前用户将被当作定义人。请重新创建视图！ [Page]</p><p>错误：1448 SQLSTATE: HY000 (ER_VIEW_OTHER_USER) 消息：需要SUPER权限才能创建具有 %s@%s 定义器的视图。</p><p>错误：1449 SQLSTATE: HY000 (ER_NO_SUCH_USER) 消息：没有注册的 %s@%s 。</p><p>错误：1450 SQLSTATE: HY000 (ER_FORBID_SCHEMA_CHANGE) 消息：不允许将方案从’%s’变为’%s’。</p><p>错误：1451 SQLSTATE: 23000 (ER_ROW_IS_REFERENCED_2) 消息：不能删除或更新父行，外键约束失败(%s)。</p><p>错误：1452 SQLSTATE: 23000 (ER_NO_REFERENCED_ROW_2) 消息：不能添加或更新子行，外键约束失败(%s)。</p><p>错误：1453 SQLSTATE: 42000 (ER_SP_BAD_VAR_SHADOW) 消息：必须用<code>...</code>引用变量，或重新命名变量。</p><p>错误：1454 SQLSTATE: HY000 (ER_PARTITION_REQUIRES_VALUES_ERROR) 消息：对于每个分区，%s PARTITIONING需要VALUES %s的定义。</p><p>错误：1455 SQLSTATE: HY000 (ER_PARTITION_WRONG_VALUES_ERROR) 消息：在分区定义中，只有%s PARTITIONING能使用VALUES %s。</p><p>错误：1456 SQLSTATE: HY000 (ER_PARTITION_MAXVALUE_ERROR) 消息：MAXVALUE只能在最后1个分区定义中使用。</p><p>错误：1457 SQLSTATE: HY000 (ER_PARTITION_SUBPARTITION_ERROR) 消息：子分区只能是哈希分区，并按键分区。</p><p>错误：1458 SQLSTATE: HY000 (ER_PARTITION_WRONG_NO_PART_ERROR) 消息：定义了错误的分区数，与前面的设置不匹配。</p><p>错误：1459 SQLSTATE: HY000 (ER_PARTITION_WRONG_NO_SUBPART_ERROR) 消息：定义了错误的子分区数，与前面的设置不匹配。</p><p>错误：1460 SQLSTATE: HY000 (ER_CONST_EXPR_IN_PARTITION_FUNC_ERROR) 消息：在分区（子分区）函数中不允许使用常量／随机表达式。</p><p>错误：1461 SQLSTATE: HY000 (ER_NO_CONST_EXPR_IN_RANGE_OR_LIST_ERROR) 消息：RANGE/LIST VALUES中的表达式必须是常量。</p><p>错误：1462 SQLSTATE: HY000 (ER_FIELD_NOT_FOUND_PART_ERROR) 消息：在表中未发现分区函数字段列表中的字段。</p><p>错误：1463 SQLSTATE: HY000 (ER_LIST_OF_FIELDS_ONLY_IN_HASH_ERROR) 消息：仅在KEY分区中允许使用字段列表。</p><p>错误：1464 SQLSTATE: HY000 (ER_INCONSISTENT_PARTITION_INFO_ERROR) 消息：frm文件中的分区信息与能够写入到frm文件中的不一致。</p><p>错误：1465 SQLSTATE: HY000 (ER_PARTITION_FUNC_NOT_ALLOWED_ERROR) 消息：%s函数返回了错误类型。</p><p>错误：1466 SQLSTATE: HY000 (ER_PARTITIONS_MUST_BE_DEFINED_ERROR) 消息：对于%s分区，必须定义每个分区。</p><p>错误：1467 SQLSTATE: HY000 (ER_RANGE_NOT_INCREASING_ERROR) 消息：对于各分区，VALUES LESS THAN值必须严格增大。</p><p>错误：1468 SQLSTATE: HY000 (ER_INCONSISTENT_TYPE_OF_FUNCTIONS_ERROR) 消息：VALUES值必须与分区函数具有相同的类型。</p><p>错误：1469 SQLSTATE: HY000 (ER_MULTIPLE_DEF_CONST_IN_LIST_PART_ERROR) 消息：Multiple definition of same constant in list partitioning</p><p>错误：1470 SQLSTATE: HY000 (ER_PARTITION_ENTRY_ERROR) 消息：在查询中，不能独立使用分区功能。</p><p>错误：1471 SQLSTATE: HY000 (ER_MIX_HANDLER_ERROR) 消息：在该MySQL版本中，不允许分区中的句柄组合。 [Page]</p><p>错误：1472 SQLSTATE: HY000 (ER_PARTITION_NOT_DEFINED_ERROR) 消息：对于分区引擎，有必要定义所有的%s。</p><p>错误：1473 SQLSTATE: HY000 (ER_TOO_MANY_PARTITIONS_ERROR) 消息：定义了过多分区。</p><p>错误：1474 SQLSTATE: HY000 (ER_SUBPARTITION_ERROR) 消息：对于子分区，仅能将RANGE/LIST分区与HASH/KEY分区混合起来。</p><p>错误：1475 SQLSTATE: HY000 (ER_CANT_CREATE_HANDLER_FILE) 消息：无法创建特定的句柄文件。</p><p>错误：1476 SQLSTATE: HY000 (ER_BLOB_FIELD_IN_PART_FUNC_ERROR) 消息：在分区函数中，不允许使用BLOB字段。</p><p>错误：1477 SQLSTATE: HY000 (ER_CHAR_SET_IN_PART_FIELD_ERROR) 消息：如果为分区函数选择了二进制校对，才允许使用VARCHAR。</p><p>错误：1478 SQLSTATE: HY000 (ER_UNIQUE_KEY_NEED_ALL_FIELDS_IN_PF) 消息：在分区函数中，%s需要包含所有文件。</p><p>错误：1479 SQLSTATE: HY000 (ER_NO_PARTS_ERROR) 消息：%s的数目= 0不是允许的值。</p><p>错误：1480 SQLSTATE: HY000 (ER_PARTITION_MGMT_ON_NONPARTITIONED) 消息：无法在非分区表上进行分区管理。</p><p>错误：1481 SQLSTATE: HY000 (ER_DROP_PARTITION_NON_EXISTENT) 消息：分区列表中的错误出现变化。</p><p>错误：1482 SQLSTATE: HY000 (ER_DROP_LAST_PARTITION) 消息：不能删除所有分区，请使用DROP TABLE取而代之。</p><p>错误：1483 SQLSTATE: HY000 (ER_COALESCE_ONLY_ON_HASH_PARTITION) 消息：COALESCE PARTITION仅能在HASH/KEY分区上使用。</p><p>错误：1484 SQLSTATE: HY000 (ER_ONLY_ON_RANGE_LIST_PARTITION) 消息：%s PARTITION仅能在RANGE/LIST分区上使用。</p><p>错误：1485 SQLSTATE: HY000 (ER_ADD_PARTITION_SUBPART_ERROR) 消息：试图用错误的子分区数增加分区。</p><p>错误：1486 SQLSTATE: HY000 (ER_ADD_PARTITION_NO_NEW_PARTITION) 消息：必须至少添加1个分区。</p><p>错误：1487 SQLSTATE: HY000 (ER_COALESCE_PARTITION_NO_PARTITION) 消息：必须至少合并1个分区。</p><p>错误：1488 SQLSTATE: HY000 (ER_REORG_PARTITION_NOT_EXIST) 消息：重组的分区数超过了已有的分区数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  附录MYSQL ERROR CODE含义表 （转载至网上（&lt;a href=&quot;http://hchmsguo.iteye.com/blog/969761））：&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://hchmsguo.iteye.co
      
    
    </summary>
    
    
      <category term="MySQL" scheme="https://husky-wu.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://husky-wu.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>innodb存储引擎详解</title>
    <link href="https://husky-wu.github.io/2020/12/18/MySQL/innodb%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E8%AF%A6%E8%A7%A3/"/>
    <id>https://husky-wu.github.io/2020/12/18/MySQL/innodb%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-12-18T07:47:57.000Z</published>
    <updated>2020-12-28T02:28:51.596Z</updated>
    
    <content type="html"><![CDATA[<h3 id="innodb特性："><a href="#innodb特性：" class="headerlink" title="innodb特性："></a>innodb特性：</h3><p><strong>主体系结构</strong>：默认7个后台线程，4个io thread(insert buffer、log、read、write),1个master thread(优先级最高),1个锁(lock)监控线程，1个错误监控线程。可以通过show engine innodb status来查看。新版本已对默认的read thread和write thread分别增大到4个，可通过show variables like ‘innodb_io_thread%’查看。</p><p><strong>存储引擎组成</strong>：缓冲池(buffer pool)、重做日志缓冲池(redo log buffer)以及额外的内存池(additional memory pool).具体配置可由show variables like ‘innodb_buffer_pool_size’、show variables like</p><p>‘innodb_log_buffer_size’、show variables like ‘innodb_additional_mem_pool_size’来查看。</p><p><strong>缓冲池</strong>：占最大块内存，用来存放各种数据的缓存包括有索引页、数据页、undo页、插入缓冲、自适应哈希索引、innodb存储的锁信息、数据字典信息等。工作方式总是将数据库文件按页(每页16k)读取到缓冲池，然后按最近最少使用(lru)的算法来保留在缓冲池中的缓存数据。如果数据库文件需要修改，总是首先修改在缓存池中的页(发生修改后即为脏页)，然后再按照一定的频率将缓冲池的脏页刷新到文件。通过命令show engine innodb status;来查看。</p><p><strong>日志缓冲</strong>：将重做日志信息先放入这个缓冲区，然后按一定频率将其刷新到重做日志文件。</p><p><img src="../innodb%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E8%AF%A6%E8%A7%A3/innodb%E7%BC%93%E5%86%B2%E6%B1%A0.jpg" alt="img" title="null"></p><p><strong>master thread:</strong></p><p>loop主循环每秒一次的操作：</p><p>日志缓冲刷新到磁盘，即使这个事务还没有提交。(总是执行，所以再大的事务commit</p><p>的时间也是很快的)</p><p>合并插入缓冲(innodb当前一秒发生的io次数小于5次则执行)</p><p>至多刷新100个innodb的缓冲池中的脏页到磁盘(超过配置的脏页所占缓冲池比例则执</p><p>行，在配置文件中由innodb_max_dirty_pages_pac决定，默认是90，新版本是75，</p><p>google建议是80)</p><p>如果当前没用用户活动，切换到backgroud loop</p><p>loop主循环每10秒一次的操作：</p><p>刷新100个脏页到磁盘(过去10秒IO操作小于200次则执行)</p><p>合并至多5个插入缓冲(总是)</p><p>将日志缓冲到磁盘(总是)</p><p>删除无用的Undo页(总是)</p><p>刷新100个或者10个脏页到磁盘(有超过70%的脏页，刷新100个脏页;否则刷新10个脏页)</p><p>产生一个检查点</p><p>backgroud loop，若当前没有用户活动(数据库空闲时)或者数据库关闭时，就会切换到这个循环：</p><p>删除无用的Undo页(总是)</p><p>合并20个插入缓冲(总是)</p><p>跳回到主循环(总是)</p><p>不断刷新100个页，直到符合条件(可能在flush loop中完成)</p><p>如果flush loop中也没有什么事情可以做了，InnoDB存储引擎会切换到suspend_loop，将master thread挂起，等待事件的发生。若启用了InnoDB存储引擎，却没有使用任何InnoDB存储引擎的表，那么master thread总是处于挂起状态</p><p>插入缓冲：不是缓冲池的一部分，Insert Buffer是物理页的一个组成部分,它带来InnoDB性能的提高。根据B+算法(下文会提到)的特点，插入数据的时候会主键索引是顺序的，不会造成数据库的随机读取，而对于非聚集索引(即辅助索引)，叶子节点的插入不再是顺序的了，这时需要离散地访问非聚集索引，插入性能在这里变低了。InnoDB引入插入缓冲，判断非聚集索引页是否在缓冲池中，如果在则直接插入;不在，则先放在 插入缓冲区中。然后根据上述master thread中介绍的，会有一定的频率将插入缓冲合并。此外，辅助索引不能是唯一的，因为插入到插入缓冲时，并不去查找索引页的情况，否则仍然会造成随机读，失去插入缓冲的意义了。插入缓冲可能会占缓冲池中内存，默认也能会占到1/2，所以可以将这个值调小点，到1/3。通过IBUF_POOL_SIZE_PER_MAX_SIZE来设置，2表示1/2,3表示1/3。</p><p>两次写： 它带来InnoDB数据的可靠性。如果写失效，可以通过重做日志进行恢复，但是重做日志中记录的是对页的物理操作，如果页本身损坏，再对其进行重做是没有意义的。所以，在应用重做日志前，需要一个页的副本，当写入失效发生时，先通过页的副本来还原该页，再进行重做，这就是doublewire。</p><p>恢复数据=页副本+重做日志</p><p><img src="../innodb%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E8%AF%A6%E8%A7%A3/%E4%B8%A4%E6%AC%A1%E5%86%99.jpg" alt="img" title="null"></p><p>自适应哈希索引：InnoDB存储引擎提出一种自适应哈希索引，存储引擎会监控对表上索引的查找，如果观察到建立建立哈希索引会带来速度的提升，则建立哈希索引，所以称之为自适应的。自适应哈希索引只能用来搜索等值的查询，如select * from table where index_col=’***’, 此外自适应哈希是由InnoDB存储引擎控制的，我们只能通过innodb_adaptive_hash_index来禁用或启用，默认开启。</p><h3 id="mysql-文件"><a href="#mysql-文件" class="headerlink" title="mysql 文件"></a>mysql 文件</h3><p>参数文件：告诉Mysql实例启动时在哪里可以找到数据库文件，并且指定某些初始化参数，这些参数定义了某种内存结构的大小等设置。用文件存储，可编辑，若启动时加载不到则不能成功启动（与其他数据库不同）。参数有动态和静态之分，静态相当于只读，动态是可以set的。如我们通过show variable like ‘***’查出来的key、value值，是可以通过set key=value直接修改的。同是，修改时还有作用域之分，即这个seesion个有效和全局有效，在对应的key前加上session或global即可，如select @@seesion.read_buffer_size、set @@global.read_buffer_size。</p><p>日志文件：用来记录Mysql实例对某种条件做出响应时写入的文件。如错误日志文件、二进制日志文件、慢查询日志文件、查询日志文件等。</p><p>错误日志：通过show variables like ‘log_error’来查看错误日志存放地址</p><p>慢查询日志：通过show variables like ‘%long%’ 查看慢查询日志记录的阈值，新版本设成了0.05；通过show variables like ‘log_slow_queries’查看是否开启了，默认为关闭的；通过show variabes like ‘log_queries_not_using_indexes’查看是将没有使用索引的查询记录到慢日志中。mysql中可以直接通过mysqldumpslow命令来查看慢日志。</p><p>二进制文件：不记录查询，只记录对数据库所有的修改操作。目的是为了恢复(point-in-time修复)和复制。通过show variables like ‘datadir’查看存放路径。二进制日志支持STATEMENT、ROW、MIX三种格式，通过binlog_format参数设定，通常设置为ROW，可以为数据库的恢复和复制带来更好的可靠性，但会带来二进制文件大小的增加，复制时会增加网络开销。mysql中通过mysqlbinlog查看二进制日志文件内容。</p><p>socket文件：当用Unix域套接字方式进行连接时需要的文件。</p><p>pid文件：Mysql实例的进程ID文件。</p><p>Mysql表结构文件：用来存放Mysql表结构定义文件。因为Mysql插件式存储引擎的体系结构，每个表都有一个对应的文件，以frm后缀结尾。</p><p>存储引擎文件：存储自己的文件来保存各种数据，真正存储了数据和索引等数据。下面主要介绍InnoDB的存储引擎下的表空间文件和重做日志文件。</p><p>表空间文件：InnoDB默认的表空间文件为ibdata1,可通过show variables like ‘innodb_file_per_table’查看每个表是否产生单独的.idb表空间文件。但是，单独的表空间文件仅存储该表的数据、索引和插入缓冲等信息，其余信息还是存放在默认的表空间中。</p><p>重做日志文件：实例和介质失败，重做日志文件就能派上用场，如数据库掉电，InnoDB存储引擎会使用重做日志恢复到掉电前的时刻，以此来保证数据的完整性。参数innodb_log_file_size指定了重做日志文件的大小；innodb_log_file_in_group指定了日志文件组中重做日志文件的数量，默认为2，innodb_mirrored_log_groups指定了日志镜像文件组的数量，默认为1，代表只有一个日志文件组，没有镜像；innodb_log_group_home_dir指定了日志文件组所在路径，默认在数据库路径下。</p><p>二进制日志和重做日志的区别：首先，二进制日志会记录所有与Mysql有关的日志记录，包括InnoDB、MyISAM、Heap等其他存储引擎的日志。而InnoDB存储引擎重做日志只存储有关其本身的事务日志；其次内容不同，不管将二进制日志文件记录的格式设为STATEMENT还是ROW，又或者是MIXED，其记录的都是关于一个事务的具体操作内容。而InnoDB存储引擎的重做日志文件记录的关于每个页的更改的物理情况 。此外，写入时间不同，二进制日志文件是在事务提交前进行记录的，而在事务进行的过程中，不断有重做日志条目被 写入重做日志文件中。</p><h3 id="mysql-innodb表"><a href="#mysql-innodb表" class="headerlink" title="mysql innodb表"></a>mysql innodb表</h3><p>表空间：表空间可看做是InnoDB存储引擎逻辑结构的最高层。</p><p>段：表空间由各个段组成，常见的段有数据段、索引段、回滚段等。</p><p>区：由64个连续的页组成，每个页大小为16kb，即每个区大小为1MB。</p><p>页：每页16kb，且不能更改。常见的页类型有：数据页、Undo页、系统页、事务数据页、插入缓冲位图页、插入缓冲空闲列表页、未压缩的二进制大对象页、压缩的二进制大对象页。</p><p>行：InnoDB存储引擎是面向行的(row-oriented)，每页最多允许存放7992行数据。</p><p>行记录格式：常见两种行记录格式Compact和Redundant，mysql5.1版本后，主要是Compact行记录格式。对于Compact，不管是char型还是varchar型，null型都是不占用存储空间的；对于Redudant,varchar的null不占用空间，char的null型是占用存储空间的。</p><p>varchar类型的长度限制是65535，其实达不到，会有别的开销，一般是65530左右，这还跟选取的字符集有关。此外这个长度限制是一整行的，例如：create table test(a varchar(22000), b varchar(22000), cvarchar(22000)) charset=latin1 engine=innodb也会报错。</p><p>对于blob类型的数据，在数据页面中只保存了varchar(65535)的前768个字节前缀数据，之后跟的是偏移量，指向行溢出页，也就是Uncompressed BLOB Page。新的InnoDB Plugin引入了新的文件格式称为Barracuda，其有两种新的行记录格式Compressed和Dynamic，两者对于存入Blog字段采用了完全溢出的方式，在数据库页中存放20个字节的指针，实际的数据都存入在BLOB Page中。</p><p><img src="../innodb%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E8%AF%A6%E8%A7%A3/blob%E9%A1%B5%E4%B8%8E%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%85%B3%E7%B3%BB.jpg" alt="img" title="null"></p><p><img src="../innodb%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E8%AF%A6%E8%A7%A3/offpage.jpg" alt="img" title="null"></p><p>数据页结构：数据页结构由以下7个部分组成：</p><p>File Header(文件头):记录页的一些头信息，如页偏移量、上一页、下一页、页类型等，固定长度为38个字节。</p><p>Page Header(页头)：记录页的状态信息，堆中记录数、指向空闲列表的指针、已删除记录的字节数、最后插入的位置等，固定长度共56个字节。</p><p>Infimun+Supremum Records:在InnoDB存储引擎中，每个数据页中有两个虚拟的行记录，用来限定记录的边界。</p><p>Infimun记录是比该页中任何主键都要小的值，Supermum指比任何可能大的值还要大的值。这两个值在页创建时被建立，并且在任何情况下不会被删除。在Compact行格式和Redundant行格式下，两者占用的字节数各不相同。</p><p><img src="../innodb%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E8%AF%A6%E8%A7%A3/b+%E6%A0%91.jpg" alt="img" title="null"></p><p>User Records(用户记录，即行记录):实现记录的内容。再次强调，InnoDB存储引擎表总是B+村索引组织的。</p><p>Free Space(空闲空间)：指空闲空间，同样也是个链表数据结构。当一条记录被删除后，该空间会被加入空闲链 表中。</p><p>Page Directory(页目录)：页目录存放了记录的相对位置，并不是偏移量，有些时候这些记录称为Slots(槽)，InnoDB并不是每个记录一个槽，槽是一个稀疏目录，即一个槽中可能属于多个记录，最少属于4条记录，最多属于8条记录。需要牢记的是，B+树索引本身并不能找到具体的一条记录，B+树索引能找到只是该记录所在的页。数据库把页载入内存，然后通过Page Directory再进行二叉查找。只不过二叉查找的时间复杂度低，同时内存中的查找很快，因此通过忽略了这部分查找所用的时间。</p><p>File Trailer(文件结尾信息)：为了保证页完整地写入磁盘(如写过程的磁盘损坏、机器宕机等)，固定长8个字节。</p><p>视图：Mysql中的视图总是虚拟的表，本身不支持物化视图。但是通过一些其他技巧(如触发器)，同样也可以实现一些简单的物化视图的功能。</p><p>分区：Mysql数据库支持RANGE、LIST、HASH、KEY、COLUMNS分区，并且可以使用HASH或KEY来进行子分区。</p><h3 id="mysql-innodb常见索引与算法："><a href="#mysql-innodb常见索引与算法：" class="headerlink" title="mysql innodb常见索引与算法："></a>mysql innodb常见索引与算法：</h3><p>B+树索引：B+树的数据结构相对较复杂，B代表的是balance最早是从平衡二叉树演化而来，但B+树并不是一个二叉树， 由于B+树索引的高扇出性，因此在数据库中，B+树的高度一般都在2<del>3层，也就对于查找某一键值的行记录，最多只要2到3次IO,现在一般的磁盘每秒至少可以做100次IO，2</del>3次的IO意味着查询时间只需0.02~0.03秒。</p><p>数据库中的B+索引可以分为聚集索引(clustered index)和辅助聚集索引(secondary index),但其内部都是B+树的，即高度平衡的，叶子节点存放数据。</p><p>聚集索引：由于聚集索引是按照主键组织的，所以每一张表只能有一个聚集索引，每个数据页都通过双向链表进行连接，叶子节点存放一整行的信息，所以查询优化器更倾向走聚集索引。此外，对于聚集索引的存储是逻辑上连续的。所以，聚集索引对于主键的排序查找和范围查找速度非常快。</p><p>辅助索引：也叫非聚集索引，叶子节点不存全部数据，主要存键值及一个boomark(其实就是聚集索引的键)告诉InnoDB哪里可以找到与索引相对应的行数据，如一个高度为3的辅助索引和一个高度为3的聚集索引，若根据辅助索引来查询行记录，一共需要6次IO。另外辅助索引可以有多个。</p><p>索引的使用原则：高选择、取出表中的少部分数据(也称为唯一索引)。一般取出的数据量超过表中数据的20%，优化器不会使用索引，而进行全表扫描。如对于性别等字段是没有意义的。</p><p>联合索引： 也称复合索引，是在多列（&gt;=2）上建立的索引。Innodb中的复合索引也是b+ tree结构。索引的数据包含多列(col1, col2, col3…)，在索引中依次按照col1, col2, col3排序。如(1, 2), (1, 3),(2,0)…使用复合索引要充分利用最左前缀原则，顾名思义，就是最左优先。如创建索引ind_col1_col2(col1, col2)，那么在查询where col1 = xxx and col2 = xx或者where col1 = xxx都可以走ind_col1_col2索引，但where col2=****是走不到索引的。在创建多列索引时，要根据业务需求，where子句中使用最频繁且过滤效果好的的一列放在最左边。</p><p>哈希索引：哈希算法也是比较常见的算法，mysql innoDB中使用了比较常见的链地址法进行去重。此外上面已经提及，innoDB中的hash是自适应的，什么时候使用hash是系统决定的，无法进行人工设置。</p><p>二分查找法：这个算法比较常见，这里就不多提及了。在InnoDB中，每页Page Directory中的槽是按照主键的顺序存放的，对于某一条具体记录的查询是通过对Page Directory进行二分查找得到的。</p><h3 id="mysql-innodb中的锁"><a href="#mysql-innodb中的锁" class="headerlink" title="mysql innodb中的锁"></a>mysql innodb中的锁</h3><p>InnoDB存储引擎锁的实现和Oracle非常类似，提供一致性的非锁定读、行级锁支持、行级锁没有相关的开销，可以同时得到并发性和一致性。</p><p>InnoDB存储引擎实现了如下两种标准的行级锁：</p><p>共享锁(S Lock)：允许事务读一行数据；</p><p>排他锁(X Lock)：允许事务删除或者更新一行数据。</p><p>当一个事务已经获得了行r的共享锁，那么另外的事务可以立即获得行r的共享锁，因为读取没有改变行r的数据，我们称这种情况为锁兼容。但如果有事务想获得行r的排他锁，则它必须等待事务释放行r上的共享锁————这种情况称为锁不兼容。</p><p><img src="../innodb%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E8%AF%A6%E8%A7%A3/innodb%E9%94%81.jpg" alt="img" title="null"></p><p>在InnoDB Plugin之前，只能通过SHOW FULL PROCESSLIST，SHOW ENGINE INOODB STATUS等命令来查看当前的数据库请求，然后再判断当前事务中的锁的情况。新版本的InnoDB Plugin中，在INFORMATION_SCHEMA架构下添加了INNODB_TRX、INNODB_LOCKS、InnoDB_LOCK_WAITS。通过这三张表，可以更简单地监控当前的事务并分析可能存在的锁的问题。</p><p>INNODB_TRX由8个字段组成：</p><p>trx_id:InnoDB存储引擎内部唯一的事务ID</p><p>trx_state:当前事务的状态。</p><p>trx_started:事务的开始时间。</p><p>trx_requested_lock_id:等待事务的锁ID。如trx_state的状态为LOCK WAIT,那么该值代表当前的等待之前事务占用锁资源的ID.</p><p>若trx_state不是LOCK WAIT,则该值为NULL。</p><p>trx_wait_started:事务等待开始的时间。</p><p>trx_weight:事务的权重，反映了一个事务修改和锁住的行数。在InnoDB存储引擎中，当发生死锁需要回滚时，InnoDB存储会选</p><p>择该值最小的进行回滚。</p><p>trx_mysql_thread_id:Mysql中的线程ID,SHOW PROCESSLIST显示的结果。</p><p>trx_query:事务运行的sql语句。</p><p>通过select * from infomation_schema.INNODB_TRX;可查看</p><p>INNODB_LOCKS表，该表由如下字段组成：</p><p>lock_id:锁的ID。</p><p>lock_trx_id:事务ID。</p><p>lock_mode:锁的模式。</p><p>lock_type:锁的类型，表锁还是行锁。</p><p>lock_table:要加锁的表。</p><p>lock_index:锁的索引。</p><p>lock_space:InnoDB存储引擎表空间的ID号。</p><p>lock_page:被锁住的页的数量。若是表锁，则该值为NULL。</p><p>lock_rec:被锁住的行的数量。若是表锁，则该值为NULL。</p><p>lock_data:被锁住的行的主键值。当是表锁时，该值为NULL。</p><p>通过select * from information_schema.INNODB_LOCK;可查看</p><p>INNODB_LOCK_WAIT由4个字段组成：</p><p>requesting_trx_id:申请锁资源的事务ID。</p><p>requesting_lock_id:申请的锁的ID。</p><p>blocking_trx_id:阻塞的锁的ID。</p><p>通过select * from information_schema.INNODB_LOCK_WAITS;可查看。</p><p>一致性的非锁定读：InnoDB存储引擎通过行多版本控制的方式来读取当前执行时间数据库中行的数据。如果读取的行正在执行Delete、update操作，这时读取操作不会因此而会等待行上锁的释放，相反，InnoDB存储引擎会去读取行的一个快照数据。快照数据是指该行之前版本的数据，该实现是通过Undo段来实现。而Undo用来事务中回滚数据，因此快照本身是没有额外开销的。此外，快照数据是不需要上锁的，因为没有必要对历史的数据进行修改。一个行可能有不止一个快照数据，所以称这种技术为行多版本技术。由此带来并发控制，称之为多版本并发控制(Multi VersionConcurrency Control, MVCC)。</p><p>事务的隔离级别：Read uncommitted、Read committed、Repeatable read、serializable。在Read Committed和Repeatable Read下，InnoDB存储引擎使用非锁定一致性读。然而，对于快照的定义却不同。在Read Committed事务隔离级别下，对于快照数据，非一致性读总是读取被锁定行的最新一份快照数据。在Repeatable事务隔离级别下，对于快照数据，非一致性读总是读取事务开始时的行数据版本。</p><p><img src="../innodb%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E8%AF%A6%E8%A7%A3/%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB.jpg" alt="img" title="null"></p><p>锁的算法：</p><p>Record Lock:单行记录上的锁</p><p>Gap Lock:间隙锁，锁定一个范围，但不包含记录本身</p><p>Next-Key Lock:Gap Lock + Record Lock，锁定一个范围，并且锁定记录本身。</p><p>锁的问题：</p><p>丢失更新：经典的数据库问题，当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，会发生丢失更新问题。每个事务都不知道其它事务的存在。最后的更新将重写由其它事务所做的更新，这将导致数据丢失。 　　</p><p>例:</p><p>事务A和事务B同时修改某行的值，</p><p>1.事务A将数值改为1并提交</p><p>2.事务B将数值改为2并提交。</p><p>这时数据的值为2，事务A所做的更新将会丢失。</p><p>解决办法：事务并行变串行操作，对更新操作加排他锁。</p><p>脏读：一个事务读到另一个事务未提交的更新数据，即读到脏数据。</p><p>例:</p><p>1.Mary的原工资为1000, 财务人员将Mary的工资改为了8000(但未提交事务)</p><p>2.Mary读取自己的工资 ,发现自己的工资变为了8000，欢天喜地！</p><p>3.而财务发现操作有误，回滚了事务,Mary的工资又变为了1000, 像这样,Mary记取的工资数8000是一个脏数据。</p><p>解决办法：脏读只有在事务隔离级别是Read Uncommitted的情况下才会出现，innoDB默认隔离级别是Repeatable Read，所以生产环境下不会出现脏读。</p><p>不可重复读：在同一个事务中,多次读取同一数据,返回的结果有所不同。换句话说就是,后续读取可以读到另一个事务已提交的更新数据。相反”可重复读”在同一事务多次读取数据时,能够保证所读数据一样,也就是后续读取不能读到另一事务已提交的更新数据。脏读和不可重复读的主要区别在于，脏读是读到未提交的数据，不可重复读是读到已提交的数据。</p><p>例:</p><p>1.在事务1中，Mary 读取了自己的工资为1000,操作并没有完成</p><p>2.在事务2中，这时财务人员修改了Mary的工资为2000,并提交了事务.</p><p>3.在事务1中，Mary 再次读取自己的工资时，工资变为了2000</p><p>解决办法：读到已提交的数据，一般数据库是可接受的，因此事务隔离级别一般设为Read Committed。Mysql InnoDB通过Next-Key Lock算法避免不可重复读，默认隔离级别为Repeatable Read。</p><h3 id="mysql-innodb中的事务"><a href="#mysql-innodb中的事务" class="headerlink" title="mysql innodb中的事务"></a>mysql innodb中的事务</h3><p>事务的四个特性：原子性、一致性、隔离性、持久性</p><p>隔离性通过锁实现，原子性、一致性、持久性通过数据库的redo和undo来完成。</p><p>重做日志记录了事务的行为，通过redo实现，保证了事务的完整性，但事务有时还需要撤销，这时就需要产生undo。undo和redo正好相反，对于数据库进行修改时，数据库不但会产生redo，而且还会产生一定的undo，即使执行的事务或语句由于某种原因失败了，或者如果用一条rollback语句请求回滚，就可以用这些undo信息将数据回滚到修改之前的样子。与redo不同的是,redo存放在重做日志文件中，undo存放在数据库内部的一个特殊段(segment)中，这称为undo段(undo segment)，undo段位于共享表空间内。还有一点重要的是，undo记录的是与事务操作相反的逻辑操作，如insert undo 记录一个delete，所以undo只是逻辑地将数据库恢复成事务开始前的样子。如:insert 10万行的数据，可能导致表空间增大，回滚后，表空间不会减小回去。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;innodb特性：&quot;&gt;&lt;a href=&quot;#innodb特性：&quot; class=&quot;headerlink&quot; title=&quot;innodb特性：&quot;&gt;&lt;/a&gt;innodb特性：&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;主体系结构&lt;/strong&gt;：默认7个后台线程，4个io threa
      
    
    </summary>
    
    
      <category term="MySQL" scheme="https://husky-wu.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://husky-wu.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>知识点梳理</title>
    <link href="https://husky-wu.github.io/2020/12/18/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/"/>
    <id>https://husky-wu.github.io/2020/12/18/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/</id>
    <published>2020-12-18T03:18:59.000Z</published>
    <updated>2020-12-18T03:20:52.174Z</updated>
    
    <content type="html"><![CDATA[<h3 id="知识点梳理"><a href="#知识点梳理" class="headerlink" title="知识点梳理"></a>知识点梳理</h3><ul><li><input checked disabled type="checkbox"> 1.hexo img目录转换代码</li><li><input checked disabled type="checkbox"> 2.Oracle体系结构</li><li><input disabled type="checkbox"> 3.Oracle DG同步原理</li><li><input disabled type="checkbox"> 4.Oracle 配置参数解析</li><li><input disabled type="checkbox"> 5.Oracle 事务隔离级别</li><li><input disabled type="checkbox"> 6.Oracle 锁解析</li><li><input disabled type="checkbox"> 7.Oracle 工具梳理</li><li><input disabled type="checkbox"> 8.MySQL体系结构</li><li><input disabled type="checkbox"> 9.MySQL 主从复制原理</li><li><input disabled type="checkbox"> 10.MySQL 配置参数解析</li><li><input disabled type="checkbox"> 11.MySQL 事务隔离级别</li><li><input disabled type="checkbox"> 12.MySQL 锁解析</li><li><input disabled type="checkbox"> 13.MySQL 工具梳理</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;知识点梳理&quot;&gt;&lt;a href=&quot;#知识点梳理&quot; class=&quot;headerlink&quot; title=&quot;知识点梳理&quot;&gt;&lt;/a&gt;知识点梳理&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;input checked disabled type=&quot;checkbox&quot;&gt; 1.hexo img目
      
    
    </summary>
    
    
    
      <category term="知识点梳理" scheme="https://husky-wu.github.io/tags/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>工作记录2020</title>
    <link href="https://husky-wu.github.io/2020/12/18/%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%95/%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%952020/"/>
    <id>https://husky-wu.github.io/2020/12/18/%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%95/%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%952020/</id>
    <published>2020-12-18T03:07:07.000Z</published>
    <updated>2020-12-18T11:29:33.110Z</updated>
    
    <content type="html"><![CDATA[<h3 id="客户项目"><a href="#客户项目" class="headerlink" title="客户项目"></a>客户项目</h3><p>1.虹越花卉_PostgreSQL_备份恢复修复</p><p><a href="https://confluence.jiagouyun.com/pages/viewpage.action?pageId=130450092" target="_blank" rel="noopener">https://confluence.jiagouyun.com/pages/viewpage.action?pageId=130450092</a></p><p>2.泸州老窖_Oracle数据文件目录修复（测试员人为误操作）</p><p><a href="https://confluence.jiagouyun.com/pages/viewpage.action?pageId=130450134" target="_blank" rel="noopener">https://confluence.jiagouyun.com/pages/viewpage.action?pageId=130450134</a></p><p>3.碧桂园_异构迁移项目方案评估</p><p>4.亿腾医药_正式部署高可用步骤核对</p><p>5.友邦保险_DAS会话异常持有MDL问题</p><p><a href="https://confluence.jiagouyun.com/pages/viewpage.action?pageId=130449726" target="_blank" rel="noopener">https://confluence.jiagouyun.com/pages/viewpage.action?pageId=130449726</a></p><p>6.污染地图_事务日志无法扩展导致JOB异常</p><p><a href="https://confluence.jiagouyun.com/pages/viewpage.action?pageId=130450196" target="_blank" rel="noopener">https://confluence.jiagouyun.com/pages/viewpage.action?pageId=130450196</a></p><p>7.友邦保险_MySQL报错异常排查</p><p><a href="https://confluence.jiagouyun.com/pages/viewpage.action?pageId=130450190" target="_blank" rel="noopener">https://confluence.jiagouyun.com/pages/viewpage.action?pageId=130450190</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;客户项目&quot;&gt;&lt;a href=&quot;#客户项目&quot; class=&quot;headerlink&quot; title=&quot;客户项目&quot;&gt;&lt;/a&gt;客户项目&lt;/h3&gt;&lt;p&gt;1.虹越花卉_PostgreSQL_备份恢复修复&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://confluence.ji
      
    
    </summary>
    
    
    
      <category term="工作记录A" scheme="https://husky-wu.github.io/tags/%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%95A/"/>
    
  </entry>
  
</feed>
