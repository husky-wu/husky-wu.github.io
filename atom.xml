<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HuskyWuの博客</title>
  <icon>https://www.gravatar.com/avatar/677a3831b4f8567bbc2750dafb4fa06e</icon>
  <subtitle>Huskyの技术分享</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://husky-wu.github.io/"/>
  <updated>2021-01-05T17:20:12.304Z</updated>
  <id>https://husky-wu.github.io/</id>
  
  <author>
    <name>HuskyWu</name>
    <email>beantech@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Oracle体系结构及执行流程</title>
    <link href="https://husky-wu.github.io/2021/01/06/Oracle/Oracle%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%8F%8A%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/"/>
    <id>https://husky-wu.github.io/2021/01/06/Oracle/Oracle%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%8F%8A%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/</id>
    <published>2021-01-05T16:58:10.000Z</published>
    <updated>2021-01-05T17:20:12.304Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../Oracle%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%8F%8A%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/Oracle%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.jpg" alt="Oracle体系结构" title="null"></p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>实例是数据库启动时初始化的一组进程和内存结构</p><p><img src="../Oracle%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%8F%8A%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/image-20210106011153401.png" alt="image-20210106011153401" title="null"></p><h3 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h3><p><img src="../Oracle%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%8F%8A%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/image-20210106011202443.png" alt="image-20210106011202443" title="null"></p><h4 id="SGA-系统全局区"><a href="#SGA-系统全局区" class="headerlink" title="SGA(系统全局区)"></a>SGA(系统全局区)</h4><p>SGA是一块共享的内存区域，也是最大的一块内存区域</p><p><img src="../Oracle%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%8F%8A%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/image-20210106010305467.png" alt="image-20210106010305467" title="null"></p><h5 id="数据库缓冲区缓存"><a href="#数据库缓冲区缓存" class="headerlink" title="数据库缓冲区缓存"></a>数据库缓冲区缓存</h5><p>缓冲区缓存 是Oracle用来执行SQL 的工作区域，在更新数据时，用户会话不会直接去更新磁盘上的数据，而是先更新缓冲区缓存数据，以减少磁盘IO</p><p>脏缓冲区 </p><p>　　如果缓冲区存储的块和磁盘上的块不一致，该缓冲区就叫做“脏缓冲区”，脏缓冲区最终会由数据库写入器（DBWn）写入到磁盘中去。</p><h5 id="日志缓冲区"><a href="#日志缓冲区" class="headerlink" title="日志缓冲区"></a>日志缓冲区</h5><p>日志缓冲区是一块比较小的内存区域，它是用来短期存储将写入到磁盘中的重做日志文件中的变更向量的。</p><p>日志缓冲区存在的意义依然是为了减少磁盘IO，减少用户的等待时间，试想下，如果每一次用户DML操作都要进行等待重做记录被写入到磁盘中去，体验会有多差劲。</p><h5 id="共享池"><a href="#共享池" class="headerlink" title="共享池"></a>共享池</h5><p><img src="../Oracle%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%8F%8A%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/image-20210106010507375.png" alt="image-20210106010507375" title="null"></p><h6 id="库缓存"><a href="#库缓存" class="headerlink" title="库缓存"></a>库缓存</h6><p>库缓存这块内存区域会按已分析的格式缓存最近执行的代码，这样，同样的sql代码多次执行的时候，就不用重复地去进行代码分析，可以很大程度上提高系统性能</p><h6 id="数据字典缓存"><a href="#数据字典缓存" class="headerlink" title="数据字典缓存"></a>数据字典缓存</h6><p>存储oracle中的对象定义（表，视图，同义词，索引等数据库对象），这样在分析sql代码的时候，就不用频繁去磁盘上读取数据字典中的数据了</p><h6 id="PL-SQL区"><a href="#PL-SQL区" class="headerlink" title="PL/SQL区"></a>PL/SQL区</h6><p>缓存存储过程、函数、触发器等数据库对象，这些对象都存储在数据字典中，通过将其缓存到内存中，可以在重复调用的时候提高性能</p><h5 id="大池"><a href="#大池" class="headerlink" title="大池"></a>大池</h5><p>大池是个可选的内存区域，前面我们提到专有服务器连接和共享服务器连接，如果数据库采用了共享服务器连接模式，则要使用到大池；RMAN(Oracle的高级备份恢复工具)备份数据也需要大池</p><h5 id="Java池"><a href="#Java池" class="headerlink" title="Java池"></a>Java池</h5><p>Oracle 的很多选项使用java写的，Java池用作实例化Java对象所需的堆空间</p><h5 id="流池"><a href="#流池" class="headerlink" title="流池"></a>流池</h5><p>从重做日志中提取变更记录的进程 和 应用变更记录的进程会用到流池（如实例不正常关闭，譬如断电导致实例关闭，在重启时，Oracle会自动执行实例恢复过程，在此过程需要提取重做日志记录和应用重做日志两个动作）</p><h4 id="PGA-用户全局区"><a href="#PGA-用户全局区" class="headerlink" title="PGA(用户全局区)"></a>PGA(用户全局区)</h4><p>PGA是用户会话专有的内存区域，每个会话在服务器端都有一块专有的内存区域就是PGA</p><p><img src="../Oracle%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%8F%8A%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/image-20210106010325159.png" alt="image-20210106010325159" title="null"></p><h5 id="Private-SQL-area"><a href="#Private-SQL-area" class="headerlink" title="Private SQL area"></a>Private SQL area</h5><p>包含绑定信息、运行时的内存结构。每个发出sql语句的会话，都有一个private SQL area（私有SQL区）</p><h5 id="Session-memory"><a href="#Session-memory" class="headerlink" title="Session memory"></a>Session memory</h5><p>为保存会话中的变量以及其他与会话相关的信息，而分配的内存区。</p><h5 id="Cursor、SQL-Areas"><a href="#Cursor、SQL-Areas" class="headerlink" title="Cursor、SQL Areas"></a>Cursor、SQL Areas</h5><p>游标以及SQL存储区域。</p><h5 id="Work-Area"><a href="#Work-Area" class="headerlink" title="Work Area"></a>Work Area</h5><p>PGA的一大部分被分配给Work Area，用来执行如下操作：</p><p>a.基于操作符的排序，group by、order by、rollup和窗口函数。参数为sort_area_size  </p><p>b.hash散列连接，参数为hash_area_size     </p><p>c.位图合并，参数为bitmap_merge_area_size</p><p>d.位图创建，参数为create_bitmap_area_size </p><p>e.批量装载操作使用的写缓存</p><p>当发起的指令需要排序，则在PGA中进行，如果内存不够存放排序的尺寸，则超出的部分就在临时表空间完成排序，即在磁盘中完成。</p><p>下图是Oracle体系结构图，一般用户发起的请求，需要经历1区–&gt;2区–&gt;3区，或者1区–&gt;2区</p><h3 id="进程结构"><a href="#进程结构" class="headerlink" title="进程结构"></a>进程结构</h3><p><img src="../Oracle%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%8F%8A%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/image-20210106010644502.png" alt="image-20210106010644502" title="null"></p><h4 id="监听进程"><a href="#监听进程" class="headerlink" title="监听进程"></a>监听进程</h4><h4 id="数据库写入器（DBWn）"><a href="#数据库写入器（DBWn）" class="headerlink" title="数据库写入器（DBWn）"></a>数据库写入器（DBWn）</h4><p>DBWn的作用就是将变脏了的缓冲区从数据库缓冲区缓存中写入到磁盘中的数据文件中去</p><p>DBWn是个比较懒的进程，它会尽可能少的进行写入，在以下四种情况它会执行写入：</p><p>a.没有任何可用缓冲区（不得不写啊）</p><p>b.脏缓冲区过多</p><p>c.3秒超时（最晚3秒会执行一次写入）</p><p>d.遇到检查点，即checkPoint（检查点），检查点是个Oracle事件，遇到检查点，DBWn会执行写入。比如实例有序关闭的时候会有检查点，DBWn会将所有脏缓冲区写入到磁盘上去的，这很容易理解，要保持数据文件的一致性。</p><h4 id="日志写入器（LGWR）"><a href="#日志写入器（LGWR）" class="headerlink" title="日志写入器（LGWR）"></a>日志写入器（LGWR）</h4><p>日志写入器（LGWR）就是把日志缓冲区内的内容写入到磁盘的重做日志文件中去，相比数据库写入器（DBWn），日志写入器就勤快多了。</p><p>以下三种情况LGWR会执行写入：</p><p>a.commit时写入</p><p>　　前面提过，DBWn的写入和commit没有任何关系，如果commit时数据库没有任何记录，那数据就真的丢失了，Oracle 的重做日志就是为了保证数据安全而存在的，commit时，会话会先挂起，等待LGWR将这些记录写入到磁盘上的重做日志文件中，才会通知用户提交完成。所以，LGWR在commit时执行写入，是为了确保事务永不丢失。</p><p>b.日志缓冲区的占用率达到1/3。</p><p>c.DBWn要写入脏缓冲区前</p><p>这个写入是为了数据回滚考虑的。DBWn完全可能写入还没提交的事务（参照上面提到的写入时机）</p><p>那如何保证事务回滚呢？</p><p>　　首先要知道，DBWn除了写入实际的数据，还会写入撤销数据（不了解的同学可参考我的另一篇博文中对于撤销段的描述 Oracle闪回技术详解。）简单说，事务回滚需要撤销数据，在写入撤销数据前，会先写入针对撤销数据的日志记录（有点绕），若用户要进行事务回滚，就可以应用这些日志记录来构造撤销数据，然后进行回滚。</p><p>我们对这两块最重要的内存区域和对应的后台进程做个总结：</p><p>　　数据库缓冲区缓存和日志缓冲区都是为了提高性能，避免频繁IO而存在的。日志缓冲区相比数据库缓冲区缓存要小的多，并且不能进行自动管理，对于日志缓冲区的修改需要重启实例，数据库缓冲区缓存可进行自动管理。作用在数据库缓冲区缓存上的DBWn进程，为了避免频繁的磁盘IO导致系统性能下降，会尽可能少地执行写入，且DBWn的写入和commit操作没有任何关系；</p><p>　　而作用在日志缓冲区上的LGWR进程，则会非常积极地进行写入，一般情况下，它几乎是实时地将重做日志记录转储到磁盘中去。LGWR是Oracle体系结构中最大的瓶颈之一。DML的速度不可能超过LGWR将变更向量写入磁盘的速度。</p><h4 id="SMON-System-Monitor"><a href="#SMON-System-Monitor" class="headerlink" title="SMON(System Monitor)"></a>SMON(System Monitor)</h4><p>安装和打开数据库，实例恢复也是由此进程完成的</p><h4 id="PMON-Process-Monitor"><a href="#PMON-Process-Monitor" class="headerlink" title="PMON(Process Monitor)"></a>PMON(Process Monitor)</h4><p>进程监视器，主要监视服务器进程。前面提到过，专有服务器体系模式下，用户进程和服务器进程是一对一的关系，如果某个会话发生异常，PMON会销毁对应的服务器进程，回滚未提交的事务，并回收会话专有的PGA内存区域。</p><h4 id="CKPT-Checkpoint-Process"><a href="#CKPT-Checkpoint-Process" class="headerlink" title="CKPT(Checkpoint Process)"></a>CKPT(Checkpoint Process)</h4><p>CKPT负责发起检查点信号，手动设置检查点的语法:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span>&gt; <span class="keyword">alter</span> <span class="keyword">system</span> <span class="keyword">checkpoint</span>;</span><br></pre></td></tr></table></figure><p>　　检查点可强制DBWn写入脏缓冲区，当数据库崩溃后，由于大量脏缓冲区未写入数据文件，在重新启动时，需要由SMON进行实例恢复，实例恢复需要提取和应用重做日志记录，提取的位置就是从上次检查点发起的位置开始的（检查点之前的数据已经被强制写入到数据文件中去了），这个位置称为RBA(redo byte address)，CKPT会不断将这个位置更新到控制文件中去（以确定实例恢复需要从哪儿开始提取日志记录）。</p><h4 id="MMON-Manageability-Monitor"><a href="#MMON-Manageability-Monitor" class="headerlink" title="MMON(Manageability Monitor)"></a>MMON(Manageability Monitor)</h4><p>数据库的自我监视和自我调整的支持进程。实例在运行中，会收集大量有关实例活动和性能的统计数据，这些数据会收集到SGA中，MMON定期从SGA中捕获这些统计数据，并将其写入到数据字典中，便于后续对这些快照进行分析。（默认情况，MMON每隔一个小时收集一次快照）</p><h4 id="ARCn（Archiver）"><a href="#ARCn（Archiver）" class="headerlink" title="ARCn（Archiver）"></a>ARCn（Archiver）</h4><p>归档进程，这个进程是可选的，如果数据库配置为归档模式，这个进程就是必须的。所谓归档，就是将重做日志文件永久保存（生产库一般都会配置为归档模式）到归档日志文件中。归档日志文件和重做日志文件作用是一样的，只不过重做日志文件会不短被重写，而归档日志文件则保留了关于数据更改的完整的历史记录。</p><h2 id="数据库（存储结构）"><a href="#数据库（存储结构）" class="headerlink" title="数据库（存储结构）"></a>数据库（存储结构）</h2><p><img src="../Oracle%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%8F%8A%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/image-20210106010946789.png" alt="image-20210106010946789" title="null"></p><h3 id="物理存储结构"><a href="#物理存储结构" class="headerlink" title="物理存储结构"></a>物理存储结构</h3><p><img src="../Oracle%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%8F%8A%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/image-20210106010930120.png" alt="image-20210106010930120" title="null"></p><p>所谓外部文件，意味着这些文件从严格意义上来讲并不属于Oracle数据库的一部分</p><h4 id="控制文件"><a href="#控制文件" class="headerlink" title="控制文件"></a>控制文件</h4><p>控制文件虽小，但作用重大，它包含指向数据库其余部分的指针（包括重做日志文件，数据文件，归档日志文件等的位置），存储重要的序列号和时间戳，存储RMAN备份的详细信息。控制文件一旦受损，那实例会立马终止，一般对数据文件的保护采用多路复用机制，就是冗余多份在不同物理位置。</p><h4 id="数据文件"><a href="#数据文件" class="headerlink" title="数据文件"></a>数据文件</h4><p>数据文件存储着实际的数据，DBWn会将数据库缓冲区中的内容写入到这类文件中去，数据文件的大小和数量是不受限制的。Oracle从10g开始，创建一个数据库至少需要两个数据文件，一个用于SYSTEM表空间，该表空间用来存储数据字典；一个用于SYSAUX表空间，这个表空间用来存储一些数据字典的辅助数据。</p><p>　　数据文件由一个个的Oracle块组成，这是Oracle的I/O基础单元，与操作系统块是不同的概念，Oracle块要比操作系统块大，这当然有处于性能的一些考虑，但我们考虑这样一种情况，当用户使用操作系统命令进行数据文件的备份的时候（假设1个Oracle块=8个操作系统块），已经复制了4个操作系统块，然后CPU被DBWn抢占了，DBWn又重新对这个Oracle块进行了更新，这时，当复制命令又得到了CPU时间去复制剩余的4个块的时候，就造成了整个Oracle块的数据不一致，所以，这也是在执行这种备份（用户自行备份）的时候，需要做一些额外处理，比如将表空间置为备份模式的原因。当然，使用RMAN是不存在这样的问题的，RMAN的备份机制是肯定可以得到数据一致的块的。（这块内容作了解即可）</p><p>　　对于数据文件的保护，一般可进行定期备份，或者使用RAID也可以。</p><h4 id="联机重做日志文件"><a href="#联机重做日志文件" class="headerlink" title="联机重做日志文件"></a>联机重做日志文件</h4><p>重做日志按时间顺序存储应用于数据库的一连串的变更向量（包含联机重做日志文件和归档日志文件）。由SMON在数据库启动时自动执行的实例恢复 和 磁盘损坏所要求的提取备份恢复都会应用到重做日志进行相应的数据恢复</p><p>　　重做日志文件也建议进行多路复用，一个数据库至少要有两组重做日志文件。一组供LGWR进行写入，日志文件是固定大小，业务高峰期会很快写满，写满之后会切换到第二组上，在配置为归档模式的数据库中，这时由归档进程（ARCn）开始将第一组的内容进行归档备份，如此循环地进行写入和归档。需要注意的是，在归档进程还未对当前组的日志归档完毕前，是不允许LGWR对其进行重写的。</p><h4 id="初始化参数文件"><a href="#初始化参数文件" class="headerlink" title="初始化参数文件"></a>初始化参数文件</h4><p>这个文件存储了数据库所需的一些参数设置，比如各个内存区域的大小，可允许的最大进程数，最大会话数，控制文件的位置，数据库的名称等等，参数文件也是实例启动时首先要加载的文件</p><h4 id="口令文件"><a href="#口令文件" class="headerlink" title="口令文件"></a>口令文件</h4><p>一般称为外部口令文件。一般的用户名和口令是存放在数据字典中，不会存放在这个文件中。在一些特殊场景下，比如实例还未启动，这时，我可能需要以管理员的身份登入系统去执行一些恢复或者启动操作，然而此时，数据字典由于实例还没启动是不存在的，这时就需要外部口令文件进行用户身份的验证。</p><h4 id="归档重做日志文件"><a href="#归档重做日志文件" class="headerlink" title="归档重做日志文件"></a>归档重做日志文件</h4><p>ARCn将联机重做日志文件会备份归档到这类文件中去，归档日志文件保留了数据更改的完整历史信息。</p><h3 id="逻辑存储结构"><a href="#逻辑存储结构" class="headerlink" title="逻辑存储结构"></a>逻辑存储结构</h3><p>Oracle将其物理结构从逻辑存储结构中抽象出来，物理机构是系统管理员能看到的，逻辑结构则是用户所能感知到的。比较典型的逻辑结构就是 “段”和”表空间”。</p><p><img src="../Oracle%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%8F%8A%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/image-20210106010935141.png" alt="image-20210106010935141" title="null"></p><h4 id="表空间（tablespace）"><a href="#表空间（tablespace）" class="headerlink" title="表空间（tablespace）"></a>表空间（tablespace）</h4><p>表空间从逻辑上是多个段的结合，在物理上是多个数据文件的集合，相当于在段和数据文件的对应中加入了一个中间层来解决这种多对多的关系。</p><p>　　在早期的一些数据库设计中，段和数据文件是一对一的关系，一个段一个数据文件，这种设计有很多弊端，首先，段的数量是不固定的，有可能一个系统中上千张表，那就得需要上千个数据文件，系统管理员要管理这么多文件肯定会抓狂的；</p><p>​    还有一种情况就是某些历史表可能特别大，大到底层系统对单个文件的限制，用一个数据文件去承载的话肯定是不行的。表空间则完美解决了这样的问题。</p><h4 id="段（segment）"><a href="#段（segment）" class="headerlink" title="段（segment）"></a>段（segment）</h4><p>段就是包含所有数据的逻辑结构，比较典型的段就是”表”，称为表段，还有索引段，撤销段等等。</p><h4 id="区（extend）"><a href="#区（extend）" class="headerlink" title="区（extend）"></a>区（extend）</h4><h4 id="块（block）"><a href="#块（block）" class="headerlink" title="块（block）"></a>块（block）</h4><h2 id="SQL执行流程"><a href="#SQL执行流程" class="headerlink" title="SQL执行流程"></a>SQL执行流程</h2><p>1）语法分析，分析语句的语法是否符合规范，衡量语句中各表达式的意义</p><p>2）语义分析，检查语句中涉及的所有数据库对象是否存在，且用户有相应的权限</p><p>3）视图转换，将涉及视图的查询语句转换为相应的对基表查询语句</p><p>4）表达式转换， 将复杂的 SQL 表达式转换为较简单的等效连接表达式</p><p>5）选择优化器，不同的优化器一般产生不同的“执行计划”</p><p>6）选择连接方式，ORACLE有三种连接方式，对多表连接ORACLE可选择适当的连接方式</p><p>7）选择连接顺序，对多表连接ORACLE选择哪一对表先连接，选择这两表中哪个表做为源数据表</p><p>8）选择数据的搜索路径，根据以上条件选择合适的数据搜索路径，如是选用全表搜索还是利用索引或是其他的方式</p><p>9）运行“执行计划”</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;../Oracle%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%8F%8A%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/Oracle%E4%BD%93%E7%B3%BB%E7%BB%93%E6
      
    
    </summary>
    
    
      <category term="Oracle" scheme="https://husky-wu.github.io/categories/Oracle/"/>
    
    
      <category term="Oracle" scheme="https://husky-wu.github.io/tags/Oracle/"/>
    
  </entry>
  
  <entry>
    <title>MySQL加锁过程详解-09-理解innodb的锁(record,gap,next-key-lock)</title>
    <link href="https://husky-wu.github.io/2021/01/04/MySQL/MySQL%E9%94%81%E8%AF%A6%E8%A7%A3/MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-09-%E7%90%86%E8%A7%A3innodb%E7%9A%84%E9%94%81-record-gap-next-key-lock/"/>
    <id>https://husky-wu.github.io/2021/01/04/MySQL/MySQL%E9%94%81%E8%AF%A6%E8%A7%A3/MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-09-%E7%90%86%E8%A7%A3innodb%E7%9A%84%E9%94%81-record-gap-next-key-lock/</id>
    <published>2021-01-04T06:00:33.000Z</published>
    <updated>2021-01-04T06:57:13.269Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Record-lock"><a href="#Record-lock" class="headerlink" title="Record lock"></a>Record lock</h1><p>单条索引记录上加锁，record lock锁住的永远是索引，而非记录本身，即使该表上没有任何索引，那么innodb会在后台创建一个隐藏的聚集主键索引，那么锁住的就是这个隐藏的聚集主键索引。所以说当一条sql没有走任何索引时，那么将会在每一条聚集索引后面加X锁，这个类似于表锁，但原理上和表锁应该是完全不同的。</p><h1 id="Gap-lock"><a href="#Gap-lock" class="headerlink" title="Gap lock"></a>Gap lock</h1><p>在索引记录之间的间隙中加锁，或者是在某一条索引记录之前或者之后加锁，并不包括该索引记录本身。gap lock的机制主要是解决可重复读模式下的幻读问题，关于幻读的演示和gap锁如何解决了幻读。关于这一块，先给出几个定义</p><h2 id="快照读："><a href="#快照读：" class="headerlink" title="快照读："></a>快照读：</h2><p>简单的select操作，没有lock in share mode或for update，快照读不会加任何的锁，而且由于mysql的一致性非锁定读的机制存在，任何快照读也不会被阻塞。但是如果事务的隔离级别是SERIALIZABLE的话，那么快照读也会被加上共享的next-key锁，本文不对SERIALIZABLE隔离级别做叙述。</p><h2 id="当前读："><a href="#当前读：" class="headerlink" title="当前读："></a>当前读：</h2><p>官方文档的术语叫locking read，也就是insert，update，delete,select..in share mode和select..for update,当前读会在所有扫描到的索引记录上加锁，不管它后面的where条件到底有没有命中对应的行记录。当前读可能会引起死锁。</p><h2 id="意向锁："><a href="#意向锁：" class="headerlink" title="意向锁："></a>意向锁：</h2><p>innodb的意向锁主要用户多粒度的锁并存的情况。比如事务A要在一个表上加S锁，如果表中的一行已被事务B加了X锁，那么该锁的申请也应被阻塞。如果表中的数据很多，逐行检查锁标志的开销将很大，系统的性能将会受到影响。为了解决这个问题，可以在表级上引入新的锁类型来表示其所属行的加锁情况，这就引出了“意向锁”的概念。</p><p>举个例子，如果表中记录1亿，事务A把其中有几条记录上了行锁了，这时事务B需要给这个表加表级锁，如果没有意向锁的话，那就要去表中查找这一亿条记录是否上锁了。如果存在意向锁，那么假如事务Ａ在更新一条记录之前，先加意向锁，再加Ｘ锁，事务B先检查该表上是否存在意向锁，存在的意向锁是否与自己准备加的锁冲突，如果有冲突，则等待直到事务Ａ释放，而无须逐条记录去检测。事务Ｂ更新表时，其实无须知道到底哪一行被锁了，它只要知道反正有一行被锁了就行了。</p><p>说白了意向锁的主要作用是处理行锁和表锁之间的矛盾，能够显示“某个事务正在某一行上持有了锁，或者准备去持有锁”</p><p>下文之知乎大神观点：<a href="https://www.zhihu.com/question/51513268" target="_blank" rel="noopener">https://www.zhihu.com/question/51513268</a></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">innodb的意向锁有什么作用？</span><br><span class="line">mysql官网上对于意向锁的解释中有这么一句话“The main purpose <span class="keyword">of</span> IX <span class="keyword">and</span> <span class="keyword">IS</span> locks <span class="keyword">is</span> <span class="keyword">to</span> <span class="keyword">show</span> that someone <span class="keyword">is</span> locking a <span class="keyword">row</span>, <span class="keyword">or</span> going <span class="keyword">to</span> <span class="keyword">lock</span> a <span class="keyword">row</span> <span class="keyword">in</span> the <span class="keyword">table</span>.”意思是说加意向锁的目的是为了表明某个事务正在锁定一行或者将要锁定一行。那么，意向锁的作用就是“表明”加锁的意图，可是为什么要表明这个 意图呢？如果仅仅锁定一行仅仅需要加一个锁，那么就直接加锁就好了，这里要表明加锁意图的原因是因为要锁定一行不仅仅是要加一个锁，而是要做一系列操作吗？</span><br><span class="line">作者：尹发条地精</span><br><span class="line"></span><br><span class="line">我最近也在看这个，我说一下我的理解①在mysql中有表锁，<span class="keyword">LOCK</span> <span class="keyword">TABLE</span> my_tabl_name <span class="keyword">READ</span>;  用读锁锁表，会阻塞其他事务修改表数据。<span class="keyword">LOCK</span> <span class="keyword">TABLE</span> my_table_name <span class="keyword">WRITe</span>; 用写锁锁表，会阻塞其他事务读和写。②Innodb引擎又支持行锁，行锁分为共享锁，一个事务对一行的共享只读锁。排它锁，一个事务对一行的排他读写锁。③这两中类型的锁共存的问题考虑这个例子：事务A锁住了表中的一行，让这一行只能读，不能写。之后，事务B申请整个表的写锁。如果事务B申请成功，那么理论上它就能修改表中的任意一行，这与A持有的行锁是冲突的。数据库需要避免这种冲突，就是说要让B的申请被阻塞，直到A释放了行锁。数据库要怎么判断这个冲突呢？step1：判断表是否已被其他事务用表锁锁表step2：判断表中的每一行是否已被行锁锁住。注意step2，这样的判断方法效率实在不高，因为需要遍历整个表。于是就有了意向锁。在意向锁存在的情况下，事务A必须先申请表的意向共享锁，成功后再申请一行的行锁。在意向锁存在的情况下，上面的判断可以改成step1：不变step2：发现表上有意向共享锁，说明表中有些行被共享行锁锁住了，因此，事务B申请表的写锁会被阻塞。注意：申请意向锁的动作是数据库完成的，就是说，事务A申请一行的行锁的时候，数据库会自动先开始申请表的意向锁，不需要我们程序员使用代码来申请。总结：为了实现多粒度锁机制（白话：为了表锁和行锁都能用）</span><br></pre></td></tr></table></figure><h2 id="不可重复读："><a href="#不可重复读：" class="headerlink" title="不可重复读："></a>不可重复读：</h2><p>指的是在同一个事务中，连续几次快照读，读取的记录应该是一样的</p><p>不可重复读的演示较为简单，本文不做讨论。</p><h2 id="幻读："><a href="#幻读：" class="headerlink" title="幻读："></a>幻读：</h2><p>指的是在一个事务A中执行了一个当前读操作，而另外一个事务B在事务A的影响区间内insert了一条记录，这时事务A再执行一个当前读操作时，出现了幻行。这和不可重复读的主要区别就在与事务A中一个是快照读，一个当前读；并且事务B中一个是任何的dml操作，一个只是insert。比如在A中select * from test where id&lt;10 lock in share mode结果集为（1,2,3），这时在B中对test表插入了一条记录4，这时在A中重新查询结果集就是(1,2,3,4），和事务A在第一次查询出来的结果集不一致，这里的4就是幻行。</p><p>演示条件：由于可重读的隔离级别下，默认采用Next-Key Locks，就是Record lock和gap lock的结合，即除了锁住记录本身，还要再锁住索引之间的间隙，所以这个gap lock机制默认打开，并不会产生幻行，那么我们要演示幻行的话，要么将隔离级别改为read-commited，要么在REPEATABLE-READ模式下禁用掉gap lock，这里我们采用的是第二种方式。</p><h3 id="幻读的演示"><a href="#幻读的演示" class="headerlink" title="幻读的演示"></a>幻读的演示</h3><p>在演示之前又引入了innodb_locks_unsafe_for_binlog参数，该参数可以禁用gap lock。</p><p>innodb_locks_unsafe_for_binlog：静态参数，默认为0，表示启动gap lock，如果设置为1，表示禁用gap lock，这时mysql就只有record lock了，不过值得注意的是，即使了设置了1，关于外键和唯一键重复检查方面用到的gap lock依旧有效。这时可以简单地理解成事务的隔离级别退化成可重复读，然后两者应该还是有所区别的。建议是不要随便设置，我们这里设置只是做个简单的幻读演示，mysql后续的版本可能都会废弃掉这个参数了。</p><p>session 1 先将myid&gt;95的记录加一个当前读</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show create table test_gap_lock\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">    Table: test_gap_lock</span><br><span class="line">Create Table: CREATE TABLE `test_gap_lock` (</span><br><span class="line"> `id` int(11) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"> `name` varchar(100)<span class="built_in"> DEFAULT </span><span class="literal">NULL</span>,</span><br><span class="line"> `myid` int(11)<span class="built_in"> DEFAULT </span><span class="literal">NULL</span>,</span><br><span class="line"> PRIMARY KEY (`id`),</span><br><span class="line"> UNIQUE KEY `uniq_name` (`name`),</span><br><span class="line"> KEY `idex_myid` (`myid`)</span><br><span class="line">) <span class="attribute">ENGINE</span>=InnoDB<span class="built_in"> DEFAULT </span><span class="attribute">CHARSET</span>=utf8</span><br><span class="line">1 row <span class="keyword">in</span> <span class="builtin-name">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; begin;</span><br><span class="line"></span><br><span class="line">mysql&gt; select * <span class="keyword">from</span> test_gap_lock where myid&gt;95 <span class="keyword">for</span> update;</span><br><span class="line">+----+------------+------+</span><br><span class="line">| id | name    | myid |</span><br><span class="line">+----+------------+------+</span><br><span class="line">|  1 | jiang    |  99 |</span><br><span class="line">|  2 | hubingmei  |  99 |</span><br><span class="line">|  5 | hubingmei4 |  100 |</span><br><span class="line">+----+------------+------+</span><br><span class="line">3 rows <span class="keyword">in</span> <span class="builtin-name">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure><p>session 2  这时session 2插入myid=98的记录成功了。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insert <span class="built_in">int</span>o test_gap_lock values(<span class="number">6</span>,<span class="string">'jiang2'</span>,<span class="number">98</span>);</span><br><span class="line">Query OK, <span class="number">1</span> row affected (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>session 1 这时session 1再次查看时发现记录myid=98的记录已经存在了，这条记录就是幻行。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from test<span class="emphasis">_gap_</span>lock where myid&gt;95 for update;</span><br><span class="line"><span class="code">+----+</span>------------<span class="code">+------+</span></span><br><span class="line">| id | name    | myid |</span><br><span class="line"><span class="code">+----+</span>------------<span class="code">+------+</span></span><br><span class="line">|  1 | jiang    |  99 |</span><br><span class="line">|  2 | hubingmei  |  99 |</span><br><span class="line">|  5 | hubingmei4 |  100 |</span><br><span class="line">|  6 | jiang2   |  98 |</span><br><span class="line"><span class="code">+----+</span>------------<span class="code">+------+</span></span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><h3 id="gap-lock机制解决幻读问题演示"><a href="#gap-lock机制解决幻读问题演示" class="headerlink" title="gap lock机制解决幻读问题演示"></a>gap lock机制解决幻读问题演示</h3><p>条件：我们再把innodb_locks_unsafe_for_binlog值改回默认值0，并且tx_isolation为REPEATABLE-READ，演示时务必explain下，确保该sql走了非唯一索引idx_myid(因为如果测试数据较少的话，可能优化器直接走全表扫描，那就导致锁住所有记录，无法模拟出gap锁)</p><h4 id="演示范例-1（非唯一索引-范围当前读）"><a href="#演示范例-1（非唯一索引-范围当前读）" class="headerlink" title="演示范例 1（非唯一索引+范围当前读）"></a>演示范例 1（非唯一索引+范围当前读）</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show create table test_gap_lock\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">    Table: test_gap_lock</span><br><span class="line">Create Table: CREATE TABLE `test_gap_lock` (</span><br><span class="line"> `id` int(11) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"> `name` varchar(100)<span class="built_in"> DEFAULT </span><span class="literal">NULL</span>,</span><br><span class="line"> `myid` int(11)<span class="built_in"> DEFAULT </span><span class="literal">NULL</span>,</span><br><span class="line"> PRIMARY KEY (`id`),</span><br><span class="line"> UNIQUE KEY `uniq_name` (`name`),</span><br><span class="line"> KEY `idex_myid` (`myid`)</span><br><span class="line">) <span class="attribute">ENGINE</span>=InnoDB<span class="built_in"> DEFAULT </span><span class="attribute">CHARSET</span>=utf8</span><br><span class="line">1 row <span class="keyword">in</span> <span class="builtin-name">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure><p>session 1 先explain确保session的当前读sql执行走了索引idx_myid</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; explain select * from test<span class="emphasis">_gap_</span>lock where myid&gt;100 for update;</span><br><span class="line"><span class="code">+----+</span>-------------<span class="code">+---------------+</span>-------<span class="code">+---------------+</span>-----------<span class="code">+---------+</span>------<span class="code">+------+</span>-----------------------+</span><br><span class="line">| id | select<span class="emphasis">_type | table     | type  | possible_</span>keys | key    | key<span class="emphasis">_len | ref  | rows | Extra         |</span></span><br><span class="line"><span class="emphasis">+----+-------------+---------------+-------+---------------+-----------+---------+------+------+-----------------------+</span></span><br><span class="line"><span class="emphasis">|  1 | SIMPLE    | test_</span>gap<span class="emphasis">_lock | range | idex_</span>myid   | idex<span class="emphasis">_myid | 5    | NULL |   2 | Using index condition |</span></span><br><span class="line"><span class="emphasis">+----+-------------+---------------+-------+---------------+-----------+---------+------+------+-----------------------+</span></span><br><span class="line"><span class="emphasis">1 row in set (0.00 sec)</span></span><br><span class="line"><span class="emphasis">mysql&gt;  select * from test_</span>gap<span class="emphasis">_lock where myid&gt;100 for update;</span></span><br><span class="line"><span class="emphasis">+----+------------+------+</span></span><br><span class="line"><span class="emphasis">| id | name    | myid |</span></span><br><span class="line"><span class="emphasis">+----+------------+------+</span></span><br><span class="line"><span class="emphasis">|  5 | hubingmei4 |  101 |</span></span><br><span class="line"><span class="emphasis">| 98 | test    |  105 |</span></span><br><span class="line"><span class="emphasis">+----+------------+------+</span></span><br><span class="line"><span class="emphasis">2 rows in set (0.00 sec)</span></span><br></pre></td></tr></table></figure><p>session 2 先插入myid=56的成功，因为锁住的间隙是myid&gt;100,56不在该范围内；再插入myid=109时，会一直卡住直到session 1commit，rollback或者直接锁等待超时，在锁等待超时前在session 1中执行同样的sql，得到的结果依旧只有id=5,98的记录，这样就避免了幻读问题</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">insert</span> <span class="keyword">into</span> test_gap_lock <span class="keyword">values</span>(<span class="number">999</span>,<span class="string">'test2'</span>,<span class="number">56</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="keyword">row</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line">mysql&gt; <span class="keyword">insert</span> <span class="keyword">into</span> test_gap_lock <span class="keyword">values</span>(<span class="number">123</span>,<span class="string">'test4'</span>,<span class="number">109</span>);</span><br><span class="line">ERROR <span class="number">1205</span> (HY000): <span class="keyword">Lock</span> wait timeout exceeded; try restarting <span class="keyword">transaction</span></span><br></pre></td></tr></table></figure><h4 id="演示范例2（非唯一索引-等值当前读）"><a href="#演示范例2（非唯一索引-等值当前读）" class="headerlink" title="演示范例2（非唯一索引+等值当前读）"></a>演示范例2（非唯一索引+等值当前读）</h4><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select <span class="symbol">*</span> from test_gap_lock;</span><br><span class="line">+-----+------------+------+</span><br><span class="line">|<span class="string"> id  </span>|<span class="string"> name    </span>|<span class="string"> myid </span>|</span><br><span class="line">+-----+------------+------+</span><br><span class="line">|<span class="string">  1 </span>|<span class="string"> jiang    </span>|<span class="string">  98 </span>|</span><br><span class="line">|<span class="string">  2 </span>|<span class="string"> hubingmei  </span>|<span class="string">  99 </span>|</span><br><span class="line">|<span class="string">  5 </span>|<span class="string"> hubingmei4 </span>|<span class="string">  101 </span>|</span><br><span class="line">|<span class="string">  6 </span>|<span class="string"> jiang2   </span>|<span class="string">  100 </span>|</span><br><span class="line">|<span class="string">  7 </span>|<span class="string"> jiang22   </span>|<span class="string">  70 </span>|</span><br><span class="line">|<span class="string">  67 </span>|<span class="string"> jiang222  </span>|<span class="string">  80 </span>|</span><br><span class="line">|<span class="string">  98 </span>|<span class="string"> test    </span>|<span class="string">  105 </span>|</span><br><span class="line">|<span class="string"> 123 </span>|<span class="string"> test4    </span>|<span class="string">  109 </span>|</span><br><span class="line">|<span class="string"> 999 </span>|<span class="string"> test2    </span>|<span class="string">  56 </span>|</span><br><span class="line">+-----+------------+------+</span><br><span class="line">9 rows in set (0.00 sec)</span><br><span class="line">session 1</span><br><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; explain delete from test_gap_lock where myid=100;</span><br><span class="line">+----+-------------+---------------+-------+---------------+-----------+---------+-------+------+-------------+</span><br><span class="line">|<span class="string"> id </span>|<span class="string"> select_type </span>|<span class="string"> table     </span>|<span class="string"> type  </span>|<span class="string"> possible_keys </span>|<span class="string"> key    </span>|<span class="string"> key_len </span>|<span class="string"> ref  </span>|<span class="string"> rows </span>|<span class="string"> Extra    </span>|</span><br><span class="line">+----+-------------+---------------+-------+---------------+-----------+---------+-------+------+-------------+</span><br><span class="line">|<span class="string">  1 </span>|<span class="string"> SIMPLE    </span>|<span class="string"> test_gap_lock </span>|<span class="string"> range </span>|<span class="string"> idex_myid   </span>|<span class="string"> idex_myid </span>|<span class="string"> 5    </span>|<span class="string"> const </span>|<span class="string">   2 </span>|<span class="string"> Using where </span>|</span><br><span class="line">+----+-------------+---------------+-------+---------------+-----------+---------+-------+------+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line">mysql&gt; delete from test_gap_lock where myid=100;</span><br><span class="line">Query OK, 2 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><p>session 2 插入myid=99的记录依旧阻塞，存在gap锁；插入myid=97的记录成功</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">insert</span> <span class="keyword">into</span> test_gap_lock <span class="keyword">values</span>(<span class="number">676</span>,<span class="string">'gap recored test'</span>,<span class="number">99</span>);</span><br><span class="line">ERROR <span class="number">1205</span> (HY000): <span class="keyword">Lock</span> wait timeout exceeded; try restarting <span class="keyword">transaction</span></span><br><span class="line">mysql&gt; <span class="keyword">insert</span> <span class="keyword">into</span> test_gap_lock <span class="keyword">values</span>(<span class="number">675</span>,<span class="string">'gap recored test1'</span>,<span class="number">97</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="keyword">row</span> affected (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h4 id="范例3（主键索引-范围当前读）"><a href="#范例3（主键索引-范围当前读）" class="headerlink" title="范例3（主键索引+范围当前读）"></a>范例3（主键索引+范围当前读）</h4><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from test<span class="emphasis">_gap_</span>lock ;</span><br><span class="line"><span class="code">+-----+</span>------------<span class="code">+------+</span></span><br><span class="line">| id  | name    | myid |</span><br><span class="line"><span class="code">+-----+</span>------------<span class="code">+------+</span></span><br><span class="line">|  1 | jiang    |  98 |</span><br><span class="line">|  2 | hubingmei  |  98 |</span><br><span class="line">|  5 | hubingmei4 |  100 |</span><br><span class="line">|  6 | jiang2   |  100 |</span><br><span class="line">|  7 | jiang22   |  70 |</span><br><span class="line">|  67 | jiang222  |  80 |</span><br><span class="line">|  98 | test    |  105 |</span><br><span class="line">| 123 | test4    |  109 |</span><br><span class="line">| 999 | test2    |  56 |</span><br><span class="line"><span class="code">+-----+</span>------------<span class="code">+------+</span></span><br><span class="line">9 rows in set (0.00 sec)</span><br><span class="line">session 1 </span><br><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; explain select * from test<span class="emphasis">_gap_</span>lock where id &gt; 100 for update;</span><br><span class="line"><span class="code">+----+</span>-------------<span class="code">+---------------+</span>-------<span class="code">+---------------+</span>---------<span class="code">+---------+</span>------<span class="code">+------+</span>-------------+</span><br><span class="line">| id | select<span class="emphasis">_type | table     | type  | possible_</span>keys | key   | key<span class="emphasis">_len | ref  | rows | Extra    |</span></span><br><span class="line"><span class="emphasis">+----+-------------+---------------+-------+---------------+---------+---------+------+------+-------------+</span></span><br><span class="line"><span class="emphasis">|  1 | SIMPLE    | test_</span>gap<span class="emphasis">_lock | range | PRIMARY    | PRIMARY | 4    | NULL |   2 | Using where |</span></span><br><span class="line"><span class="emphasis">+----+-------------+---------------+-------+---------------+---------+---------+------+------+-------------+</span></span><br><span class="line"><span class="emphasis">1 row in set (0.00 sec)</span></span><br><span class="line"><span class="emphasis">mysql&gt;  select * from test_</span>gap<span class="emphasis">_lock where id &gt; 100 for update;</span></span><br><span class="line"><span class="emphasis">+-----+-------+------+</span></span><br><span class="line"><span class="emphasis">| id  | name  | myid |</span></span><br><span class="line"><span class="emphasis">+-----+-------+------+</span></span><br><span class="line"><span class="emphasis">| 123 | test4 |  109 |</span></span><br><span class="line"><span class="emphasis">| 999 | test2 |  56 |</span></span><br><span class="line"><span class="emphasis">+-----+-------+------+</span></span><br><span class="line"><span class="emphasis">2 rows in set (0.00 sec)</span></span><br></pre></td></tr></table></figure><p>session 2(id=3可插入；id=108无法插入，存在gap lock；id=123的记录无法select..in share mode,因为该记录上存在record lock；id=125可以被select..in share mode和update,这点比较奇怪，应该这也算是当前读，不过后来查看官方文档得知，gap锁只会阻塞insert操作，因为gap间隙中是不存在任何记录的，除了insert操作，其他的操作结果应该都等价于空操作，mysql就不去阻塞它了)</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">insert</span> <span class="keyword">into</span> test_gap_lock <span class="keyword">values</span>(<span class="number">108</span>,<span class="string">'gap lock test3'</span>,<span class="number">123</span>);</span><br><span class="line">ERROR <span class="number">1205</span> (HY000): <span class="keyword">Lock</span> wait timeout exceeded; try restarting <span class="keyword">transaction</span></span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">insert</span> <span class="keyword">into</span> test_gap_lock <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">'gap lock test3'</span>,<span class="number">123</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="keyword">row</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> * <span class="keyword">from</span> test_gap_lock <span class="keyword">where</span> id=<span class="number">125</span> <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share mode</span>;</span><br><span class="line">Empty <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> test_gap_lock <span class="keyword">where</span> id=<span class="number">125</span> <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share mode</span>;</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+------+---------+------+------+-----------------------------------------------------+</span></span><br><span class="line">| id | select_type | <span class="keyword">table</span> | <span class="keyword">type</span> | possible_keys | key  | key_len | <span class="keyword">ref</span>  | <span class="keyword">rows</span> | Extra                        |</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+------+---------+------+------+-----------------------------------------------------+</span></span><br><span class="line">|  <span class="number">1</span> | SIMPLE    | <span class="keyword">NULL</span>  | <span class="keyword">NULL</span> | <span class="keyword">NULL</span>      | <span class="keyword">NULL</span> | <span class="keyword">NULL</span>   | <span class="keyword">NULL</span> | <span class="keyword">NULL</span> | Impossible <span class="keyword">WHERE</span> noticed <span class="keyword">after</span> reading const <span class="keyword">tables</span> |</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+------+---------+------+------+-----------------------------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">update</span> test_gap_lock <span class="keyword">set</span> myid=<span class="number">12345</span> <span class="keyword">where</span> id=<span class="number">125</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"><span class="keyword">Rows</span> matched: <span class="number">0</span>  Changed: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="gap-lock的内部加锁原理"><a href="#gap-lock的内部加锁原理" class="headerlink" title="gap lock的内部加锁原理"></a>gap lock的内部加锁原理</h3><h4 id="gap-lock的前置条件："><a href="#gap-lock的前置条件：" class="headerlink" title="gap lock的前置条件："></a>gap lock的前置条件：</h4><p>1.事务隔离级别为REPEATABLE-READ，innodb_locks_unsafe_for_binlog参数为0，且sql走的索引为非唯一索引</p><p>2.事务隔离级别为REPEATABLE-READ，innodb_locks_unsafe_for_binlog参数为0，且sql是一个范围的当前读操作，这时即使不是非唯一索引也会加gap lock</p><h4 id="gap-lock的加锁步骤"><a href="#gap-lock的加锁步骤" class="headerlink" title="gap lock的加锁步骤"></a>gap lock的加锁步骤</h4><p>针对上面的范例1（非唯一索引+范围当前读）和范例3（主键索引+范围当前读）比较好理解，那为什么范例2（非主键索引+等值当前读）为什么也会产生gap lock，这要从btree 索引的原理讲起，我们都知道，btree索引是按照顺序排列的，并且innodb存在主键聚集索引，本人绘图能力有限，已范例2的加锁过程分析举例，手写加锁过程如下图</p><p><img src="http://img.blog.csdn.net/20160127214258573?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img" title="null"></p><p>从图中的数据组织顺序可以看出，myid=100的记录有两条，如果加gap锁就会产生三个间隙，分别是gap1（98,100），gap2（100,100），gap3（100,105），在这三个开区间（如果我高中数学没记错的话）内的myid数值无法插入，显然gap1还有(myid=99，id=3)(myid</p><p>=99,id=4)等记录，gap2无实际的间隙，gap3还有（myid=101，id=7）等记录。并且，在myid=100的两条记录上加了record lock，也就是这两条数据业务无法被其他session进行当前读操作（范例三可以看出）</p><h1 id="Next-Key-Locks"><a href="#Next-Key-Locks" class="headerlink" title="Next-Key Locks"></a>Next-Key Locks</h1><p>在默认情况下，mysql的事务隔离级别是可重复读，并且innodb_locks_unsafe_for_binlog参数为0，这时默认采用next-key locks。所谓Next-Key Locks，就是Record lock和gap lock的结合，即除了锁住记录本身，还要再锁住索引之间的间隙。</p><p>下面我们针对大部分的SQL类型分析是如何加锁的，假设事务隔离级别为<strong>可重复读</strong>。</p><h2 id="select-from"><a href="#select-from" class="headerlink" title="select .. from"></a>select .. from</h2><p>不加任何类型的锁</p><h2 id="select…from-lock-in-share-mode"><a href="#select…from-lock-in-share-mode" class="headerlink" title="select…from lock in share mode"></a>select…from lock in share mode</h2><p>在扫描到的任何索引记录上加共享的（shared）next-key lock，还有主键聚集索引加排它锁 </p><h2 id="select-from-for-update"><a href="#select-from-for-update" class="headerlink" title="select..from for update"></a>select..from for update</h2><p>在扫描到的任何索引记录上加排它的next-key lock，还有主键聚集索引加排它锁 </p><h2 id="update-where-delete-from-where"><a href="#update-where-delete-from-where" class="headerlink" title="update..where  delete from..where"></a>update..where  delete from..where</h2><p>在扫描到的任何索引记录上加next-key lock，还有主键聚集索引加排它锁 </p><h2 id="insert-into"><a href="#insert-into" class="headerlink" title="insert into.."></a>insert into..</h2><p>简单的insert会在insert的行对应的索引记录上加一个排它锁，这是一个record lock，并没有gap，所以并不会阻塞其他session在gap间隙里插入记录。不过在insert操作之前，还会加一种锁，官方文档称它为insertion intention gap lock，也就是意向的gap锁。这个意向gap锁的作用就是预示着当多事务并发插入相同的gap空隙时，只要插入的记录不是gap间隙中的相同位置，则无需等待其他session就可完成，这样就使得insert操作无须加真正的gap lock。想象一下，如果一个表有一个索引idx_test，表中有记录1和8，那么每个事务都可以在2和7之间插入任何记录，只会对当前插入的记录加record lock，并不会阻塞其他session插入与自己不同的记录，因为他们并没有任何冲突。</p><p>假设发生了一个唯一键冲突错误，那么将会在重复的索引记录上加读锁。当有多个session同时插入相同的行记录时，如果另外一个session已经获得改行的排它锁，那么将会导致死锁。</p><h3 id="insert导致的死锁现象演示1"><a href="#insert导致的死锁现象演示1" class="headerlink" title="insert导致的死锁现象演示1"></a>insert导致的死锁现象演示1</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show create table t1\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">    Table: t1</span><br><span class="line">Create Table: CREATE TABLE `t1` (</span><br><span class="line"> `i` int(11) <span class="keyword">NOT</span> <span class="literal">NULL</span><span class="built_in"> DEFAULT </span><span class="string">'0'</span>,</span><br><span class="line"> PRIMARY KEY (`i`)</span><br><span class="line">) <span class="attribute">ENGINE</span>=InnoDB<span class="built_in"> DEFAULT </span><span class="attribute">CHARSET</span>=utf8</span><br><span class="line">1 row <span class="keyword">in</span> <span class="builtin-name">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure><p>session 1 </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line">mysql&gt; <span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 <span class="keyword">VALUES</span>(<span class="number">1</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="keyword">row</span> affected (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>session 2 这时session2一直被卡住</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line">mysql&gt; <span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 <span class="keyword">VALUES</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>session 3 这时session3也一直被卡住</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 <span class="keyword">VALUES</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>session 1 这时我们回滚session1</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; rollback;</span><br><span class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>发现session 2的insert成功，而session3检测到死锁回滚</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">session</span> <span class="number">2</span> Query OK, <span class="number">1</span> <span class="keyword">row</span> affected (<span class="number">28.87</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="keyword">session</span> <span class="number">3</span>  ERROR <span class="number">1213</span> (<span class="number">40001</span>): Deadlock <span class="built_in">found</span> <span class="keyword">when</span> trying <span class="keyword">to</span> <span class="keyword">get</span> <span class="keyword">lock</span>; try restarting <span class="keyword">transaction</span></span><br></pre></td></tr></table></figure><h3 id="死锁原因分析："><a href="#死锁原因分析：" class="headerlink" title="死锁原因分析："></a>死锁原因分析：</h3><p>首先session1插入一条记录，获得该记录的排它锁，这时session2和session3都检测到了主键冲突错误，但是由于session1并没有提交，所以session1并不算插入成功，于是它并不能直接报错吧，于是session2和session3都申请了该记录的共享锁，这时还没获取到共享锁，处于等待队列中。这时session1 rollback了，也就释放了该行记录的排它锁，那么session2和session3都获取了该行上的共享锁。而session2和session3想要插入记录，必须获取排它锁，但由于他们自己都拥有了共享锁，于是永远无法获取到排它锁，于是死锁就发生了。如果这时session1是commit而不是rollback的话，那么session2和session3都直接报错主键冲突错误。查看死锁日志也是一目了然</p><p><img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-09-%E7%90%86%E8%A7%A3innodb%E7%9A%84%E9%94%81-record-gap-next-key-lock/20160128143217677" alt="img" title="null"></p><h3 id="insert导致的死锁现象2"><a href="#insert导致的死锁现象2" class="headerlink" title="insert导致的死锁现象2"></a>insert导致的死锁现象2</h3><p>另外一个类似的死锁是session1删除了id=1的记录并未提交，这时session2和session3插入id=1的记录。这时session1 commit了，session2和session3需要insert的话，就需要获取排它锁，那么死锁也就发生了；session1 rollback，则session2和session3报错主键冲突。这里不再做演示。</p><h2 id="INSERT-…-ON-DUPLICATE-KEY-UPDATE"><a href="#INSERT-…-ON-DUPLICATE-KEY-UPDATE" class="headerlink" title="INSERT … ON DUPLICATE KEY UPDATE"></a>INSERT … ON DUPLICATE KEY UPDATE</h2><p>这种sql和insert加锁的不同的是，如果检测到键冲突，它直接申请加排它锁，而不是共享锁。</p><h2 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h2><p>replace操作如果没有检测到键冲突的话，那么它的加锁策略和insert相似；如果检测到键冲突，那么它也是直接再申请加排它锁</p><h2 id="INSERT-INTO-T-SELECT-…-FROM-S-WHERE-…"><a href="#INSERT-INTO-T-SELECT-…-FROM-S-WHERE-…" class="headerlink" title="INSERT INTO T SELECT … FROM S WHERE …"></a>INSERT INTO T SELECT … FROM S WHERE …</h2><p>在T表上的加锁策略和普通insert一致，另外还会在S表上的相关记录上加共享的next-key lock。（如果是可重复读模式，则不会加锁）</p><h2 id="CREATE-TABLE-…-SELECT-…"><a href="#CREATE-TABLE-…-SELECT-…" class="headerlink" title="CREATE TABLE … SELECT …"></a>CREATE TABLE … SELECT …</h2><p>在select的表上加共享的next-key lock</p><h2 id="自增id的加锁策略"><a href="#自增id的加锁策略" class="headerlink" title="自增id的加锁策略"></a>自增id的加锁策略</h2><p>当一张表的某个字段是自增列时，innodb会在该索引的末位加一个排它锁。为了访问这个自增的数值，需要加一个表级锁，不过这个表级锁的持续时间只有当前sql，而不是整个事务，即当前sql执行完，该表级锁就释放了。其他session无法在这个表级锁持有时插入任何记录。</p><h2 id="外键检测的加锁策略"><a href="#外键检测的加锁策略" class="headerlink" title="外键检测的加锁策略"></a>外键检测的加锁策略</h2><p>如果存在外键约束，任何的insert，update，delete将会检测约束条件，将会在相应的记录上加共享的record lock，无论是否存在外键冲突。</p><p><strong>注：转载自 博客园 crazyYong：<a href="https://www.cnblogs.com/crazylqy/p/7773492.html" target="_blank" rel="noopener">https://www.cnblogs.com/crazylqy/p/7773492.html</a></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Record-lock&quot;&gt;&lt;a href=&quot;#Record-lock&quot; class=&quot;headerlink&quot; title=&quot;Record lock&quot;&gt;&lt;/a&gt;Record lock&lt;/h1&gt;&lt;p&gt;单条索引记录上加锁，record lock锁住的永远是索引，而非记录
      
    
    </summary>
    
    
      <category term="MySQL" scheme="https://husky-wu.github.io/categories/MySQL/"/>
    
      <category term="锁" scheme="https://husky-wu.github.io/categories/MySQL/%E9%94%81/"/>
    
    
      <category term="MySQL" scheme="https://husky-wu.github.io/tags/MySQL/"/>
    
      <category term="锁" scheme="https://husky-wu.github.io/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>MySQL加锁过程详解-08-初步理解MySQL的gap锁</title>
    <link href="https://husky-wu.github.io/2021/01/04/MySQL/MySQL%E9%94%81%E8%AF%A6%E8%A7%A3/MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-08-%E5%88%9D%E6%AD%A5%E7%90%86%E8%A7%A3MySQL%E7%9A%84gap%E9%94%81/"/>
    <id>https://husky-wu.github.io/2021/01/04/MySQL/MySQL%E9%94%81%E8%AF%A6%E8%A7%A3/MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-08-%E5%88%9D%E6%AD%A5%E7%90%86%E8%A7%A3MySQL%E7%9A%84gap%E9%94%81/</id>
    <published>2021-01-04T05:59:47.000Z</published>
    <updated>2021-01-04T06:49:27.893Z</updated>
    
    <content type="html"><![CDATA[<h1 id="初步理解MySQL的gap锁"><a href="#初步理解MySQL的gap锁" class="headerlink" title="初步理解MySQL的gap锁"></a>初步理解MySQL的gap锁</h1><p>初识MySQL的gap，觉得这个设计比较独特，和其他数据库的做法不太一样，所以整理一个简单的memo（虽然关于gap锁，相关资料已经很多了）</p><h2 id="1-什么是gap"><a href="#1-什么是gap" class="headerlink" title="1. 什么是gap"></a>1. 什么是gap</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A place <span class="keyword">in</span> an InnoDB <span class="keyword">index</span> data structure <span class="keyword">where</span> <span class="built_in">new</span> <span class="keyword">values</span> could be inserted.</span><br></pre></td></tr></table></figure><p>说白了<strong>gap就是索引树中插入新记录的空隙</strong>。相应的gap lock就是加在gap上的锁，还有一个next-key锁，是记录+记录前面的gap的组合的锁。</p><h2 id="2-gap锁或next-key锁的作用"><a href="#2-gap锁或next-key锁的作用" class="headerlink" title="2. gap锁或next-key锁的作用"></a>2. gap锁或next-key锁的作用</h2><p><a href="http://dev.mysql.com/doc/refman/5.7/en/innodb-next-key-locking.html" target="_blank" rel="noopener">http://dev.mysql.com/doc/refman/5.7/en/innodb-next-key-locking.html</a></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">To</span> prevent phantoms, InnoDB uses an algorithm <span class="keyword">called</span> next-key locking that combines <span class="keyword">index</span>-<span class="keyword">row</span> </span><br><span class="line">locking <span class="keyword">with</span> gap locking. InnoDB performs <span class="keyword">row</span>-<span class="keyword">level</span> locking <span class="keyword">in</span> such a way that <span class="keyword">when</span> it searches</span><br><span class="line"> <span class="keyword">or</span> scans a <span class="keyword">table</span> <span class="keyword">index</span>, it sets shared <span class="keyword">or</span> <span class="keyword">exclusive</span> locks <span class="keyword">on</span> the <span class="keyword">index</span> records it encounters. </span><br><span class="line">Thus, the <span class="keyword">row</span>-<span class="keyword">level</span> locks are actually <span class="keyword">index</span>-<span class="type">record</span> locks. <span class="keyword">In</span> addition, a next-key <span class="keyword">lock</span> <span class="keyword">on</span> </span><br><span class="line">an <span class="keyword">index</span> <span class="type">record</span> <span class="keyword">also</span> affects the “gap” <span class="keyword">before</span> that <span class="keyword">index</span> <span class="type">record</span>. That <span class="keyword">is</span>, a next-key <span class="keyword">lock</span> <span class="keyword">is</span> </span><br><span class="line">an <span class="keyword">index</span>-<span class="type">record</span> <span class="keyword">lock</span> plus a gap <span class="keyword">lock</span> <span class="keyword">on</span> the gap <span class="keyword">preceding</span> the <span class="keyword">index</span> <span class="type">record</span>. <span class="keyword">If</span> one <span class="keyword">session</span> has </span><br><span class="line">a shared <span class="keyword">or</span> <span class="keyword">exclusive</span> <span class="keyword">lock</span> <span class="keyword">on</span> <span class="type">record</span> R <span class="keyword">in</span> an <span class="keyword">index</span>, another <span class="keyword">session</span> cannot <span class="keyword">insert</span> a <span class="built_in">new</span> <span class="keyword">index</span> </span><br><span class="line"><span class="type">record</span> <span class="keyword">in</span> the gap immediately <span class="keyword">before</span> R <span class="keyword">in</span> the <span class="keyword">index</span> <span class="keyword">order</span>.</span><br></pre></td></tr></table></figure><p>简单讲就是防止幻读。<strong>通过锁阻止特定条件的新记录的插入，因为插入时也要获取gap锁(Insert Intention Locks)。</strong></p><h2 id="3-什么时候会取得gap-lock或nextkey-lock"><a href="#3-什么时候会取得gap-lock或nextkey-lock" class="headerlink" title="3. 什么时候会取得gap lock或nextkey lock"></a>3. 什么时候会取得gap lock或nextkey lock</h2><p><strong>这和隔离级别有关,只在REPEATABLE READ或以上的隔离级别下的特定操作才会取得gap lock或nextkey lock。</strong></p><p><a href="http://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.html" target="_blank" rel="noopener">http://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.html</a></p><p><strong>2.1 REPEATABLE READ</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">... For consistent reads, there is an important difference from the READ COMMITTED isolation level:</span><br><span class="line"> All consistent reads within the same transaction read the snapshot established by the first read. ...</span><br><span class="line"></span><br><span class="line">For locking reads (<span class="keyword">SELECT</span> <span class="keyword">with</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> <span class="keyword">or</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>), <span class="keyword">UPDATE</span>, <span class="keyword">and</span> <span class="keyword">DELETE</span> statements, </span><br><span class="line">locking depends <span class="keyword">on</span> whether the <span class="keyword">statement</span> uses a <span class="keyword">unique</span> <span class="keyword">index</span> <span class="keyword">with</span> a <span class="keyword">unique</span> <span class="keyword">search</span> condition, </span><br><span class="line"><span class="keyword">or</span> a <span class="keyword">range</span>-<span class="keyword">type</span> <span class="keyword">search</span> condition. <span class="keyword">For</span> a <span class="keyword">unique</span> <span class="keyword">index</span> <span class="keyword">with</span> a <span class="keyword">unique</span> <span class="keyword">search</span> condition, </span><br><span class="line"><span class="keyword">InnoDB</span> locks <span class="keyword">only</span> the <span class="keyword">index</span> <span class="built_in">record</span> <span class="keyword">found</span>, <span class="keyword">not</span> the gap <span class="keyword">before</span> it. <span class="keyword">For</span> other <span class="keyword">search</span> conditions, </span><br><span class="line"><span class="keyword">InnoDB</span> locks the <span class="keyword">index</span> <span class="keyword">range</span> scanned, <span class="keyword">using</span> gap locks <span class="keyword">or</span> <span class="keyword">next</span>-<span class="keyword">key</span> locks <span class="keyword">to</span> <span class="keyword">block</span> insertions </span><br><span class="line"><span class="keyword">by</span> other sessions <span class="keyword">into</span> the gaps covered <span class="keyword">by</span> the range.</span><br></pre></td></tr></table></figure><p><strong>locking reads，UPDATE和DELETE时，除了对唯一索引的唯一搜索外都会获取gap锁或next-key锁。即锁住其扫描的范围。</strong></p><p>下面对<strong>非唯一索引</strong>做个测试。</p><p>表定义如下:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show create table tb2;</span><br><span class="line">+-------+------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| Table | Create Table                                                                                                                                   |</span><br><span class="line">+-------+------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| tb2   | CREATE TABLE `tb2` (</span><br><span class="line">  `id` int(11)<span class="built_in"> DEFAULT </span><span class="literal">NULL</span>,</span><br><span class="line">  `c1` int(11)<span class="built_in"> DEFAULT </span><span class="literal">NULL</span>,</span><br><span class="line">  KEY `tb2_idx1` (`id`)</span><br><span class="line">) <span class="attribute">ENGINE</span>=InnoDB<span class="built_in"> DEFAULT </span><span class="attribute">CHARSET</span>=utf8mb4 |</span><br><span class="line">+-------+------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">1 row <span class="keyword">in</span> <span class="builtin-name">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure><p>注意id只是索引，不是主键</p><p>表中有3条记录： 10,20,30。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from tb2;</span><br><span class="line"><span class="code">+------+</span>------+</span><br><span class="line">| id   | c1   |</span><br><span class="line"><span class="code">+------+</span>------+</span><br><span class="line">|   10 |    0 |</span><br><span class="line">|   20 |    0 |</span><br><span class="line">|   30 |    0 |</span><br><span class="line"><span class="code">+------+</span>------+</span><br><span class="line">3 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>在REPEATABLE READ下，更新一条记录不提交，然后看看能阻塞另外的会话哪些操作。</p><p><strong>SESSION 1:</strong></p><p>SESSION 1中更新id=20的记录</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; update tb2 <span class="keyword">set</span> c1=<span class="number">2</span> where id=<span class="number">20</span>;</span><br><span class="line">Query OK, <span class="number">1</span> row affected (<span class="number">0.04</span> sec)</span><br><span class="line">Rows matched: <span class="number">1</span>  Changed: <span class="number">1</span>  Warnings: <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>SESSION 2:</strong></p><p>SESSION 2中，执行插入操作，发现[10,30)范围不能插入数据。</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; insert into tb2 values(9,4);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into tb2 values(10,4);</span><br><span class="line"><span class="keyword">ERROR </span>1205 (HY000): Lock wait timeout exceeded; try restarting transaction</span><br><span class="line">mysql&gt; insert into tb2 values(19,4);</span><br><span class="line"><span class="keyword">ERROR </span>1205 (HY000): Lock wait timeout exceeded; try restarting transaction</span><br><span class="line">mysql&gt; insert into tb2 values(20,4);</span><br><span class="line"><span class="keyword">ERROR </span>1205 (HY000): Lock wait timeout exceeded; try restarting transaction</span><br><span class="line">mysql&gt; insert into tb2 values(21,4);</span><br><span class="line"><span class="keyword">ERROR </span>1205 (HY000): Lock wait timeout exceeded; try restarting transaction</span><br><span class="line">mysql&gt; insert into tb2 values(29,4);</span><br><span class="line"><span class="keyword">ERROR </span>1205 (HY000): Lock wait timeout exceeded; try restarting transaction</span><br><span class="line">mysql&gt; insert into tb2 values(30,4);</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">0.00</span> sec)</span><br><span class="line">mysql&gt; update tb2 <span class="keyword">set</span> c1=<span class="number">4</span> where id=<span class="number">10</span>;</span><br><span class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">0.00</span> sec)</span><br><span class="line">Rows matched: <span class="number">1</span>  Changed: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql&gt; update tb2 <span class="keyword">set</span> c1=<span class="number">4</span> where id=<span class="number">20</span>;</span><br><span class="line">ERROR <span class="number">1205</span> (HY000): Lock wait timeout exceeded; <span class="keyword">try</span> restarting transaction</span><br><span class="line">mysql&gt; update tb2 <span class="keyword">set</span> c1=<span class="number">4</span> where id=<span class="number">30</span>;</span><br><span class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">0.00</span> sec)</span><br><span class="line">Rows matched: <span class="number">2</span>  Changed: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br></pre></td></tr></table></figure><p>如果SESSION 1的表扫描没有用到索引，那么gap或next-key锁住的范围是整个表，即任何值都不能插入。</p><p><strong>2.2 READ COMMITTED</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">For locking reads (<span class="keyword">SELECT</span> <span class="keyword">with</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> <span class="keyword">or</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>), <span class="keyword">UPDATE</span> statements, </span><br><span class="line"><span class="keyword">and</span> <span class="keyword">DELETE</span> statements, <span class="keyword">InnoDB</span> locks <span class="keyword">only</span> <span class="keyword">index</span> <span class="keyword">records</span>, <span class="keyword">not</span> the gaps <span class="keyword">before</span> them,</span><br><span class="line"> <span class="keyword">and</span> thus permits the free insertion <span class="keyword">of</span> <span class="keyword">new</span> <span class="keyword">records</span> <span class="keyword">next</span> <span class="keyword">to</span> <span class="keyword">locked</span> records.</span><br></pre></td></tr></table></figure><p>只会锁住已有记录，不会加gap锁。</p><p><strong>2.3 SERIALIZABLE</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">This level is like REPEATABLE READ, but InnoDB implicitly converts all plain </span><br><span class="line"><span class="keyword">SELECT</span> statements <span class="keyword">to</span> <span class="keyword">SELECT</span> ... <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span> <span class="keyword">if</span> autocommit <span class="keyword">is</span> disabled.</span><br></pre></td></tr></table></figure><p>和REPEATABLE READ的主要区别在于把普通的SELECT变成SELECT … LOCK IN SHARE MODE，即对普通的select都会获取gap锁或next-key锁。</p><h2 id="4-REPEATABLE-READ和幻读"><a href="#4-REPEATABLE-READ和幻读" class="headerlink" title="4. REPEATABLE READ和幻读"></a>4. REPEATABLE READ和幻读</h2><p>在“consistent-read”时，REPEATABLE READ下看到是事务开始时的快照，即使其它事务插入了新行通常也是看不到的，所以在常见的场合可以避免幻读。 但是，”locking read”或更新，删除时是会看到已提交的修改的，包括新插入的行。</p><p><a href="http://dev.mysql.com/doc/refman/5.7/en/innodb-consistent-read.html" target="_blank" rel="noopener">http://dev.mysql.com/doc/refman/5.7/en/innodb-consistent-read.html</a></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">If you want <span class="built_in">to</span> see <span class="keyword">the</span> “freshest” state <span class="keyword">of</span> <span class="keyword">the</span> database, use either <span class="keyword">the</span> READ COMMITTED </span><br><span class="line">isolation level <span class="keyword">or</span> <span class="keyword">a</span> locking <span class="built_in">read</span>:</span><br></pre></td></tr></table></figure><p>下面看一个例子</p><p><strong>SESSION 1:</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; START TRANSACTION;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; select id,c1 from tb1 where id=1;</span><br><span class="line"><span class="code">+----+</span>------+</span><br><span class="line">| id | c1   |</span><br><span class="line"><span class="code">+----+</span>------+</span><br><span class="line">|  1 |  100 |</span><br><span class="line"><span class="code">+----+</span>------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p><strong>SESSION 2:</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update tb1 <span class="keyword">set</span> c1=<span class="number">101</span> where id =<span class="number">1</span>;</span><br><span class="line">Query OK, <span class="number">1</span> row affected (<span class="number">0.03</span> sec)</span><br><span class="line">Rows matched: <span class="number">1</span>  Changed: <span class="number">1</span>  Warnings: <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>SESSION 1:</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select id,c1 from tb1 where id=1 LOCK IN SHARE MODE;</span><br><span class="line"><span class="code">+----+</span>------+</span><br><span class="line">| id | c1   |</span><br><span class="line"><span class="code">+----+</span>------+</span><br><span class="line">|  1 |  101 |</span><br><span class="line"><span class="code">+----+</span>------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select id,c1 from tb1 where id=1;</span><br><span class="line"><span class="code">+----+</span>------+</span><br><span class="line">| id | c1   |</span><br><span class="line"><span class="code">+----+</span>------+</span><br><span class="line">|  1 |  100 |</span><br><span class="line"><span class="code">+----+</span>------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; update tb1 set c1=c1+1000 where id=1;</span><br><span class="line">Query OK, 1 row affected (0.02 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; select id,c1 from tb1 where id=1;</span><br><span class="line"><span class="code">+----+</span>------+</span><br><span class="line">| id | c1   |</span><br><span class="line"><span class="code">+----+</span>------+</span><br><span class="line">|  1 | 1101 |</span><br><span class="line"><span class="code">+----+</span>------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>上面update的行为违反了REPEATABLE READ的承诺，看到了事务开始后其它事务的并发更新。这对应用开发需要特别注意，这种情况下其它数据库通常都是报错的。</p><h2 id="5-其它"><a href="#5-其它" class="headerlink" title="5. 其它"></a>5. 其它</h2><p>RR和RC相比还有一个重要的区别，RC下，扫描过但不匹配的记录不会加锁，或者是先加锁再释放，即semi-consistent read。但RR下扫描过记录都要加锁。这个差别对有全表扫描的更新的场景影响极大。详细参考<a href="http://hedengcheng.com/?p=771，关于MySQL的加锁处理，这篇文章讲得很透彻！" target="_blank" rel="noopener">http://hedengcheng.com/?p=771，关于MySQL的加锁处理，这篇文章讲得很透彻！</a></p><h2 id="6-参考"><a href="#6-参考" class="headerlink" title="6. 参考"></a>6. 参考</h2><ul><li><a href="http://hedengcheng.com/?p=771" target="_blank" rel="noopener">http://hedengcheng.com/?p=771</a></li><li><a href="http://dev.mysql.com/doc/refman/5.7/en/innodb-consistent-read.html" target="_blank" rel="noopener">http://dev.mysql.com/doc/refman/5.7/en/innodb-consistent-read.html</a></li><li><a href="http://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.html" target="_blank" rel="noopener">http://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.html</a></li><li><a href="http://dev.mysql.com/doc/refman/5.7/en/innodb-next-key-locking.html" target="_blank" rel="noopener">http://dev.mysql.com/doc/refman/5.7/en/innodb-next-key-locking.html</a></li><li><a href="http://blog.chinaunix.net/uid-20726500-id-3902528.html" target="_blank" rel="noopener">http://blog.chinaunix.net/uid-20726500-id-3902528.html</a></li><li><a href="http://blog.itpub.net/22664653/viewspace-750824/" target="_blank" rel="noopener">http://blog.itpub.net/22664653/viewspace-750824/</a></li><li><a href="http://www.bitscn.com/pdb/mysql/201405/227973.html" target="_blank" rel="noopener">http://www.bitscn.com/pdb/mysql/201405/227973.html</a></li></ul><p><strong>注：转载自 博客园 crazyYong：<a href="https://www.cnblogs.com/crazylqy/p/7689447.html" target="_blank" rel="noopener">https://www.cnblogs.com/crazylqy/p/7689447.html</a></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;初步理解MySQL的gap锁&quot;&gt;&lt;a href=&quot;#初步理解MySQL的gap锁&quot; class=&quot;headerlink&quot; title=&quot;初步理解MySQL的gap锁&quot;&gt;&lt;/a&gt;初步理解MySQL的gap锁&lt;/h1&gt;&lt;p&gt;初识MySQL的gap，觉得这个设计比较独特
      
    
    </summary>
    
    
      <category term="MySQL" scheme="https://husky-wu.github.io/categories/MySQL/"/>
    
      <category term="锁" scheme="https://husky-wu.github.io/categories/MySQL/%E9%94%81/"/>
    
    
      <category term="MySQL" scheme="https://husky-wu.github.io/tags/MySQL/"/>
    
      <category term="锁" scheme="https://husky-wu.github.io/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>MySQL加锁过程详解-07-数据库隔离级别(2)-实际案例</title>
    <link href="https://husky-wu.github.io/2021/01/04/MySQL/MySQL%E9%94%81%E8%AF%A6%E8%A7%A3/MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-07-%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB-2-%E5%AE%9E%E9%99%85%E6%A1%88%E4%BE%8B/"/>
    <id>https://husky-wu.github.io/2021/01/04/MySQL/MySQL%E9%94%81%E8%AF%A6%E8%A7%A3/MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-07-%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB-2-%E5%AE%9E%E9%99%85%E6%A1%88%E4%BE%8B/</id>
    <published>2021-01-04T05:59:24.000Z</published>
    <updated>2021-01-04T06:46:58.946Z</updated>
    
    <content type="html"><![CDATA[<p>SQL标准定义了4种隔离级别，包括了一些具体规则，用来限定事务内外的哪些改变是可见的，哪些是不可见的。</p><p>低级别的隔离级一般支持更高的并发处理，并拥有更低的系统开销。</p><p>首先，我们使用 test 数据库，新建 tx 表，并且如图所示打开两个窗口来操作同一个数据库：</p><p><img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-07-%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB-2-%E5%AE%9E%E9%99%85%E6%A1%88%E4%BE%8B/821187-20160811160643512-422866874.png" alt="img" title="null"></p><hr><h3 id="第1级别：Read-Uncommitted-读取未提交内容"><a href="#第1级别：Read-Uncommitted-读取未提交内容" class="headerlink" title="第1级别：Read Uncommitted(读取未提交内容)"></a>第1级别：Read Uncommitted(读取未提交内容)</h3><p>(1)所有事务都可以看到其他未提交事务的执行结果<br>(2)本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少<br>(3)该级别引发的问题是——脏读(Dirty Read)：读取到了未提交的数据</p><p><a href="javascript:void(0);" target="_blank" rel="noopener"><img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-07-%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB-2-%E5%AE%9E%E9%99%85%E6%A1%88%E4%BE%8B/copycode.gif" alt="复制代码" title="null"></a></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#首先，修改隔离级别set tx<span class="emphasis">_isolation='READ-UNCOMMITTED';</span></span><br><span class="line"><span class="emphasis">select @@tx_</span>isolation;</span><br><span class="line"><span class="code">+------------------+</span></span><br><span class="line">| @@tx<span class="emphasis">_isolation   |</span></span><br><span class="line"><span class="emphasis">+------------------+</span></span><br><span class="line"><span class="emphasis">| READ-UNCOMMITTED |</span></span><br><span class="line"><span class="emphasis">+------------------+</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">#事务A：启动一个事务</span></span><br><span class="line"><span class="emphasis">start transaction;</span></span><br><span class="line"><span class="emphasis">select * from tx;</span></span><br><span class="line"><span class="emphasis">+------+------+</span></span><br><span class="line"><span class="emphasis">| id   | num  |</span></span><br><span class="line"><span class="emphasis">+------+------+</span></span><br><span class="line"><span class="emphasis">|    1 |    1 |</span></span><br><span class="line"><span class="emphasis">|    2 |    2 |</span></span><br><span class="line"><span class="emphasis">|    3 |    3 |</span></span><br><span class="line"><span class="emphasis">+------+------+</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">#事务B：也启动一个事务(那么两个事务交叉了)       在事务B中执行更新语句，且不提交</span></span><br><span class="line"><span class="emphasis">start transaction;</span></span><br><span class="line"><span class="emphasis">update tx set num=10 where id=1;</span></span><br><span class="line"><span class="emphasis">select * from tx;</span></span><br><span class="line"><span class="emphasis">+------+------+</span></span><br><span class="line"><span class="emphasis">| id   | num  |</span></span><br><span class="line"><span class="emphasis">+------+------+</span></span><br><span class="line"><span class="emphasis">|    1 |   10 |</span></span><br><span class="line"><span class="emphasis">|    2 |    2 |</span></span><br><span class="line"><span class="emphasis">|    3 |    3 |</span></span><br><span class="line"><span class="emphasis">+------+------+</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">#事务A：那么这时候事务A能看到这个更新了的数据吗?</span></span><br><span class="line"><span class="emphasis">select * from tx;</span></span><br><span class="line"><span class="emphasis">+------+------+</span></span><br><span class="line"><span class="emphasis">| id   | num  |</span></span><br><span class="line"><span class="emphasis">+------+------+</span></span><br><span class="line"><span class="emphasis">|    1 |   10 |   ---&gt;可以看到！说明我们读到了事务B还没有提交的数据</span></span><br><span class="line"><span class="emphasis">|    2 |    2 |</span></span><br><span class="line"><span class="emphasis">|    3 |    3 |</span></span><br><span class="line"><span class="emphasis">+------+------+</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">#事务B：事务B回滚,仍然未提交</span></span><br><span class="line"><span class="emphasis">rollback;</span></span><br><span class="line"><span class="emphasis">select * from tx;</span></span><br><span class="line"><span class="emphasis">+------+------+</span></span><br><span class="line"><span class="emphasis">| id   | num  |</span></span><br><span class="line"><span class="emphasis">+------+------+</span></span><br><span class="line"><span class="emphasis">|    1 |    1 |</span></span><br><span class="line"><span class="emphasis">|    2 |    2 |</span></span><br><span class="line"><span class="emphasis">|    3 |    3 |</span></span><br><span class="line"><span class="emphasis">+------+------+</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">#事务A：在事务A里面看到的也是B没有提交的数据</span></span><br><span class="line"><span class="emphasis">select * from tx;</span></span><br><span class="line"><span class="emphasis">+------+------+</span></span><br><span class="line"><span class="emphasis">| id   | num  |</span></span><br><span class="line"><span class="emphasis">+------+------+</span></span><br><span class="line"><span class="emphasis">|    1 |    1 |      ---&gt;脏读意味着我在这个事务中(A中)，事务B虽然没有提交，但它任何一条数据变化，我都可以看到！</span></span><br><span class="line"><span class="emphasis">|    2 |    2 |</span></span><br><span class="line"><span class="emphasis">|    3 |    3 |</span></span><br><span class="line"><span class="emphasis">+------+------+</span></span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);" target="_blank" rel="noopener"><img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-07-%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB-2-%E5%AE%9E%E9%99%85%E6%A1%88%E4%BE%8B/copycode.gif" alt="复制代码" title="null"></a></p><hr><h3 id="第2级别：Read-Committed-读取提交内容"><a href="#第2级别：Read-Committed-读取提交内容" class="headerlink" title="第2级别：Read Committed(读取提交内容)"></a><strong>第2级别：Read Committed(读取提交内容)</strong></h3><p>(1)这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）<br>(2)它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变<br>(3)这种隔离级别出现的问题是——不可重复读(Nonrepeatable Read)：不可重复读意味着我们在同一个事务中执行完全相同的select语句时可能看到不一样的结果。<br>   |——&gt;导致这种情况的原因可能有：(1)有一个交叉的事务有新的commit，导致了数据的改变;(2)一个数据库被多个实例操作时,同一事务的其他实例在该实例处理其间可能会有新的commit</p><p><a href="javascript:void(0);" target="_blank" rel="noopener"><img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-07-%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB-2-%E5%AE%9E%E9%99%85%E6%A1%88%E4%BE%8B/copycode.gif" alt="复制代码" title="null"></a></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#首先修改隔离级别set tx<span class="emphasis">_isolation='read-committed';</span></span><br><span class="line"><span class="emphasis">select @@tx_</span>isolation;</span><br><span class="line"><span class="code">+----------------+</span></span><br><span class="line">| @@tx<span class="emphasis">_isolation |</span></span><br><span class="line"><span class="emphasis">+----------------+</span></span><br><span class="line"><span class="emphasis">| READ-COMMITTED |</span></span><br><span class="line"><span class="emphasis">+----------------+</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">#事务A：启动一个事务</span></span><br><span class="line"><span class="emphasis">start transaction;</span></span><br><span class="line"><span class="emphasis">select * from tx;</span></span><br><span class="line"><span class="emphasis">+------+------+</span></span><br><span class="line"><span class="emphasis">| id   | num  |</span></span><br><span class="line"><span class="emphasis">+------+------+</span></span><br><span class="line"><span class="emphasis">|    1 |    1 |</span></span><br><span class="line"><span class="emphasis">|    2 |    2 |</span></span><br><span class="line"><span class="emphasis">|    3 |    3 |</span></span><br><span class="line"><span class="emphasis">+------+------+</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">#事务B：也启动一个事务(那么两个事务交叉了)       在这事务中更新数据，且未提交</span></span><br><span class="line"><span class="emphasis">start transaction;</span></span><br><span class="line"><span class="emphasis">update tx set num=10 where id=1;</span></span><br><span class="line"><span class="emphasis">select * from tx;</span></span><br><span class="line"><span class="emphasis">+------+------+</span></span><br><span class="line"><span class="emphasis">| id   | num  |</span></span><br><span class="line"><span class="emphasis">+------+------+</span></span><br><span class="line"><span class="emphasis">|    1 |   10 |</span></span><br><span class="line"><span class="emphasis">|    2 |    2 |</span></span><br><span class="line"><span class="emphasis">|    3 |    3 |</span></span><br><span class="line"><span class="emphasis">+------+------+</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">#事务A：这个时候我们在事务A中能看到数据的变化吗?</span></span><br><span class="line"><span class="emphasis">select * from tx; ---------------&gt;</span></span><br><span class="line"><span class="emphasis">+------+------+                |</span></span><br><span class="line"><span class="emphasis">| id   | num  |                |</span></span><br><span class="line"><span class="emphasis">+------+------+                |</span></span><br><span class="line"><span class="emphasis">|    1 |    1 |---&gt;并不能看到！  |</span></span><br><span class="line"><span class="emphasis">|    2 |    2 |                |</span></span><br><span class="line"><span class="emphasis">|    3 |    3 |                |</span></span><br><span class="line"><span class="emphasis">+------+------+                |——&gt;相同的select语句，结果却不一样</span></span><br><span class="line"><span class="emphasis">                               |</span></span><br><span class="line"><span class="emphasis">#事务B：如果提交了事务B呢?         |</span></span><br><span class="line"><span class="emphasis">commit;                        |</span></span><br><span class="line"><span class="emphasis">                               |</span></span><br><span class="line"><span class="emphasis">#事务A:                         |</span></span><br><span class="line"><span class="emphasis">select * from tx; ---------------&gt;</span></span><br><span class="line"><span class="emphasis">+------+------+</span></span><br><span class="line"><span class="emphasis">| id   | num  |</span></span><br><span class="line"><span class="emphasis">+------+------+</span></span><br><span class="line"><span class="emphasis">|    1 |   10 |---&gt;因为事务B已经提交了，所以在A中我们看到了数据变化</span></span><br><span class="line"><span class="emphasis">|    2 |    2 |</span></span><br><span class="line"><span class="emphasis">|    3 |    3 |</span></span><br><span class="line"><span class="emphasis">+------+------+</span></span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);" target="_blank" rel="noopener"><img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-07-%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB-2-%E5%AE%9E%E9%99%85%E6%A1%88%E4%BE%8B/copycode.gif" alt="复制代码" title="null"></a></p><hr><h3 id="第3级别：Repeatable-Read-可重读"><a href="#第3级别：Repeatable-Read-可重读" class="headerlink" title="第3级别：Repeatable Read(可重读)"></a>第3级别：Repeatable Read(可重读)</h3><p>(1)这是MySQL的默认事务隔离级别<br>(2)它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行<br>(3)此级别可能出现的问题——幻读(Phantom Read)：当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行<br>(4)InnoDB和Falcon存储引擎通过多版本并发控制(MVCC，Multiversion Concurrency Control)机制解决了幻读</p><p><a href="javascript:void(0);" target="_blank" rel="noopener"><img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-07-%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB-2-%E5%AE%9E%E9%99%85%E6%A1%88%E4%BE%8B/copycode.gif" alt="复制代码" title="null"></a></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#首先，更改隔离级别set tx<span class="emphasis">_isolation='repeatable-read';</span></span><br><span class="line"><span class="emphasis">select @@tx_</span>isolation;</span><br><span class="line"><span class="code">+-----------------+</span></span><br><span class="line">| @@tx<span class="emphasis">_isolation  |</span></span><br><span class="line"><span class="emphasis">+-----------------+</span></span><br><span class="line"><span class="emphasis">| REPEATABLE-READ |</span></span><br><span class="line"><span class="emphasis">+-----------------+</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">#事务A：启动一个事务</span></span><br><span class="line"><span class="emphasis">start transaction;</span></span><br><span class="line"><span class="emphasis">select * from tx;</span></span><br><span class="line"><span class="emphasis">+------+------+</span></span><br><span class="line"><span class="emphasis">| id   | num  |</span></span><br><span class="line"><span class="emphasis">+------+------+</span></span><br><span class="line"><span class="emphasis">|    1 |    1 |</span></span><br><span class="line"><span class="emphasis">|    2 |    2 |</span></span><br><span class="line"><span class="emphasis">|    3 |    3 |</span></span><br><span class="line"><span class="emphasis">+------+------+</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">#事务B：开启一个新事务(那么这两个事务交叉了)       在事务B中更新数据，并提交</span></span><br><span class="line"><span class="emphasis">start transaction;</span></span><br><span class="line"><span class="emphasis">update tx set num=10 where id=1;</span></span><br><span class="line"><span class="emphasis">select * from tx;</span></span><br><span class="line"><span class="emphasis">+------+------+</span></span><br><span class="line"><span class="emphasis">| id   | num  |</span></span><br><span class="line"><span class="emphasis">+------+------+</span></span><br><span class="line"><span class="emphasis">|    1 |   10 |</span></span><br><span class="line"><span class="emphasis">|    2 |    2 |</span></span><br><span class="line"><span class="emphasis">|    3 |    3 |</span></span><br><span class="line"><span class="emphasis">+------+------+</span></span><br><span class="line"><span class="emphasis">commit;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">#事务A：这时候即使事务B已经提交了,但A能不能看到数据变化？</span></span><br><span class="line"><span class="emphasis">select * from tx;</span></span><br><span class="line"><span class="emphasis">+------+------+</span></span><br><span class="line"><span class="emphasis">| id   | num  |</span></span><br><span class="line"><span class="emphasis">+------+------+</span></span><br><span class="line"><span class="emphasis">|    1 |    1 | ---&gt;还是看不到的！(这个级别2不一样，也说明级别3解决了不可重复读问题)</span></span><br><span class="line"><span class="emphasis">|    2 |    2 |</span></span><br><span class="line"><span class="emphasis">|    3 |    3 |</span></span><br><span class="line"><span class="emphasis">+------+------+</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">#事务A：只有当事务A也提交了，它才能够看到数据变化</span></span><br><span class="line"><span class="emphasis">commit;</span></span><br><span class="line"><span class="emphasis">select * from tx;</span></span><br><span class="line"><span class="emphasis">+------+------+</span></span><br><span class="line"><span class="emphasis">| id   | num  |</span></span><br><span class="line"><span class="emphasis">+------+------+</span></span><br><span class="line"><span class="emphasis">|    1 |   10 |</span></span><br><span class="line"><span class="emphasis">|    2 |    2 |</span></span><br><span class="line"><span class="emphasis">|    3 |    3 |</span></span><br><span class="line"><span class="emphasis">+------+------+</span></span><br></pre></td></tr></table></figure><hr><h3 id="第4级别：Serializable-可串行化"><a href="#第4级别：Serializable-可串行化" class="headerlink" title="第4级别：Serializable(可串行化)"></a>第4级别：Serializable(可串行化)</h3><p>(1)这是最高的隔离级别<br>(2)它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之,它是在每个读的数据行上加上共享锁。<br>(3)在这个级别，可能导致大量的超时现象和锁竞争</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#首先修改隔离界别set tx_isolation='serializable';</span></span><br><span class="line"><span class="keyword">select</span> @@tx_isolation;</span><br><span class="line">+<span class="comment">----------------+</span></span><br><span class="line">| @@tx_isolation |</span><br><span class="line">+<span class="comment">----------------+</span></span><br><span class="line">| SERIALIZABLE   |</span><br><span class="line">+<span class="comment">----------------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#事务A：开启一个新事务</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#事务B：在A没有commit之前，这个交叉事务是不能更改数据的</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"><span class="keyword">insert</span> tx <span class="keyword">values</span>(<span class="string">'4'</span>,<span class="string">'4'</span>);</span><br><span class="line">ERROR 1205 (HY000): <span class="keyword">Lock</span> <span class="keyword">wait</span> <span class="keyword">timeout</span> exceeded; try restarting transaction</span><br><span class="line"><span class="keyword">update</span> tx <span class="keyword">set</span> <span class="keyword">num</span>=<span class="number">10</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span>;</span><br><span class="line">ERROR 1205 (HY000): <span class="keyword">Lock</span> <span class="keyword">wait</span> <span class="keyword">timeout</span> exceeded; try restarting transaction</span><br></pre></td></tr></table></figure><hr><p>​      <img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-07-%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB-2-%E5%AE%9E%E9%99%85%E6%A1%88%E4%BE%8B/821187-20160811171241606-133220585.jpg" alt="img" title="null"></p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a><strong>参考文章</strong></h3><p>​      <a href="http://xm-king.iteye.com/blog/770721" target="_blank" rel="noopener">Mysql事务隔离级别详解</a></p><p><a href="http://www.cnblogs.com/snsdzjlz320/p/5761387.html" target="_blank" rel="noopener">http://www.cnblogs.com/snsdzjlz320/p/5761387.html</a></p><p>在MYSQL的事务引擎中，INNODB是使用范围最广的。它默认的事务隔离级别是REPEATABLE READ(可重复读），在标准的事务隔离级别定义下，REPEATABLE READ是不能防止幻读产生的。INNODB使用了2种技术手段（MVCC AND GAP LOCK)实现了防止幻读的发生。</p><p>以上的iso定义的数据库隔离级别，mysql实现了基本定义，但和他有点不一样，比如mysql重复读避免的幻读</p><p><strong>注：转载自 博客园 crazyYong：<a href="https://www.cnblogs.com/crazylqy/p/7516066.html" target="_blank" rel="noopener">https://www.cnblogs.com/crazylqy/p/7516066.html</a></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SQL标准定义了4种隔离级别，包括了一些具体规则，用来限定事务内外的哪些改变是可见的，哪些是不可见的。&lt;/p&gt;
&lt;p&gt;低级别的隔离级一般支持更高的并发处理，并拥有更低的系统开销。&lt;/p&gt;
&lt;p&gt;首先，我们使用 test 数据库，新建 tx 表，并且如图所示打开两个窗口来操作
      
    
    </summary>
    
    
      <category term="MySQL" scheme="https://husky-wu.github.io/categories/MySQL/"/>
    
      <category term="锁" scheme="https://husky-wu.github.io/categories/MySQL/%E9%94%81/"/>
    
    
      <category term="MySQL" scheme="https://husky-wu.github.io/tags/MySQL/"/>
    
      <category term="锁" scheme="https://husky-wu.github.io/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>MySQL加锁过程详解-06-数据库隔离级别(1)</title>
    <link href="https://husky-wu.github.io/2021/01/04/MySQL/MySQL%E9%94%81%E8%AF%A6%E8%A7%A3/MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-06-%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB-1/"/>
    <id>https://husky-wu.github.io/2021/01/04/MySQL/MySQL%E9%94%81%E8%AF%A6%E8%A7%A3/MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-06-%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB-1/</id>
    <published>2021-01-04T05:58:47.000Z</published>
    <updated>2021-01-04T06:59:53.005Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、数据库事务隔离级别"><a href="#一、数据库事务隔离级别" class="headerlink" title="一、数据库事务隔离级别"></a>一、数据库事务隔离级别</h2><p>数据库事务的隔离级别有4个，由低到高依次为Read uncommitted 、Read committed 、Repeatable read 、Serializable ，这四个级别可以逐个解决脏读 、不可重复读 、幻读 这几类问题。</p><p>√: 可能出现  ×: 不会出现</p><table><thead><tr><th></th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>Read uncommitted</td><td>√</td><td>√</td><td>√</td></tr><tr><td>Read committed</td><td>×</td><td>√</td><td>√</td></tr><tr><td>Repeatable read</td><td>×</td><td>×</td><td>√</td></tr><tr><td>Serializable</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><p>注意：我们讨论隔离级别的场景，主要是在多个事务并发 的情况下，因此，接下来的讲解都围绕事务并发。</p><h5 id="Read-uncommitted-读未提交"><a href="#Read-uncommitted-读未提交" class="headerlink" title="Read uncommitted 读未提交"></a>Read uncommitted 读未提交</h5><p>公司发工资了，领导把5000元打到singo的账号上，但是该事务并未提交，而singo正好去查看账户，发现工资已经到账，是5000元整，非常高 兴。可是不幸的是，领导发现发给singo的工资金额不对，是2000元，于是迅速回滚了事务，修改金额后，将事务提交，最后singo实际的工资只有 2000元，singo空欢喜一场。</p><p><img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-06-%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB-1/f244ae46-c8f4-3bc1-906e-d1d9c1af3516.gif" alt="img" title="null"></p><p>出现上述情况，即我们所说的脏读 ，两个并发的事务，“事务A：领导给singo发工资”、“事务B：singo查询工资账户”，事务B读取了事务A尚未提交的数据。</p><p>当隔离级别设置为Read uncommitted 时，就可能出现脏读，如何避免脏读，请看下一个隔离级别。</p><h5 id="Read-committed-读提交"><a href="#Read-committed-读提交" class="headerlink" title="Read committed 读提交"></a>Read committed 读提交</h5><p>singo拿着工资卡去消费，系统读取到卡里确实有2000元，而此时她的老婆也正好在网上转账，把singo工资卡的2000元转到另一账户，并在 singo之前提交了事务，当singo扣款时，系统检查到singo的工资卡已经没有钱，扣款失败，singo十分纳闷，明明卡里有钱，为 何……</p><p>出现上述情况，即我们所说的不可重复读 ，两个并发的事务，“事务A：singo消费”、“事务B：singo的老婆网上转账”，事务A事先读取了数据，事务B紧接了更新了数据，并提交了事务，而事务A再次读取该数据时，数据已经发生了改变。</p><p>当隔离级别设置为Read committed 时，避免了脏读，但是可能会造成不可重复读。</p><p>大多数数据库的默认级别就是Read committed，比如Sql Server , Oracle。如何解决不可重复读这一问题，请看下一个隔离级别。</p><h5 id="Repeatable-read-重复读（这是MySQL的默认事务隔离级别）"><a href="#Repeatable-read-重复读（这是MySQL的默认事务隔离级别）" class="headerlink" title="Repeatable read 重复读（这是MySQL的默认事务隔离级别）"></a>Repeatable read 重复读（这是MySQL的默认事务隔离级别）</h5><p>当隔离级别设置为Repeatable read 时，可以避免不可重复读。当singo拿着工资卡去消费时，一旦系统开始读取工资卡信息（即事务开始），singo的老婆就不可能对该记录进行修改，也就是singo的老婆不能在此时转账。</p><p>虽然Repeatable read避免了不可重复读，但还有可能出现幻读 。</p><p>singo的老婆工作在银行部门，她时常通过银行内部系统查看singo的信用卡消费记录。有一天，她正在查询到singo当月信用卡的总消费金额 （select sum(amount) from transaction where month = 本月）为80元，而singo此时正好在外面胡吃海塞后在收银台买单，消费1000元，即新增了一条1000元的消费记录（insert transaction … ），并提交了事务，随后singo的老婆将singo当月信用卡消费的明细打印到A4纸上，却发现消费总额为1080元，singo的老婆很诧异，以为出 现了幻觉，幻读就这样产生了。</p><p>注：Mysql的默认隔离级别就是Repeatable read。</p><h5 id="Serializable-序列化"><a href="#Serializable-序列化" class="headerlink" title="Serializable 序列化"></a>Serializable 序列化</h5><p>Serializable 是最高的事务隔离级别，同时代价也花费最高，性能很低，一般很少使用，在该级别下，事务顺序执行，不仅可以避免脏读、不可重复读，还避免了幻像读。</p><h2 id="二、脏读、幻读、不可重复读"><a href="#二、脏读、幻读、不可重复读" class="headerlink" title="二、脏读、幻读、不可重复读"></a>二、脏读、幻读、不可重复读</h2><p><strong>1.脏读：</strong><br>脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。</p><p><strong>2.不可重复读：</strong><br>是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。（即不能读到相同的数据内容）<br>例如，一个编辑人员两次读取同一文档，但在两次读取之间，作者重写了该文档。当编辑人员第二次读取文档时，文档已更改。原始读取不可重复。如果只有在作者全部完成编写后编辑人员才可以读取文档，则可以避免该问题。</p><p><strong>3.幻读:</strong><br>是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象<br>发生了幻觉一样。<br>例如，一个编辑人员更改作者提交的文档，但当生产部门将其更改内容合并到该文档的主复本时，发现作者已将未编辑的新材料添加到该文档中。如果在编辑人员和生产部门完成对原始文档的处理之前，任何人都不能将新材料添加到文档中，则可以避免该问题。</p><p>在MYSQL的事务引擎中，INNODB是使用范围最广的。它默认的事务隔离级别是REPEATABLE READ(可重复读），在标准的事务隔离级别定义下，REPEATABLE READ是不能防止幻读产生的。INNODB使用了2种技术手段（MVCC AND GAP LOCK)实现了防止幻读的发生。</p><p>以上的iso定义的数据库隔离级别，mysql实现了基本定义，但和他有点不一样，比如mysql重复读避免的幻读</p><p><strong>注：转载自 博客园 crazyYong：<a href="https://www.cnblogs.com/crazylqy/p/7515020.html" target="_blank" rel="noopener">https://www.cnblogs.com/crazylqy/p/7515020.html</a></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、数据库事务隔离级别&quot;&gt;&lt;a href=&quot;#一、数据库事务隔离级别&quot; class=&quot;headerlink&quot; title=&quot;一、数据库事务隔离级别&quot;&gt;&lt;/a&gt;一、数据库事务隔离级别&lt;/h2&gt;&lt;p&gt;数据库事务的隔离级别有4个，由低到高依次为Read uncommit
      
    
    </summary>
    
    
      <category term="MySQL" scheme="https://husky-wu.github.io/categories/MySQL/"/>
    
      <category term="锁" scheme="https://husky-wu.github.io/categories/MySQL/%E9%94%81/"/>
    
    
      <category term="MySQL" scheme="https://husky-wu.github.io/tags/MySQL/"/>
    
      <category term="锁" scheme="https://husky-wu.github.io/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>MySQL加锁过程详解-05-innodb多版本并发控制原理详解</title>
    <link href="https://husky-wu.github.io/2021/01/04/MySQL/MySQL%E9%94%81%E8%AF%A6%E8%A7%A3/MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-05-innodb%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
    <id>https://husky-wu.github.io/2021/01/04/MySQL/MySQL%E9%94%81%E8%AF%A6%E8%A7%A3/MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-05-innodb%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/</id>
    <published>2021-01-04T05:58:19.000Z</published>
    <updated>2021-01-04T06:44:05.900Z</updated>
    
    <content type="html"><![CDATA[<p>多版本并发控制技术已经被广泛运用于各大数据库系统中,如Oracle，MS SQL Server 2005+, Postgresql, Firebird, Maria等等,开源数据库MYSQL中流行的INNODB引擎也采用了类似的并发控制技术.本文就将结合实例来解析不同事务隔离等级下INNODB的MVCC实现原理.</p><p><strong>1 MVCC概述</strong></p><p><strong>1.1 MVCC简介</strong></p><p>MVCC (Multiversion Concurrency Control),即多版本并发控制技术,它使得大部分支持行锁的事务引擎,不再单纯的使用行锁来进行数据库的并发控制,取而代之的是,把数据库的行锁与行的多个版本结合起来,只需要很小的开销,就可以实现非锁定读,从而大大提高数据库系统的并发性能.</p><p><strong>1.2 实现原理</strong></p><p>MVCC可以提供基于某个时间点的快照,使得对于事务看来,总是可以提供与事务开始时刻相一致的数据,而不管这个事务执行的时间有多长.所以在不同的事务看来,同一时刻看到的相同行的数据可能是不一样的,即一个行可能有多个版本.是否听起来不可思议呢?</p><p>原来,为了实现mvcc, innodb对每一行都加上了两个隐含的列,其中一列存储行被更新的”时间”,另外一列存储行被删除的”时间”. 但是innodb存储的并不是绝对的时间,而是与时间对应的数据库系统的版本号,每当一个事务开始的时候,innodb都会给这个事务分配一个递增的版本号,所以版本号也可以被认为是事务号.对于每一个”查询”语句,innodb都会把这个查询语句的版本号同这个查询语句遇到的行的版本号进行对比,然后结合不同的事务隔离等级,来决定是否返回该行.</p><p>下面分别以select、delete、 insert、 update语句来说明:</p><p>1) SELECT</p><p>对于select语句，只有同时满足了下面两个条件的行，才能被返回:</p><p>•行的被修改版本号小于或者等于该事务号</p><p>•行的被删除版本号要么没有被定义,要么大于事务的版本号:行的删除版本号如果没有被定义,说明该行没有被删除过;如果删除版本号大于当前事务的事务号,说明该行是被该事务后面启动的事务删除的,由于是repeatable read隔离等级,后开始的事务对数据的影响不应该被先开始的事务看见,所以该行应该被返回.</p><p>2) INSERT</p><p>对新插入的行,行的更新版本被修改为该事务的事务号</p><p>3) DELETE</p><p>对于删除,innodb直接把该行的被删除版本号设置为当前的事务号,相当于标记为删除,而不是实际删除</p><p>4) UPDATE</p><p>在更新行的时候,innodb会把原来的行复制一份到回滚段中,并把当前的事务号作为该行的更新版本</p><p><strong>1.3 MVCC的优缺点</strong></p><p>上述策略的结果就是,在读取数据的时候,innodb几乎不用获得任何锁, 每个查询都通过版本检查,只获得自己需要的数据版本,从而大大提高了系统的并发度.</p><p>这种策略的缺点是,为了实现多版本,innodb必须对每行增加相应的字段来存储版本信息,同时需要维护每一行的版本信息,而且在检索行的时候,需要进行版本的比较,因而降低了查询的效率;innodb还必须定期清理不再需要的行版本,及时回收空间,这也增加了一些开销</p><p><strong>2 INNODB支持的事务隔离等级</strong></p><p>INNODB支持并实现了ISO标准的4个事务隔离等级,即 READ-UNCOMMITTED, READ-COMMITTED, REPEATABLE-READ, SERIALIZABLE.</p><p>1) READ UNCOMMITTED (可以读未提交的): 查询可以读取到其他事务正在修改的数据,即使其他事务的修改还没有提交.这种隔离等级无法避免脏读.</p><p>2) READ COMMITTED(只可以读已经提交的):其他事务对数据库的修改,只要已经提交,其修改的结果就是可见的,与这两个事务开始的先后顺序无关.这种隔离等级避免了脏读,但是无法实现可重复读,甚至有可能产生幻读.</p><p>3) REPEATABLE READ(可重复读):比read committed更进了一步,它只能读取在它开始之前已经提交的事务对数据库的修改,在它开始以后,所有其他事务对数据库的修改对它来说均不可见.从而实现了可重复读,但是仍有可能幻读</p><p>4) SERIALIZABLE(可串行化):这是事务隔离等级的最高级别.其实现原理就是对于所有的query,即使是查询,也会加上读锁,避免其他事务对数据的修改.所以它成功的避免了幻读.但是代价是,数据库系统的并发处理能力大大降低,所以它不会被用到生产系统中.</p><p>我们对MVCC和标准事务隔离等级有所了解以后,再结合实例来看看其具体表现吧.</p><p><strong>3</strong> 不同事务隔离等级下的MVCC实现</p><p>MVCC由于其实现原理,只支持read committed和repeatable read隔离等级,下面分别举例详细说明:</p><p>每次开始之前,都先执行如下的语句:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span> mydb;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> mydb;</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="string">`emp`</span> ( <span class="string">`empno`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="literal">null</span> auto_increment, <span class="string">`ename`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">default</span> <span class="literal">null</span>, Primary <span class="keyword">key</span> (empno)) <span class="keyword">engine</span>=<span class="keyword">innodb</span> <span class="keyword">default</span> <span class="keyword">charset</span>=gbk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp <span class="keyword">values</span>(<span class="number">100</span>, <span class="string">"yuxiangang"</span>) ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp <span class="keyword">values</span>(<span class="number">200</span>,<span class="string">"2zhaoyinggang"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp <span class="keyword">values</span>(<span class="number">300</span>,<span class="string">"3yihongbin"</span>);</span><br></pre></td></tr></table></figure><p><strong>3.1 read committed隔离等级</strong></p><p>说明:session 1和session 2表示访问同一个数据库的两个不同的会话.行号用来代表不同的语句执行的时间点.</p><table><thead><tr><th>行号</th><th>session 1</th><th>session 2</th></tr></thead><tbody><tr><td>1</td><td>set transaction isolation level read committed;</td><td></td></tr><tr><td>2</td><td>start transaction;</td><td></td></tr><tr><td>3</td><td>select * from emp where empno&gt;=100; 查询的结果为:+——-+——-+| empno | ename |+——-+——-+|  100 | 1yuxiangang ||  200 | 2zhaoyinggang ||  300 | 3yihongbin |+——-+——-+</td><td></td></tr><tr><td>4</td><td></td><td>set transaction isolation level read committed;</td></tr><tr><td>5</td><td></td><td>start transaction;</td></tr><tr><td>6</td><td></td><td>update emp set ename=1 where empno=100; delete from emp where empno=200;</td></tr><tr><td>说明: 修改一行,然后删除一行,但是事务不提交.</td><td></td><td></td></tr><tr><td>7</td><td>select * from emp where empno&gt;=100; 查询的结果为:+——-+——-+| empno | ename |+——-+——-+|  100 | 1yuxiangang ||  200 | 2zhaoyinggang ||  300 | 3yihongbin |+——-+——-+</td><td></td></tr><tr><td>说明:会话2的事务没有提交,所以会话1看不到会话2的事务对数据库数据的修改.但是实际上修改已经发生,会话1获取的被修改或者删除的数据,都来自于回滚段.这是通过MVCC来实现的.</td><td></td><td></td></tr><tr><td>8</td><td></td><td>commit;</td></tr><tr><td>说明: 会话2提交</td><td></td><td></td></tr><tr><td>9</td><td>select * from emp where empno&gt;=100; 查询的结果为:+——-+——-+| empno | ename |+——-+——-+|  100 | 1   ||  300 | 3yihongbin |+——-+——-+</td><td></td></tr><tr><td>说明:当事务2提交以后,由于会话1采用的是read committed隔离等级,所以会话2的提交马上会被会话1的事务看见.对于会话1来说,第一次执行select * from emp where empno&gt;=100;与第二次执行该语句,两次看到的结果不一样,第一次读看到了3行,第二次只看到了2行,就像发生了幻觉,称之为幻读;第一次看到100对应的ename为1yuxiangang,第二次看到的100对应的是1,两次获取的数据内容不一样,称之为不可重复读.</td><td></td><td></td></tr></tbody></table><p>3.2 <strong>repeatable read隔离等级</strong></p><p>注意:先执行开头的所有sql语句.</p><table><thead><tr><th>行号</th><th>session 1</th><th>session 2</th><th>session 3</th><th>session 4</th></tr></thead><tbody><tr><td>1</td><td>set transaction isolation level repeatable read;</td><td></td><td></td><td></td></tr><tr><td>2</td><td>start transaction;</td><td></td><td></td><td></td></tr><tr><td>3</td><td>select * from emp where empno&gt;=100; 查询的结果为:+——-+——-+| empno | ename |+——-+——-+|  100 | 1yuxiangang ||  200 | 2zhaoyinggang ||  300 | 3yihongbin |+——-+——-+</td><td></td><td></td><td></td></tr><tr><td>4</td><td></td><td></td><td></td><td>set @@session.autocommit=1;</td></tr><tr><td>说明: 这里让会话4可以自动提交,便于观察它对前面3个会话的影响</td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td>update emp set ename=1 where empno=100; insert into emp values(400,”4chj”);</td></tr><tr><td>说明: 会话4先更新一行数据,然后插入一行数据,并自动提交</td><td></td><td></td><td></td><td></td></tr><tr><td>5</td><td>select * from emp where empno&gt;=100; 查询的结果为: +——-+——-+| empno | ename |+——-+——-+|  100 | 1yuxiangang ||  200 | 2zhaoyinggang ||  300 | 3yihongbin |+——-+——-+</td><td></td><td></td><td></td></tr><tr><td>说明: 会话1执行查询,两次查询得到的结果一样.它看不到会话4对数据库的修改,虽然会话4的事务已经提交.这是因为会话4的事务是在会话1的事务之后才开始.从这里也可以看出,repeatable read实现了可重复读</td><td></td><td></td><td></td><td></td></tr><tr><td>6</td><td></td><td>set transaction isolation level repeatable read;start transaction;</td><td></td><td></td></tr><tr><td>7</td><td></td><td>select * from emp where empno&gt;=100; 查询的结果为:+——-+——-+| empno | ename |+——-+——-+|  100 | 1   ||  200 | 2zhaoyinggang ||  300 | 3yihongbin ||  400 | 4chj |+——-+——-+</td><td></td><td></td></tr><tr><td>说明: 会话2是在会话4之后开始的,所以它看到了会话4对数据库的修改.同时可以看到,相同的查询语句,不同的事务来执行的时候,得到的结果不一样.会话2与会话3执行相同的查询就得到不一样的结果.</td><td></td><td></td><td></td><td></td></tr><tr><td>8</td><td></td><td></td><td></td><td>update emp set ename=2 where empno=200;</td></tr><tr><td>9</td><td></td><td></td><td>set transaction isolation level repeatable read;start transaction;</td><td></td></tr><tr><td>10</td><td></td><td></td><td>select * from emp where empno&gt;=100;查询的结果为: +——-+——-+| empno | ename |+——-+——-+|  100 | 1   ||  200 | 2   ||  300 | 3yihongbin ||  400 | 4chj |+——-+——-+</td><td></td></tr><tr><td>说明: 同样,这个会话查询到的结果与会话1和会话2的结果也不一样.而且会话3看到了会话4对数据库的修改.</td><td></td><td></td><td></td><td></td></tr><tr><td>11</td><td></td><td></td><td></td><td>update emp set ename=4 where empno=400;</td></tr><tr><td>12</td><td></td><td></td><td></td><td>select * from emp where empno&gt;=100; 查询的结果为:+——-+——-+| empno | ename |+——-+——-+|  100 | 1   ||  200 | 2   ||  300 | 3yihongbin ||  400 | 4   |+——-+——-+</td></tr><tr><td>说明: 事务总是可以看到自身对数据库数据的修改,尽管别的事务可能看不到这种修改</td><td></td><td></td><td></td><td></td></tr><tr><td>13</td><td>select * from emp where empno&gt;=100; 查询的结果为:+——-+——-+| empno | ename |+——-+——-+|  100 | 1yuxiangang ||  200 | 2zhaoyinggang ||  300 | 3yihongbin |+——-+——-+</td><td>select * from emp where empno&gt;=100; 查询的结果为:+——-+——-+| empno | ename |+——-+——-+|  100 | 1   ||  200 | 2zhaoyinggang ||  300 | 3yihongbin ||  400 | 4chj |+——-+——-+</td><td>select * from emp where empno&gt;=100; 查询的结果为:+——-+——-+| empno | ename |+——-+——-+|  100 | 1   ||  200 | 2   ||  300 | 3yihongbin ||  400 | 4chj |+——-+——-+</td><td>select * from emp where empno&gt;=100; 查询的结果为:+——-+——-+| empno | ename |+——-+——-+|  100 | 1   ||  200 | 2   ||  300 | 3yihongbin ||  400 | 4   |+——-+——-+</td></tr><tr><td>说明: 从上面的结果可以很清晰的看到:会话1,2,3,4执行相同的语句,即使是在同一时刻,他们看到的数据都可能不一样:对于empno为100的行,有 100 1yuxiangang 和 100  1两个版本;对于empno为200的行,有 200  2zhaoyinggang 和200  2两个版本…,而每一行数据都可能存在多个版本,那么这些行组合起来得到的结果集的版本就更是不计其数,这就是数据库多版本的由来.MVCC就是通过事务发生的不同的时间点,与数据行的版本来进行对比,从而取回与事务开始的时间点相一致的数据,<strong>来实现非阻塞的一致读.</strong></td><td></td><td></td><td></td><td></td></tr><tr><td>14</td><td>commit;</td><td>commit;</td><td>commit;</td><td>commit;</td></tr><tr><td>15</td><td>select * from emp where empno&gt;=100; 查询的结果为:+——-+——-+| empno | ename |+——-+——-+|  100 | 1   ||  200 | 2   ||  300 | 3yihongbin ||  400 | 4   |+——-+——-+</td><td>select * from emp where empno&gt;=100; 查询的结果为:+——-+——-+| empno | ename |+——-+——-+|  100 | 1   ||  200 | 2   ||  300 | 3yihongbin ||  400 | 4   |+——-+——-+</td><td>select * from emp where empno&gt;=100; 查询的结果为:+——-+——-+| empno | ename |+——-+——-+|  100 | 1   ||  200 | 2   ||  300 | 3yihongbin ||  400 | 4   |+——-+——-+</td><td>select * from emp where empno&gt;=100; 查询的结果为:+——-+——-+| empno | ename |+——-+——-+|  100 | 1   ||  200 | 2   ||  300 | 3yihongbin ||  400 | 4   |+——-+——-+</td></tr><tr><td>说明: 当所有事务都提交后,他们看到的结果都是一样的</td><td></td><td></td><td></td><td></td></tr></tbody></table><p>4 相关的Q&amp;A</p><p><strong>4.1 为什么select count(*)在myisam表上很快,而在Innodb的表上很慢?</strong></p><p>因为innodb采用了MVCC技术,对于相同的行,可能同时存在多个版本,innodb必须根据查询的时间来过滤掉一些行,才能得出结果,必然要执行全表扫描,而全表扫描是非常耗时的.对于myisam的表,任何行都只有一个版本,mysql甚至不需要扫描就可以直接返回精确的统计结果,我们用explain也可以看到,对于myisam的表,执行select count(*)的时候,mysql显示” Select tables optimized away”,查询直接被优化了;而对于innodb的表,可能是全表扫描,也可能是”using index”,总之,速度肯定会比myisam的表慢很多.</p><p><strong>4.2 我的数据库只是频繁更新,没有插入新数据,但是为什么表空间占用会越来越大?</strong></p><p>如果你在数据库中执行了大事务, innodb就会把被修改数据的前映像存放到称为回滚段的公共表空间中,而且对于索引和表中的行的多个版本,如果innodb来不及purge,或者这些行因为要提供一致读而不能被purge,就会占用越来越多的空间,甚至有可能短时间撑爆你的硬盘.所以应用程序中需要合理控制事务的大小.</p><p><strong>4.3 能禁用MVCC吗?</strong></p><p>禁用MVCC可以降低innodb引擎的开销,而同时innodb又可以支持外键约束,可以实现自动恢复.MVCC本身不支持read uncommitted等级,所以可以通过设置transaction_isolation = read uncommitted 来禁用MVCC.但是任何改变innodb默认隔离等级的操作,都会起到innodb_locks_unsafe_for_binlog=off类似的效果,这会导致诸如insert into t select * from t_src 之类的语句不再给源表t_src加锁,也不再使用innodb的间隙锁,从而产生幻读,直接导致binlog中记录的sql语句不能正确的串行化,从而主从数据库的数据不再一致,而且基于binlog的增量备份也不再有效.所以除非不需要记录binlog,否则别这么做.当然我们可以这样做来优化从库的性能,因为从库不需要记录binlog.</p><p><strong>4.4 何时使用char类型,何时使用varchar类型的列?</strong></p><p>在使用myisam引擎的情况下,定长表虽然可能占用较多的存储空间,但是它会加快检索和全表扫描的速度,此时适合选用char的列,而对于表中的变长的列,可以采用分表的方法把变长的列拆分出去,提高定长表的检索性能.而如果使用的是innodb的引擎,由于innodb的mvcc策略的实施,char数据类型相对于varchar类型几乎没有任何优势,反而varchar列可能节省更多的存储空间,建议使用varchar数据类型.</p><p><strong>注：转载自 博客园 crazyYong：<a href="https://www.cnblogs.com/crazylqy/p/7610831.html" target="_blank" rel="noopener">https://www.cnblogs.com/crazylqy/p/7610831.html</a></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;多版本并发控制技术已经被广泛运用于各大数据库系统中,如Oracle，MS SQL Server 2005+, Postgresql, Firebird, Maria等等,开源数据库MYSQL中流行的INNODB引擎也采用了类似的并发控制技术.本文就将结合实例来解析不同事务隔
      
    
    </summary>
    
    
      <category term="MySQL" scheme="https://husky-wu.github.io/categories/MySQL/"/>
    
      <category term="锁" scheme="https://husky-wu.github.io/categories/MySQL/%E9%94%81/"/>
    
    
      <category term="MySQL" scheme="https://husky-wu.github.io/tags/MySQL/"/>
    
      <category term="锁" scheme="https://husky-wu.github.io/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>MySQL加锁过程详解-04-selectforupdate共享读锁对事务并发影响</title>
    <link href="https://husky-wu.github.io/2021/01/04/MySQL/MySQL%E9%94%81%E8%AF%A6%E8%A7%A3/MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-04-selectforupdate%E5%85%B1%E4%BA%AB%E8%AF%BB%E9%94%81%E5%AF%B9%E4%BA%8B%E5%8A%A1%E5%B9%B6%E5%8F%91%E5%BD%B1%E5%93%8D/"/>
    <id>https://husky-wu.github.io/2021/01/04/MySQL/MySQL%E9%94%81%E8%AF%A6%E8%A7%A3/MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-04-selectforupdate%E5%85%B1%E4%BA%AB%E8%AF%BB%E9%94%81%E5%AF%B9%E4%BA%8B%E5%8A%A1%E5%B9%B6%E5%8F%91%E5%BD%B1%E5%93%8D/</id>
    <published>2021-01-04T05:57:58.000Z</published>
    <updated>2021-01-04T06:38:53.915Z</updated>
    
    <content type="html"><![CDATA[<h2 id="select-for-update-lock-in-share-mode-对事务并发性影响"><a href="#select-for-update-lock-in-share-mode-对事务并发性影响" class="headerlink" title="select for update/lock in share mode 对事务并发性影响"></a>select for update/lock in share mode 对事务并发性影响</h2><h3 id="事务并发性理解"><a href="#事务并发性理解" class="headerlink" title="事务并发性理解"></a>事务并发性理解</h3><p>事务并发性，粗略的理解就是单位时间内能够执行的事务数量，常见的单位是 TPS（ transactions per second）.</p><p>那在数据量和业务操作量一定的情况下，常见的提高事务并发性主要考虑的有哪几点呢？</p><p><strong>1.提高服务器的处理能力，让事务的处理时间变短。</strong></p><p>这样不仅加快了这个事务的执行时间，也降低了其他等待该事务执行的事务执行时间。</p><p><strong>2.尽量将事务涉及到的 sql 操作语句控制在合理范围，换句话说就是不要让一个事务包含的操作太多或者太少。</strong></p><p>在业务繁忙情况下，如果单个事务操作的表或者行数据太多，其他的事务可能都在等待该事务 commit或者 rollback，这样会导致整体上的 TPS 降低。但是，如果每个 sql 语句都是一个事务也是不太现实的。一来，有些业务本身需要多个sql语句来构成一个事务（比如汇款这种多个表的操作）；二来，每个 sql 都需要commit，如果在 mysql 里 innodb_flush_log_at_trx_commit=1 的情况下，会导致 redo log 的刷新过于频繁，也不利于整体事务数量的提高（IO限制也是需要考虑的重要因素）。</p><p><strong>3.在操作的时候，尽量控制锁的粒度，能用小的锁粒度就尽量用锁的粒度，用完锁资源后要记得立即释放，避免后面的事务等待。</strong></p><p><strong>但是有些情况下，</strong>由于业务需要，或者为了保证数据的一致性的时候，必须要增加锁的粒度，这个时候就是下面所说的几种情况。</p><h3 id="select-for-update-理解"><a href="#select-for-update-理解" class="headerlink" title="select for update 理解"></a>select for update 理解</h3><p>select col from t where where_clause for update 的目的是在执行这个 select 查询语句的时候，会将对应的索引访问条目进行上排他锁（X 锁），也就是说这个语句对应的锁就相当于update带来的效果。</p><p>那这种语法为什么会存在呢？肯定是有需要这种方式的存在啦！！请看下面的案例描述：</p><p><strong>案例1：</strong></p><p>前提条件：</p><p>mysql 隔离级别 <strong>repeatable-read</strong> ,</p><p>事务1：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">建表：</span><br><span class="line">CREATE TABLE `lockt` (</span><br><span class="line">  `id` int(11) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  `col1` int(11)<span class="built_in"> DEFAULT </span><span class="literal">NULL</span>,</span><br><span class="line">  `col2` int(11)<span class="built_in"> DEFAULT </span><span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `col1_ind` (`col1`),</span><br><span class="line">  KEY `col2_ind` (`col2`)</span><br><span class="line">) <span class="attribute">ENGINE</span>=InnoDB<span class="built_in"> DEFAULT </span><span class="attribute">CHARSET</span>=utf8</span><br><span class="line"></span><br><span class="line">插入数据 。。。。。</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="builtin-name">set</span> <span class="attribute">autocommit</span>=0;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * <span class="keyword">from</span> lockt;</span><br><span class="line">+----+------+------+</span><br><span class="line">| id | col1 | col2 |</span><br><span class="line">+----+------+------+</span><br><span class="line">|  1 |    1 |    1 |</span><br><span class="line">|  2 |    2 |    3 |</span><br><span class="line">|  5 |    5 |    5 |</span><br><span class="line">|  6 |    6 |    9 |</span><br><span class="line">|  7 |    7 |   14 |</span><br><span class="line">|  8 |    8 |   20 |</span><br><span class="line">+----+------+------+</span><br><span class="line">6 rows <span class="keyword">in</span> <span class="builtin-name">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure><p>然后另外一个事务2 进行了下面的操作：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * <span class="keyword">from</span> lockt;</span><br><span class="line">+----+------+------+</span><br><span class="line">| id | col1 | col2 |</span><br><span class="line">+----+------+------+</span><br><span class="line">|  <span class="number">1</span> |    <span class="number">1</span> |    <span class="number">1</span> |</span><br><span class="line">|  <span class="number">2</span> |    <span class="number">2</span> |    <span class="number">3</span> |</span><br><span class="line">|  <span class="number">5</span> |    <span class="number">5</span> |    <span class="number">5</span> |</span><br><span class="line">|  <span class="number">6</span> |    <span class="number">6</span> |    <span class="number">9</span> |</span><br><span class="line">|  <span class="number">7</span> |    <span class="number">7</span> |   <span class="number">14</span> |</span><br><span class="line">|  <span class="number">8</span> |    <span class="number">8</span> |   <span class="number">20</span> |</span><br><span class="line">+----+------+------+</span><br><span class="line"><span class="number">6</span> rows <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; update lockt <span class="keyword">set</span>  col2= <span class="number">144</span>  where col2=<span class="number">14</span>;  </span><br><span class="line">Query OK, <span class="number">1</span> row affected (<span class="number">0.01</span> sec)</span><br><span class="line">Rows matched: <span class="number">1</span>  Changed: <span class="number">1</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql&gt; commit;</span><br><span class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p><strong>结果：</strong>可以看到事务2 将col2=14 的列改为了 col2=144.</p><p>可是事务1继续执行的时候根本没有觉察到 lockt 发生了变化，请看 事务1 继续后面的操作：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from lockt;</span><br><span class="line"><span class="code">+----+</span>------<span class="code">+------+</span></span><br><span class="line">| id | col1 | col2 |</span><br><span class="line"><span class="code">+----+</span>------<span class="code">+------+</span></span><br><span class="line">|  1 |    1 |    1 |</span><br><span class="line">|  2 |    2 |    3 |</span><br><span class="line">|  5 |    5 |    5 |</span><br><span class="line">|  6 |    6 |    9 |</span><br><span class="line">|  7 |    7 |   14 |</span><br><span class="line">|  8 |    8 |   20 |</span><br><span class="line"><span class="code">+----+</span>------<span class="code">+------+</span></span><br><span class="line">6 rows in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; update lockt set  col2=col2*2  where col2=14;    </span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">Rows matched: 0  Changed: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; commit;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from lockt;</span><br><span class="line"><span class="code">+----+</span>------<span class="code">+------+</span></span><br><span class="line">| id | col1 | col2 |</span><br><span class="line"><span class="code">+----+</span>------<span class="code">+------+</span></span><br><span class="line">|  1 |    1 |    1 |</span><br><span class="line">|  2 |    2 |    3 |</span><br><span class="line">|  5 |    5 |    5 |</span><br><span class="line">|  6 |    6 |    9 |</span><br><span class="line">|  7 |    7 |  144 |</span><br><span class="line">|  8 |    8 |   20 |</span><br><span class="line"><span class="code">+----+</span>------<span class="code">+------+</span></span><br><span class="line">6 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p><strong>结果：</strong> 事务1 明明查看到的存在 col2=12 的行数据，可是 update 后，竟然不仅没有改为他想要的col2=28 的值，反而变成了 col2=144 ！！！！</p><p>这在有些业务情况下是不允许的，因为有些业务希望我通过 <strong>select * from lockt;</strong> 查询到的数据是此时数据库里面真正存储的最新数据，并且不允许其他的事务来修改只允许我来修改。（<strong>这个要求很霸气，但是我喜欢。。</strong>）</p><p>这种情况就是很牛逼的情况了。具体的细节请参考下面的<strong>案例2：</strong></p><p>案例2：</p><p>mysql 条件和案例1 一样。</p><p><strong>事务1操作:</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from lockt where col2=20 for update;</span><br><span class="line"><span class="code">+----+</span>------<span class="code">+------+</span></span><br><span class="line">| id | col1 | col2 |</span><br><span class="line"><span class="code">+----+</span>------<span class="code">+------+</span></span><br><span class="line">|  8 |    8 |   20 |</span><br><span class="line"><span class="code">+----+</span>------<span class="code">+------+</span></span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p><strong>事务2 操作：</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from lockt;</span><br><span class="line"><span class="code">+----+</span>------<span class="code">+------+</span></span><br><span class="line">| id | col1 | col2 |</span><br><span class="line"><span class="code">+----+</span>------<span class="code">+------+</span></span><br><span class="line">|  1 |    1 |    1 |</span><br><span class="line">|  2 |    2 |    3 |</span><br><span class="line">|  5 |    5 |    5 |</span><br><span class="line">|  6 |    6 |    9 |</span><br><span class="line">|  7 |    7 |  144 |</span><br><span class="line">|  8 |    8 |   20 |</span><br><span class="line"><span class="code">+----+</span>------<span class="code">+------+</span></span><br><span class="line">6 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; update lockt set  col2=222  where col2=20;</span><br></pre></td></tr></table></figure><p>注意： 事务2 在执行 update lockt set col2=222 where col2=20; 的时候，会发现 sql 语句被 block住了，为什么会发现这种情况呢？</p><p>因为事务1 的 select * from lockt where col2=20 for update; 语句会将 col2=20 这个索引的入口给锁住了，（其实有些时候是范围的索引条目也被锁住了，暂时不讨论。），那么事务2虽然看到了所有的数据，但是想去修改 col2=20 的行数据的时候， 事务1 只能说 “不可能也不允许”。</p><p>后面只有事务1 commit或者rollback 以后，事务2 的才能够修改 col2=20 的这个行数据。</p><p><strong>总结：</strong></p><p>这就是 select for update 的使用场景，为了避免自己看到的数据并不是数据库存储的最新数据并且看到的数据只能由自己修改，需要用 for update 来限制。</p><h3 id="select-lock-in-share-mode-理解"><a href="#select-lock-in-share-mode-理解" class="headerlink" title="select lock in share mode 理解"></a>select lock in share mode 理解</h3><p>如果看了前面的 select *** for update ，就可以很好的理解 select lock in share mode ，in share mode 子句的作用就是将查找到的数据加上一个 share 锁，这个就是表示其他的事务只能对这些数据进行简单的select 操作，并不能够进行 DML 操作。</p><p>那它和 for update 在引用场景上究竟有什么实质上的区别呢？</p><p>lock in share mode 没有 for update 那么霸道，所以它有时候也会遇到问题，请看案例3</p><p>案例3：</p><p>mysql 环境和案例1 类似</p><p>事务1：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from lockt;</span><br><span class="line"><span class="code">+----+</span>------<span class="code">+------+</span></span><br><span class="line">| id | col1 | col2 |</span><br><span class="line"><span class="code">+----+</span>------<span class="code">+------+</span></span><br><span class="line">|  1 |    1 |    1 |</span><br><span class="line">|  2 |    2 |    3 |</span><br><span class="line">|  5 |    5 |    5 |</span><br><span class="line">|  6 |    6 |    9 |</span><br><span class="line">|  7 |    7 |  144 |</span><br><span class="line">|  8 |    8 |   20 |</span><br><span class="line"><span class="code">+----+</span>------<span class="code">+------+</span></span><br><span class="line">6 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from lockt where col2=20 lock in share mode;</span><br><span class="line"><span class="code">+----+</span>------<span class="code">+------+</span></span><br><span class="line">| id | col1 | col2 |</span><br><span class="line"><span class="code">+----+</span>------<span class="code">+------+</span></span><br><span class="line">|  8 |    8 |   20 |</span><br><span class="line"><span class="code">+----+</span>------<span class="code">+------+</span></span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>事务2 接着开始操作</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from lockt;</span><br><span class="line"><span class="code">+----+</span>------<span class="code">+------+</span></span><br><span class="line">| id | col1 | col2 |</span><br><span class="line"><span class="code">+----+</span>------<span class="code">+------+</span></span><br><span class="line">|  1 |    1 |    1 |</span><br><span class="line">|  2 |    2 |    3 |</span><br><span class="line">|  5 |    5 |    5 |</span><br><span class="line">|  6 |    6 |    9 |</span><br><span class="line">|  7 |    7 |  144 |</span><br><span class="line">|  8 |    8 |   20 |</span><br><span class="line"><span class="code">+----+</span>------<span class="code">+------+</span></span><br><span class="line">6 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from lockt where col2=20 lock in share mode;</span><br><span class="line"><span class="code">+----+</span>------<span class="code">+------+</span></span><br><span class="line">| id | col1 | col2 |</span><br><span class="line"><span class="code">+----+</span>------<span class="code">+------+</span></span><br><span class="line">|  8 |    8 |   20 |</span><br><span class="line"><span class="code">+----+</span>------<span class="code">+------+</span></span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>后面的比较蛋疼的一幕出现了，当 事务1 想更新 col2=20 的时候，他发现 block 住了。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update lockt <span class="builtin-name">set</span> <span class="attribute">col2</span>=22 where <span class="attribute">col2</span>=20;</span><br></pre></td></tr></table></figure><p>解释：因为事务1 和事务2 都对该行上了一个 share 锁，事务1 以为就只有自己一个人上了 S 锁，所以当事务一想修改的时候发现没法修改，这种情况下，事务1 需要使用 for update 子句来进行约束了，而不是使用 for share 来使用。</p><p><strong>意向锁作用</strong></p><p>下文之知乎大神观点：<a href="https://www.zhihu.com/question/51513268" target="_blank" rel="noopener">https://www.zhihu.com/question/51513268</a> </p><p><a href="javascript:void(0);" target="_blank" rel="noopener"><img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-04-selectforupdate%E5%85%B1%E4%BA%AB%E8%AF%BB%E9%94%81%E5%AF%B9%E4%BA%8B%E5%8A%A1%E5%B9%B6%E5%8F%91%E5%BD%B1%E5%93%8D/copycode.gif" alt="复制代码" title="null"></a></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">innodb的意向锁有什么作用？</span><br><span class="line">mysql官网上对于意向锁的解释中有这么一句话</span><br><span class="line">“The main purpose <span class="keyword">of</span> IX <span class="keyword">and</span> <span class="keyword">IS</span> locks <span class="keyword">is</span> <span class="keyword">to</span> <span class="keyword">show</span> that someone <span class="keyword">is</span> locking a <span class="keyword">row</span>, <span class="keyword">or</span> going <span class="keyword">to</span> <span class="keyword">lock</span> a <span class="keyword">row</span> <span class="keyword">in</span> the <span class="keyword">table</span>.”</span><br><span class="line">意思是说加意向锁的目的是为了表明某个事务正在锁定一行或者将要锁定一行。</span><br><span class="line">那么，意向锁的作用就是“表明”加锁的意图，可是为什么要表明这个 意图呢？</span><br><span class="line">如果仅仅锁定一行仅仅需要加一个锁，那么就直接加锁就好了，这里要表明加锁意图的原因是因为要锁定一行不仅仅是要加一个锁，而是要做一系列操作吗？</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">作者：尹发条地精</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">我最近也在看这个，我说一下我的理解</span><br><span class="line">①在mysql中有表锁，<span class="keyword">LOCK</span> <span class="keyword">TABLE</span> my_tabl_name <span class="keyword">READ</span>;  用读锁锁表，会阻塞其他事务修改表数据。<span class="keyword">LOCK</span> <span class="keyword">TABLE</span> my_table_name <span class="keyword">WRITe</span>; 用写锁锁表，会阻塞其他事务读和写。</span><br><span class="line">②Innodb引擎又支持行锁，行锁分为共享锁，一个事务对一行的共享只读锁。排它锁，一个事务对一行的排他读写锁。</span><br><span class="line">③这两中类型的锁共存的问题考虑这个例子：</span><br><span class="line">事务A锁住了表中的一行，让这一行只能读，不能写。之后，事务B申请整个表的写锁。如果事务B申请成功，那么理论上它就能修改表中的任意一行，这与A持有的行锁是冲突的。</span><br><span class="line">数据库需要避免这种冲突，就是说要让B的申请被阻塞，直到A释放了行锁。</span><br><span class="line"></span><br><span class="line">数据库要怎么判断这个冲突呢？</span><br><span class="line">step1：判断表是否已被其他事务用表锁锁表</span><br><span class="line">step2：判断表中的每一行是否已被行锁锁住。</span><br><span class="line">注意step2，这样的判断方法效率实在不高，因为需要遍历整个表。</span><br><span class="line">于是就有了意向锁。在意向锁存在的情况下，事务A必须先申请表的意向共享锁，成功后再申请一行的行锁。在意向锁存在的情况下，</span><br><span class="line">上面的判断可以改成</span><br><span class="line">step1：不变</span><br><span class="line">step2：发现表上有意向共享锁，说明表中有些行被共享行锁锁住了，因此，事务B申请表的写锁会被阻塞。</span><br><span class="line"></span><br><span class="line">注意：申请意向锁的动作是数据库完成的，就是说，事务A申请一行的行锁的时候，数据库会自动先开始申请表的意向锁，不需要我们程序员使用代码来申请。</span><br><span class="line"></span><br><span class="line">总结：为了实现多粒度锁机制（白话：为了表锁和行锁都能用）</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);" target="_blank" rel="noopener"><img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-04-selectforupdate%E5%85%B1%E4%BA%AB%E8%AF%BB%E9%94%81%E5%AF%B9%E4%BA%8B%E5%8A%A1%E5%B9%B6%E5%8F%91%E5%BD%B1%E5%93%8D/copycode.gif" alt="复制代码" title="null"></a></p><h3 id="可能用到的情景和对性能的影响"><a href="#可能用到的情景和对性能的影响" class="headerlink" title="可能用到的情景和对性能的影响"></a>可能用到的情景和对性能的影响</h3><p><strong>使用情景：</strong></p><p>\1. select *** for update 的使用场景</p><p>为了让自己查到的数据确保是最新数据，并且查到后的数据只允许自己来修改的时候，需要用到 for update 子句。</p><p>\2. select *** lock in share mode 使用场景</p><p>为了确保自己查到的数据没有被其他的事务正在修改，也就是说确保查到的数据是最新的数据，并且不允许其他人来修改数据。但是自己不一定能够修改数据（比如a,b都拿了锁，a更改了数据，因为b还拿着锁，a提交不了，直到超时），因为有可能其他的事务也对这些数据 使用了 in share mode 的方式上了 S 锁。</p><p><strong>性能影响：</strong></p><p>select for update 语句，相当于一个 update 语句。在业务繁忙的情况下，如果事务没有及时的commit或者rollback 可能会造成其他事务长时间的等待，从而影响数据库的并发使用效率。</p><p>select lock in share mode 语句是一个给查找的数据上一个共享锁（S 锁）的功能，它允许其他的事务也对该数据上 S锁，但是不能够允许对该数据进行修改。如果不及时的commit 或者rollback 也可能会造成大量的事务等待。</p><p>for update 和 lock in share mode 的区别：前一个上的是排他锁（X 锁），一旦一个事务获取了这个锁，其他的事务是没法在这些数据上执行 for update ；后一个是共享锁，多个事务可以同时的对相同数据执行 lock in share mode。</p><p>-—————————————————————————————————————————————————————————</p><p>例子实验</p><p>1.lock in share mode死锁情况</p><table><thead><tr><th>a</th><th>b</th></tr></thead><tbody><tr><td>SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;</td><td></td></tr><tr><td>SET AUTOCOMMIT=0;</td><td></td></tr><tr><td></td><td></td></tr><tr><td>BEGIN</td><td>BEGIN</td></tr><tr><td>SELECT * FROM test</td><td>SELECT * FROM test</td></tr><tr><td><img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-04-selectforupdate%E5%85%B1%E4%BA%AB%E8%AF%BB%E9%94%81%E5%AF%B9%E4%BA%8B%E5%8A%A1%E5%B9%B6%E5%8F%91%E5%BD%B1%E5%93%8D/464291-20170930111840872-1105337469.png" alt="img" title="null"></td><td><img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-04-selectforupdate%E5%85%B1%E4%BA%AB%E8%AF%BB%E9%94%81%E5%AF%B9%E4%BA%8B%E5%8A%A1%E5%B9%B6%E5%8F%91%E5%BD%B1%E5%93%8D/464291-20170930111842356-1636185387.png" alt="img" title="null"></td></tr><tr><td>SELECT * FROM test WHERE a=’1’ LOCK IN SHARE MODE;</td><td>SELECT * FROM test WHERE a=’1’ LOCK IN SHARE MODE;</td></tr><tr><td><img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-04-selectforupdate%E5%85%B1%E4%BA%AB%E8%AF%BB%E9%94%81%E5%AF%B9%E4%BA%8B%E5%8A%A1%E5%B9%B6%E5%8F%91%E5%BD%B1%E5%93%8D/464291-20170930111847965-561733952.png" alt="img" title="null"></td><td><img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-04-selectforupdate%E5%85%B1%E4%BA%AB%E8%AF%BB%E9%94%81%E5%AF%B9%E4%BA%8B%E5%8A%A1%E5%B9%B6%E5%8F%91%E5%BD%B1%E5%93%8D/464291-20170930111849356-62133572.png" alt="img" title="null"></td></tr><tr><td>UPDATE test SET b=111 WHERE a=’1’ <img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-04-selectforupdate%E5%85%B1%E4%BA%AB%E8%AF%BB%E9%94%81%E5%AF%B9%E4%BA%8B%E5%8A%A1%E5%B9%B6%E5%8F%91%E5%BD%B1%E5%93%8D/464291-20170930111854919-1673283464.png" alt="img" title="null"></td><td></td></tr><tr><td></td><td>UPDATE test SET b=222 WHERE a=’1’</td></tr><tr><td></td><td><img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-04-selectforupdate%E5%85%B1%E4%BA%AB%E8%AF%BB%E9%94%81%E5%AF%B9%E4%BA%8B%E5%8A%A1%E5%B9%B6%E5%8F%91%E5%BD%B1%E5%93%8D/464291-20170930111900278-1364757494.png" alt="img" title="null"></td></tr><tr><td><img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-04-selectforupdate%E5%85%B1%E4%BA%AB%E8%AF%BB%E9%94%81%E5%AF%B9%E4%BA%8B%E5%8A%A1%E5%B9%B6%E5%8F%91%E5%BD%B1%E5%93%8D/464291-20170930111908153-197277786.png" alt="img" title="null"></td><td>B死锁了，释放掉了s锁，所以a就成功了</td></tr><tr><td></td><td>UPDATE test SET b=222 WHERE a=’1’</td></tr><tr><td></td><td><img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-04-selectforupdate%E5%85%B1%E4%BA%AB%E8%AF%BB%E9%94%81%E5%AF%B9%E4%BA%8B%E5%8A%A1%E5%B9%B6%E5%8F%91%E5%BD%B1%E5%93%8D/464291-20170930111912825-1622843393.png" alt="img" title="null"></td></tr><tr><td>COMMIT</td><td></td></tr><tr><td></td><td>A提交后B才更新成功，因为死锁后B丢了锁，A才成功<img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-04-selectforupdate%E5%85%B1%E4%BA%AB%E8%AF%BB%E9%94%81%E5%AF%B9%E4%BA%8B%E5%8A%A1%E5%B9%B6%E5%8F%91%E5%BD%B1%E5%93%8D/464291-20170930111918122-70439956.png" alt="img" title="null"></td></tr><tr><td>SELECT * FROM test</td><td></td></tr><tr><td><img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-04-selectforupdate%E5%85%B1%E4%BA%AB%E8%AF%BB%E9%94%81%E5%AF%B9%E4%BA%8B%E5%8A%A1%E5%B9%B6%E5%8F%91%E5%BD%B1%E5%93%8D/464291-20170930111923590-1573623926.png" alt="img" title="null"></td><td></td></tr><tr><td></td><td>SELECT * FROM test</td></tr><tr><td></td><td><img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-04-selectforupdate%E5%85%B1%E4%BA%AB%E8%AF%BB%E9%94%81%E5%AF%B9%E4%BA%8B%E5%8A%A1%E5%B9%B6%E5%8F%91%E5%BD%B1%E5%93%8D/464291-20170930111930075-1881588364.png" alt="img" title="null"></td></tr><tr><td></td><td>COMMIT</td></tr><tr><td>SELECT * FROM test</td><td>SELECT * FROM test</td></tr><tr><td><img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-04-selectforupdate%E5%85%B1%E4%BA%AB%E8%AF%BB%E9%94%81%E5%AF%B9%E4%BA%8B%E5%8A%A1%E5%B9%B6%E5%8F%91%E5%BD%B1%E5%93%8D/464291-20170930111934825-256775924.png" alt="img" title="null"></td><td><img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-04-selectforupdate%E5%85%B1%E4%BA%AB%E8%AF%BB%E9%94%81%E5%AF%B9%E4%BA%8B%E5%8A%A1%E5%B9%B6%E5%8F%91%E5%BD%B1%E5%93%8D/464291-20170930111936606-1281292661.png" alt="img" title="null"></td></tr></tbody></table><p>例子2 for update锁</p><table><thead><tr><th>a</th><th>b</th></tr></thead><tbody><tr><td>SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;</td><td></td></tr><tr><td>SET AUTOCOMMIT=0;</td><td></td></tr><tr><td></td><td></td></tr><tr><td>BEGIN</td><td>BEGIN</td></tr><tr><td>SELECT * FROM test</td><td>SELECT * FROM test</td></tr><tr><td><img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-04-selectforupdate%E5%85%B1%E4%BA%AB%E8%AF%BB%E9%94%81%E5%AF%B9%E4%BA%8B%E5%8A%A1%E5%B9%B6%E5%8F%91%E5%BD%B1%E5%93%8D/464291-20170930112455450-1958545029.png" alt="img" title="null"></td><td><img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-04-selectforupdate%E5%85%B1%E4%BA%AB%E8%AF%BB%E9%94%81%E5%AF%B9%E4%BA%8B%E5%8A%A1%E5%B9%B6%E5%8F%91%E5%BD%B1%E5%93%8D/464291-20170930112456794-2039567749.png" alt="img" title="null"></td></tr><tr><td>SELECT * FROM test WHERE a=’1’ FOR UPDATE;</td><td></td></tr><tr><td><img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-04-selectforupdate%E5%85%B1%E4%BA%AB%E8%AF%BB%E9%94%81%E5%AF%B9%E4%BA%8B%E5%8A%A1%E5%B9%B6%E5%8F%91%E5%BD%B1%E5%93%8D/464291-20170930112501700-1654496949.png" alt="img" title="null"></td><td>SELECT * FROM test WHERE a=’1’ FOR UPDATE;</td></tr><tr><td></td><td><img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-04-selectforupdate%E5%85%B1%E4%BA%AB%E8%AF%BB%E9%94%81%E5%AF%B9%E4%BA%8B%E5%8A%A1%E5%B9%B6%E5%8F%91%E5%BD%B1%E5%93%8D/464291-20170930112504684-2077931864.png" alt="img" title="null"></td></tr><tr><td>COMMIT</td><td>COMMIT</td></tr><tr><td>ForUpdate只能一个人拿到锁，是x（排他）锁</td><td></td></tr></tbody></table><p><strong>注：转载自 博客园 crazyYong：<a href="https://www.cnblogs.com/crazylqy/p/7614245.html" target="_blank" rel="noopener">https://www.cnblogs.com/crazylqy/p/7614245.html</a></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;select-for-update-lock-in-share-mode-对事务并发性影响&quot;&gt;&lt;a href=&quot;#select-for-update-lock-in-share-mode-对事务并发性影响&quot; class=&quot;headerlink&quot; title=&quot;se
      
    
    </summary>
    
    
      <category term="MySQL" scheme="https://husky-wu.github.io/categories/MySQL/"/>
    
      <category term="锁" scheme="https://husky-wu.github.io/categories/MySQL/%E9%94%81/"/>
    
    
      <category term="MySQL" scheme="https://husky-wu.github.io/tags/MySQL/"/>
    
      <category term="锁" scheme="https://husky-wu.github.io/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>MySQL加锁过程详解-03-关于幻读理解</title>
    <link href="https://husky-wu.github.io/2021/01/04/MySQL/MySQL%E9%94%81%E8%AF%A6%E8%A7%A3/MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-03-%E5%85%B3%E4%BA%8E%E5%B9%BB%E8%AF%BB%E7%90%86%E8%A7%A3/"/>
    <id>https://husky-wu.github.io/2021/01/04/MySQL/MySQL%E9%94%81%E8%AF%A6%E8%A7%A3/MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-03-%E5%85%B3%E4%BA%8E%E5%B9%BB%E8%AF%BB%E7%90%86%E8%A7%A3/</id>
    <published>2021-01-04T05:56:37.000Z</published>
    <updated>2021-01-04T06:37:51.421Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.cnblogs.com/crazylqy/p/7612230.html" target="_blank" rel="noopener"><strong>Mysql加锁过程详解（2）-关于mysql 幻读理解</strong></a>出现了幻读，那么不是说mysql的重复读解决了幻读的么？</p><p>那么，InnoDB指出的可以避免幻读是怎么回事呢？</p><blockquote><p><a href="http://dev.mysql.com/doc/refman/5.0/en/innodb-record-level-locks.html" target="_blank" rel="noopener">http://dev.mysql.com/doc/refman/5.0/en/innodb-record-level-locks.html</a></p><p>By default, InnoDB operates in REPEATABLE READ transaction isolation level and with the innodb_locks_unsafe_for_binlog system variable disabled. In this case, InnoDB uses next-key locks for searches and index scans, which prevents phantom rows (see Section 13.6.8.5, “Avoiding the Phantom Problem Using Next-Key Locking”).</p></blockquote><p>准备的理解是，当隔离级别是可重复读，且禁用innodb_locks_unsafe_for_binlog的情况下，在搜索和扫描index的时候使用的next-key locks可以避免幻读。</p><p>关键点在于，是InnoDB默认对一个普通的查询也会加next-key locks，还是说需要应用自己来加锁呢？如果单看这一句，可能会以为InnoDB对普通的查询也加了锁，如果是，那和序列化（SERIALIZABLE）的区别又在哪里呢？</p><p>MySQL manual里还有一段：</p><blockquote><p>13.2.8.5. Avoiding the Phantom Problem Using Next-Key Locking (<a href="http://dev.mysql.com/doc/refman/5.0/en/innodb-next-key-locking.html" target="_blank" rel="noopener">http://dev.mysql.com/doc/refman/5.0/en/innodb-next-key-locking.html</a>)</p><p>To prevent phantoms, <code>InnoDB</code> uses an algorithm called <em>next-key locking</em> that combines index-row locking with gap locking.</p><p>You can use next-key locking to implement a uniqueness check in your application: If you read your data in share mode and do not see a duplicate for a row you are going to insert, then you can safely insert your row and know that the next-key lock set on the successor of your row during the read prevents anyone meanwhile inserting a duplicate for your row. Thus, the next-key locking enables you to “lock” the nonexistence of something in your table.</p></blockquote><p>我的理解是说，InnoDB提供了next-key locks，但需要应用程序自己去加锁。manual里提供一个例子：</p><blockquote><p>SELECT * FROM child WHERE id &gt; 100 FOR UPDATE;</p></blockquote><p>这样，InnoDB会给id大于100的行（假如child表里有一行id为102），以及100-102，102+的gap都加上锁。</p><p>可以使用show innodb status来查看是否给表加上了锁。</p><p>下面看列子</p><p>例子1</p><table><thead><tr><th>a</th><th>b</th></tr></thead><tbody><tr><td>SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;</td><td></td></tr><tr><td>SET AUTOCOMMIT=0;</td><td></td></tr><tr><td></td><td></td></tr><tr><td>BEGIN</td><td>BEGIN</td></tr><tr><td>SELECT * FROM test WHERE a=’1’ FOR UPDATE;</td><td></td></tr><tr><td></td><td>SELECT * FROM test</td></tr><tr><td></td><td><img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-03-%E5%85%B3%E4%BA%8E%E5%B9%BB%E8%AF%BB%E7%90%86%E8%A7%A3/464291-20170930104010919-1938423655.png" alt="img" title="null"></td></tr><tr><td></td><td>INSERT test VALUES(1,1);</td></tr><tr><td></td><td><img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-03-%E5%85%B3%E4%BA%8E%E5%B9%BB%E8%AF%BB%E7%90%86%E8%A7%A3/464291-20170930104015528-1725462896.png" alt="img" title="null"> 锁住了</td></tr><tr><td>INSERT test VALUES(1,1);</td><td></td></tr><tr><td>成功</td><td></td></tr><tr><td>COMMIT</td><td></td></tr><tr><td></td><td><img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-03-%E5%85%B3%E4%BA%8E%E5%B9%BB%E8%AF%BB%E7%90%86%E8%A7%A3/464291-20170930104020887-2039098789.png" alt="img" title="null"></td></tr><tr><td></td><td>COMMIT</td></tr><tr><td></td><td>避免幻读可以select锁住，再insert</td></tr></tbody></table><p> 例子2</p><table><thead><tr><th>a</th><th>b</th></tr></thead><tbody><tr><td>SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;</td><td></td></tr><tr><td>SET AUTOCOMMIT=0;</td><td></td></tr><tr><td></td><td></td></tr><tr><td>BEGIN</td><td>BEGIN</td></tr><tr><td>SELECT * FROM test WHERE a=’1’ FOR UPDATE;</td><td></td></tr><tr><td></td><td>SELECT * FROM test</td></tr><tr><td></td><td><img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-03-%E5%85%B3%E4%BA%8E%E5%B9%BB%E8%AF%BB%E7%90%86%E8%A7%A3/464291-20170930104048106-299561308.png" alt="img" title="null"></td></tr><tr><td></td><td>INSERT test VALUES(2,2);</td></tr><tr><td></td><td><img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-03-%E5%85%B3%E4%BA%8E%E5%B9%BB%E8%AF%BB%E7%90%86%E8%A7%A3/464291-20170930104052981-1824395224.png" alt="img" title="null"> 连2也被锁住了？</td></tr><tr><td>INSERT test VALUES(1,1);</td><td></td></tr><tr><td>成功</td><td></td></tr><tr><td>COMMIT</td><td></td></tr><tr><td></td><td><img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-03-%E5%85%B3%E4%BA%8E%E5%B9%BB%E8%AF%BB%E7%90%86%E8%A7%A3/464291-20170930104057856-1609225466.png" alt="img" title="null"> 这次提交成功</td></tr><tr><td></td><td>COMMIT</td></tr><tr><td>其他尝试，这种情况无论插入2还是5都被锁住等等</td><td></td></tr></tbody></table><p> 例子3</p><table><thead><tr><th>a</th><th>b</th></tr></thead><tbody><tr><td>SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;</td><td></td></tr><tr><td>SET AUTOCOMMIT=0;</td><td></td></tr><tr><td></td><td></td></tr><tr><td>BEGIN</td><td>BEGIN</td></tr><tr><td>SELECT * FROM test</td><td>SELECT * FROM test</td></tr><tr><td><img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-03-%E5%85%B3%E4%BA%8E%E5%B9%BB%E8%AF%BB%E7%90%86%E8%A7%A3/464291-20170930104132481-1091031787.png" alt="img" title="null"></td><td><img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-03-%E5%85%B3%E4%BA%8E%E5%B9%BB%E8%AF%BB%E7%90%86%E8%A7%A3/464291-20170930104134481-12957166.png" alt="img" title="null"></td></tr><tr><td>SELECT * FROM test WHERE a=’1’ FOR UPDATE;</td><td></td></tr><tr><td><img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-03-%E5%85%B3%E4%BA%8E%E5%B9%BB%E8%AF%BB%E7%90%86%E8%A7%A3/464291-20170930104132481-1091031787.png" alt="img" title="null"></td><td>SELECT * FROM test</td></tr><tr><td></td><td><img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-03-%E5%85%B3%E4%BA%8E%E5%B9%BB%E8%AF%BB%E7%90%86%E8%A7%A3/464291-20170930104138747-1332787466.png" alt="img" title="null"></td></tr><tr><td></td><td>INSERT test VALUES(2,2);</td></tr><tr><td></td><td><img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-03-%E5%85%B3%E4%BA%8E%E5%B9%BB%E8%AF%BB%E7%90%86%E8%A7%A3/464291-20170930104143903-1665145247.png" alt="img" title="null"></td></tr><tr><td>COMMIT</td><td>COMMIT</td></tr><tr><td>成功</td><td></td></tr><tr><td>COMMIT</td><td></td></tr><tr><td></td><td>COMMIT</td></tr><tr><td></td><td></td></tr></tbody></table><p> 例子 4</p><table><thead><tr><th>a</th><th>b</th></tr></thead><tbody><tr><td>SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;</td><td></td></tr><tr><td>SET AUTOCOMMIT=0;</td><td></td></tr><tr><td></td><td></td></tr><tr><td>BEGIN</td><td>BEGIN</td></tr><tr><td>SELECT * FROM test</td><td>SELECT * FROM test</td></tr><tr><td><img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-03-%E5%85%B3%E4%BA%8E%E5%B9%BB%E8%AF%BB%E7%90%86%E8%A7%A3/464291-20170930104304059-1851404658.png" alt="img" title="null"></td><td><img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-03-%E5%85%B3%E4%BA%8E%E5%B9%BB%E8%AF%BB%E7%90%86%E8%A7%A3/464291-20170930104305465-800294356.png" alt="img" title="null"></td></tr><tr><td>SELECT * FROM test WHERE a=’2’ FOR UPDATE;</td><td></td></tr><tr><td><img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-03-%E5%85%B3%E4%BA%8E%E5%B9%BB%E8%AF%BB%E7%90%86%E8%A7%A3/464291-20170930104309950-1610819395.png" alt="img" title="null"></td><td></td></tr><tr><td></td><td>SELECT * FROM test</td></tr><tr><td></td><td><img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-03-%E5%85%B3%E4%BA%8E%E5%B9%BB%E8%AF%BB%E7%90%86%E8%A7%A3/464291-20170930104314684-2021050414.png" alt="img" title="null"></td></tr><tr><td></td><td>INSERT test VALUES(2,2);</td></tr><tr><td></td><td><img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-03-%E5%85%B3%E4%BA%8E%E5%B9%BB%E8%AF%BB%E7%90%86%E8%A7%A3/464291-20170930104319825-1455889582.png" alt="img" title="null"></td></tr><tr><td></td><td>INSERT test VALUES(5,5);</td></tr><tr><td></td><td><img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-03-%E5%85%B3%E4%BA%8E%E5%B9%BB%E8%AF%BB%E7%90%86%E8%A7%A3/464291-20170930104322059-2030975459.png" alt="img" title="null"></td></tr><tr><td>COMMIT</td><td>COMMIT</td></tr></tbody></table><p>例子 5</p><table><thead><tr><th>a</th><th>b</th></tr></thead><tbody><tr><td>SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;</td><td></td></tr><tr><td>SET AUTOCOMMIT=0;</td><td></td></tr><tr><td>BEGIN</td><td>BEGIN</td></tr><tr><td>SELECT * FROM test</td><td>SELECT * FROM test</td></tr><tr><td><img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-03-%E5%85%B3%E4%BA%8E%E5%B9%BB%E8%AF%BB%E7%90%86%E8%A7%A3/464291-20170930104356481-1257224036.png" alt="img" title="null"></td><td><img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-03-%E5%85%B3%E4%BA%8E%E5%B9%BB%E8%AF%BB%E7%90%86%E8%A7%A3/464291-20170930104358012-352407420.png" alt="img" title="null"></td></tr><tr><td>SELECT * FROM test WHERE a=’1’ FOR UPDATE;</td><td></td></tr><tr><td></td><td>INSERT test VALUES(5,5);</td></tr><tr><td></td><td><img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-03-%E5%85%B3%E4%BA%8E%E5%B9%BB%E8%AF%BB%E7%90%86%E8%A7%A3/464291-20170930104413856-2086703256.png" alt="img" title="null"> 插入5成功了</td></tr><tr><td></td><td>UPDATE test SET b=33 WHERE a=’3’</td></tr><tr><td></td><td><img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-03-%E5%85%B3%E4%BA%8E%E5%B9%BB%E8%AF%BB%E7%90%86%E8%A7%A3/464291-20170930104419669-648847820.png" alt="img" title="null"></td></tr><tr><td></td><td>INSERT test VALUES(2,2);</td></tr><tr><td></td><td><img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-03-%E5%85%B3%E4%BA%8E%E5%B9%BB%E8%AF%BB%E7%90%86%E8%A7%A3/464291-20170930104426872-1225749677.png" alt="img" title="null"> 2也可以</td></tr><tr><td></td><td>UPDATE test SET b=11 WHERE a=’1’</td></tr><tr><td></td><td><img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-03-%E5%85%B3%E4%BA%8E%E5%B9%BB%E8%AF%BB%E7%90%86%E8%A7%A3/464291-20170930104438528-2085907744.png" alt="img" title="null"> 1锁住了</td></tr><tr><td>COMMIT</td><td></td></tr><tr><td></td><td><img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-03-%E5%85%B3%E4%BA%8E%E5%B9%BB%E8%AF%BB%E7%90%86%E8%A7%A3/464291-20170930104445669-1241399068.png" alt="img" title="null"></td></tr><tr><td></td><td>COMMIT</td></tr><tr><td>SELECT * FROM test</td><td>SELECT * FROM test</td></tr><tr><td><img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-03-%E5%85%B3%E4%BA%8E%E5%B9%BB%E8%AF%BB%E7%90%86%E8%A7%A3/464291-20170930104454637-861544600.png" alt="img" title="null"></td><td><img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-03-%E5%85%B3%E4%BA%8E%E5%B9%BB%E8%AF%BB%E7%90%86%E8%A7%A3/464291-20170930104500044-490420920.png" alt="img" title="null"></td></tr></tbody></table><p>以上例子说明，forupdate时候，id为主键，RR策略时候，锁住了的条件符合的行，但是如果条件找不到任何列，锁住的是整个表，（主键，唯一索引，非唯一索引，（insert，update对于gab锁不通），参考第一章，第七章,第九章）</p><p> -—————————————————————–</p><p> 再来看大神的解释 ：链接: <a href="http://blog.bitfly.cn/post/mysql-innodb-phantom-read/" target="_blank" rel="noopener">http://blog.bitfly.cn/post/mysql-innodb-phantom-read/</a></p><p>再看一个实验，要注意，表t_bitfly里的id为主键字段。实验三：</p><blockquote><p>t Session A         Session B<br>|<br>| START TRANSACTION;    START TRANSACTION;<br>|<br>| SELECT * FROM t_bitfly<br>| WHERE id&lt;=1<br>| FOR UPDATE;<br>| +——+——-+<br>| | id  | value |<br>| +——+——-+<br>| |  1 | a   |<br>| +——+——-+<br>|              INSERT INTO t_bitfly<br>|              VALUES (2, ‘b’);<br>|              Query OK, 1 row affected<br>|<br>| SELECT * FROM t_bitfly;<br>| +——+——-+<br>| | id  | value |<br>| +——+——-+<br>| |  1 | a   |<br>| +——+——-+<br>|              INSERT INTO t_bitfly<br>|              VALUES (0, ‘0’);<br>|              (waiting for lock …<br>|              then timeout)<br>|              ERROR 1205 (HY000):<br>|              Lock wait timeout exceeded;<br>|              try restarting transaction<br>|<br>| SELECT * FROM t_bitfly;<br>| +——+——-+<br>| | id  | value |<br>| +——+——-+<br>| |  1 | a   |<br>| +——+——-+<br>|              COMMIT;<br>|<br>| SELECT * FROM t_bitfly;<br>| +——+——-+<br>| | id  | value |<br>| +——+——-+<br>| |  1 | a   |<br>| +——+——-+<br>v</p></blockquote><p>可以看到，用id&lt;=1加的锁，只锁住了id&lt;=1的范围，可以成功添加id为2的记录，添加id为0的记录时就会等待锁的释放。</p><p>MySQL manual里对可重复读里的锁的详细解释：</p><blockquote><p><a href="http://dev.mysql.com/doc/refman/5.0/en/set-transaction.html#isolevel_repeatable-read" target="_blank" rel="noopener">http://dev.mysql.com/doc/refman/5.0/en/set-transaction.html#isolevel_repeatable-read</a></p><p>For locking reads (<a href="http://dev.mysql.com/doc/refman/5.0/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a> with <code>FOR UPDATE</code> or <code>LOCK IN SHARE MODE</code>),<a href="http://dev.mysql.com/doc/refman/5.0/en/update.html" target="_blank" rel="noopener"><code>UPDATE</code></a>, and <a href="http://dev.mysql.com/doc/refman/5.0/en/delete.html" target="_blank" rel="noopener"><code>DELETE</code></a> statements, locking depends on whether the statement uses a unique index with a unique search condition, or a range-type search condition. For a unique index with a unique search condition, <code>InnoDB</code> locks only the index record found, not the gap before it. For other search conditions, <code>InnoDB</code> locks the index range scanned, using gap locks or next-key (gap plus index-record) locks to block insertions by other sessions into the gaps covered by the range.</p></blockquote><p>-—–</p><p>一致性读和提交读，先看实验，实验四：</p><blockquote><p>t Session A           Session B<br>|<br>| START TRANSACTION;       START TRANSACTION;<br>|<br>| SELECT * FROM t_bitfly;<br>| +—-+——-+<br>| | id | value |<br>| +—-+——-+<br>| | 1 | a   |<br>| +—-+——-+<br>|                INSERT INTO t_bitfly<br>|                VALUES (2, ‘b’);<br>|                COMMIT;<br>|<br>| SELECT * FROM t_bitfly;<br>| +—-+——-+<br>| | id | value |<br>| +—-+——-+<br>| | 1 | a   |<br>| +—-+——-+<br>|<br>| SELECT * FROM t_bitfly LOCK IN SHARE MODE;<br>| +—-+——-+<br>| | id | value |<br>| +—-+——-+<br>| | 1 | a   |<br>| | 2 | b   |<br>| +—-+——-+<br>|<br>| SELECT * FROM t_bitfly FOR UPDATE;<br>| +—-+——-+<br>| | id | value |<br>| +—-+——-+<br>| | 1 | a   |<br>| | 2 | b   |<br>| +—-+——-+<br>|<br>| SELECT * FROM t_bitfly;<br>| +—-+——-+<br>| | id | value |<br>| +—-+——-+<br>| | 1 | a   |<br>| +—-+——-+<br>v</p></blockquote><p>如果使用普通的读，会得到一致性的结果，如果使用了加锁的读，就会读到“最新的”“提交”读的结果。</p><p>本身，可重复读和提交读是矛盾的。在同一个事务里，如果保证了可重复读，就会看不到其他事务的提交，违背了提交读；如果保证了提交读，就会导致前后两次读到的结果不一致，违背了可重复读。</p><p><strong>可以这么讲，InnoDB提供了这样的机制，在默认的可重复读的隔离级别里，可以使用加锁读去查询最新的数据。</strong></p><blockquote><p><a href="http://dev.mysql.com/doc/refman/5.0/en/innodb-consistent-read.html" target="_blank" rel="noopener">http://dev.mysql.com/doc/refman/5.0/en/innodb-consistent-read.html</a></p><p>If you want to see the “freshest” state of the database, you should use either the READ COMMITTED isolation level or a locking read:<br>SELECT * FROM t_bitfly LOCK IN SHARE MODE;</p></blockquote><p>结论：MySQL InnoDB的可重复读并不保证避免幻读，需要应用使用加锁读来保证。而这个加锁度使用到的机制就是<strong>next-key locks。</strong></p><p>​        <strong>mysql 的重复读解决了幻读的现象，但是需要 加上 select for update/lock in share mode 变成当前读避免幻读，普通读select存在幻读</strong></p><p><strong>注：转载自 博客园 crazyYong：<a href="https://www.cnblogs.com/crazylqy/p/7614092.html" target="_blank" rel="noopener">https://www.cnblogs.com/crazylqy/p/7614092.html</a></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/crazylqy/p/7612230.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;Mysql加锁过程详解（2）-关于mysql 幻读理解&lt;/strong&gt;&lt;/a&gt;出
      
    
    </summary>
    
    
      <category term="MySQL" scheme="https://husky-wu.github.io/categories/MySQL/"/>
    
      <category term="锁" scheme="https://husky-wu.github.io/categories/MySQL/%E9%94%81/"/>
    
    
      <category term="MySQL" scheme="https://husky-wu.github.io/tags/MySQL/"/>
    
      <category term="锁" scheme="https://husky-wu.github.io/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>MySQL加锁过程详解-01-关于幻读理解</title>
    <link href="https://husky-wu.github.io/2021/01/04/MySQL/MySQL%E9%94%81%E8%AF%A6%E8%A7%A3/MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-02-%E5%85%B3%E4%BA%8E%E5%B9%BB%E8%AF%BB%E7%90%86%E8%A7%A3/"/>
    <id>https://husky-wu.github.io/2021/01/04/MySQL/MySQL%E9%94%81%E8%AF%A6%E8%A7%A3/MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-02-%E5%85%B3%E4%BA%8E%E5%B9%BB%E8%AF%BB%E7%90%86%E8%A7%A3/</id>
    <published>2021-01-04T05:56:23.000Z</published>
    <updated>2021-01-04T06:58:01.078Z</updated>
    
    <content type="html"><![CDATA[<p>首先，mysql 幻读并非是”一个事务内进行两次相同操作居然得到了不一样的结果”，因为它根本不可能发生在使用了 read view / MVCC 的 RR 隔离级别下，这种幻读的定义更适合给 Oracle，Oracle 的事务隔离只有两级，RC 和 Serializable。然后还有很多人辩解说不可重复读是针对某条记录的，幻读是针对记录集合的，这是在自我安慰么？</p><p>这里给出 mysql 幻读的比较形象的场景：</p><p>users： id 主键</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、T1：<span class="keyword">select</span> * <span class="keyword">from</span> users <span class="keyword">where</span> id = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">2、T2：<span class="keyword">insert</span> <span class="keyword">into</span> <span class="symbol">`users`</span>(<span class="symbol">`id`</span>, <span class="symbol">`name`</span>) <span class="keyword">values</span> (<span class="number">1</span>, <span class="string">'big cat'</span>);</span><br><span class="line"></span><br><span class="line">3、T1：<span class="keyword">insert</span> <span class="keyword">into</span> <span class="symbol">`users`</span>(<span class="symbol">`id`</span>, <span class="symbol">`name`</span>) <span class="keyword">values</span> (<span class="number">1</span>, <span class="string">'big cat'</span>);</span><br></pre></td></tr></table></figure><p>T1 ：主事务，检测表中是否有 id 为 1 的记录，没有则插入，这是我们期望的正常业务逻辑。</p><p>T2 ：干扰事务，目的在于扰乱 T1 的正常的事务执行。</p><p>在 RR 隔离级别下，1、2 是会正常执行的，3 则会报错主键冲突，对于 T1 的业务来说是执行失败的，这里 T1 就是发生了幻读，因为T1读取的数据状态并不能支持他的下一步的业务，见鬼了一样。</p><p>在 Serializable 隔离级别下，1 执行时是会隐式的添加 gap 共享锁的，从而 2 会被阻塞，3 会正常执行，对于 T1 来说业务是正确的，成功的扼杀了扰乱业务的T2，对于T1来说他读取的状态是可以拿来支持业务的。</p><p>所以 mysql 的幻读并非什么读取两次返回结果集不同，而是事务在插入事先检测不存在的记录时，惊奇的发现这些数据已经存在了，之前的检测读获取到的数据如同鬼影一般。</p><p>这里要灵活的理解读取的意思，第一次select是读取，第二次的 insert 其实也属于隐式的读取，只不过是在 mysql 的机制中读取的，插入数据也是要先读取一下有没有主键冲突才能决定是否执行插入。</p><p>不可重复读侧重表达 读-读，幻读则是说 读-写，用写来证实读的是鬼影。</p><p>下面例子版本</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">VERSION</span>();</span><br></pre></td></tr></table></figure><p> <img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-02-%E5%85%B3%E4%BA%8E%E5%B9%BB%E8%AF%BB%E7%90%86%E8%A7%A3/464291-20170929181641075-1331573070.png" alt="img" title="null"></p><p>例子1，读提交</p><table><thead><tr><th>a</th><th>b</th></tr></thead><tbody><tr><td>SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;</td><td></td></tr><tr><td>SET AUTOCOMMIT=0;</td><td></td></tr><tr><td>1.不可重复读</td><td></td></tr><tr><td>begin</td><td>begin</td></tr><tr><td>INSERT test VALUES(1,1);</td><td></td></tr><tr><td>SELECT * FROM test; <img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-02-%E5%85%B3%E4%BA%8E%E5%B9%BB%E8%AF%BB%E7%90%86%E8%A7%A3/464291-20170929181329731-1636218830.png" alt="img" title="null"></td><td>SELECT * FROM test; <img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-02-%E5%85%B3%E4%BA%8E%E5%B9%BB%E8%AF%BB%E7%90%86%E8%A7%A3/464291-20170929181333700-665094487.png" alt="img" title="null"></td></tr><tr><td>commit</td><td></td></tr><tr><td></td><td>SELECT * FROM test;</td></tr><tr><td></td><td><img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-02-%E5%85%B3%E4%BA%8E%E5%B9%BB%E8%AF%BB%E7%90%86%E8%A7%A3/464291-20170929181338903-1393057236.png" alt="img" title="null"></td></tr><tr><td></td><td>COMMIT</td></tr><tr><td>B在一个事务的查询的结果变了，不可重复读</td><td></td></tr><tr><td>2.锁</td><td></td></tr><tr><td>begin</td><td>begin</td></tr><tr><td>INSERT test VALUES(2,2);</td><td></td></tr><tr><td></td><td>SELECT * FROM test; <img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-02-%E5%85%B3%E4%BA%8E%E5%B9%BB%E8%AF%BB%E7%90%86%E8%A7%A3/464291-20170929181345840-682769274.png" alt="img" title="null"></td></tr><tr><td></td><td>INSERT test VALUES(2,2);</td></tr><tr><td></td><td>Lock wait timeout exceeded; try restarting transaction</td></tr><tr><td>COMMIT</td><td>COMMIT</td></tr><tr><td></td><td></td></tr><tr><td></td><td>begin</td></tr><tr><td></td><td>INSERT test VALUES(3,3);</td></tr><tr><td></td><td>INSERT test VALUES(4,4);</td></tr><tr><td></td><td>COMMIT</td></tr><tr><td></td><td></td></tr><tr><td>BEGIN</td><td>BEGIN</td></tr><tr><td>SELECT COUNT(*) FROM test WHERE a&gt;2;<img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-02-%E5%85%B3%E4%BA%8E%E5%B9%BB%E8%AF%BB%E7%90%86%E8%A7%A3/464291-20170929181355372-1031981259.png" alt="img" title="null"></td><td>SELECT COUNT(*) FROM test WHERE a&gt;2;<img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-02-%E5%85%B3%E4%BA%8E%E5%B9%BB%E8%AF%BB%E7%90%86%E8%A7%A3/464291-20170929181400762-1790433160.png" alt="img" title="null"></td></tr><tr><td></td><td></td></tr><tr><td>INSERT test VALUES(5,5);</td><td></td></tr><tr><td>SELECT COUNT(*) FROM test WHERE a&gt;2;<img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-02-%E5%85%B3%E4%BA%8E%E5%B9%BB%E8%AF%BB%E7%90%86%E8%A7%A3/464291-20170929181406669-19342833.png" alt="img" title="null"></td><td>SELECT COUNT(*) FROM test WHERE a&gt;2;<img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-02-%E5%85%B3%E4%BA%8E%E5%B9%BB%E8%AF%BB%E7%90%86%E8%A7%A3/464291-20170929181412528-1453604507.png" alt="img" title="null"></td></tr><tr><td></td><td></td></tr><tr><td>COMMIT</td><td></td></tr><tr><td>SELECT COUNT(*) FROM test WHERE a&gt;2;</td><td>SELECT COUNT(*) FROM test WHERE a&gt;2;</td></tr><tr><td><img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-02-%E5%85%B3%E4%BA%8E%E5%B9%BB%E8%AF%BB%E7%90%86%E8%A7%A3/464291-20170929181419106-903647199.png" alt="img" title="null"></td><td><img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-02-%E5%85%B3%E4%BA%8E%E5%B9%BB%E8%AF%BB%E7%90%86%E8%A7%A3/464291-20170929181421137-1814914247.png" alt="img" title="null"></td></tr><tr><td></td><td></td></tr></tbody></table><p>例子2：重复读</p><table><thead><tr><th>a</th><th>b</th></tr></thead><tbody><tr><td>SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;</td><td></td></tr><tr><td>SET AUTOCOMMIT=0;</td><td></td></tr><tr><td>1．可重复读</td><td></td></tr><tr><td>begin</td><td>begin</td></tr><tr><td>INSERT test VALUES(1,1);</td><td></td></tr><tr><td>SELECT * FROM test; <img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-02-%E5%85%B3%E4%BA%8E%E5%B9%BB%E8%AF%BB%E7%90%86%E8%A7%A3/464291-20170929181434465-707008140.png" alt="img" title="null"></td><td>SELECT * FROM test; <img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-02-%E5%85%B3%E4%BA%8E%E5%B9%BB%E8%AF%BB%E7%90%86%E8%A7%A3/464291-20170929181438200-380512861.png" alt="img" title="null"></td></tr><tr><td>commit</td><td></td></tr><tr><td></td><td>SELECT * FROM test;</td></tr><tr><td></td><td><img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-02-%E5%85%B3%E4%BA%8E%E5%B9%BB%E8%AF%BB%E7%90%86%E8%A7%A3/464291-20170929181446825-542860738.png" alt="img" title="null"></td></tr><tr><td></td><td>COMMIT</td></tr><tr><td></td><td>BEGIN</td></tr><tr><td></td><td>SELECT * FROM test;</td></tr><tr><td></td><td><img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-02-%E5%85%B3%E4%BA%8E%E5%B9%BB%E8%AF%BB%E7%90%86%E8%A7%A3/464291-20170929181455012-85444060.png" alt="img" title="null"></td></tr><tr><td></td><td>COMMIT</td></tr><tr><td>B在一个事务的查询的没变</td><td></td></tr><tr><td>2锁</td><td></td></tr><tr><td>begin</td><td>begin</td></tr><tr><td>INSERT test VALUES(2,2);</td><td></td></tr><tr><td></td><td>SELECT * FROM test; <img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-02-%E5%85%B3%E4%BA%8E%E5%B9%BB%E8%AF%BB%E7%90%86%E8%A7%A3/464291-20170929181505122-383250492.png" alt="img" title="null"></td></tr><tr><td></td><td>INSERT test VALUES(2,2);</td></tr><tr><td></td><td>Lock wait timeout exceeded; try restarting transaction</td></tr><tr><td>COMMIT</td><td>COMMIT</td></tr><tr><td>3(幻读)</td><td></td></tr><tr><td>BEGIN</td><td>BEGIN</td></tr><tr><td>INSERT test VALUES(3,3);</td><td></td></tr><tr><td>SELECT * FROM test; <img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-02-%E5%85%B3%E4%BA%8E%E5%B9%BB%E8%AF%BB%E7%90%86%E8%A7%A3/464291-20170929181521622-2144019310.png" alt="img" title="null"></td><td>SELECT * FROM test; <img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-02-%E5%85%B3%E4%BA%8E%E5%B9%BB%E8%AF%BB%E7%90%86%E8%A7%A3/464291-20170929181528309-584037273.png" alt="img" title="null"></td></tr><tr><td>COMMIT</td><td></td></tr><tr><td></td><td>SELECT * FROM test; <img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-02-%E5%85%B3%E4%BA%8E%E5%B9%BB%E8%AF%BB%E7%90%86%E8%A7%A3/464291-20170929181533028-1715226359.png" alt="img" title="null"></td></tr><tr><td></td><td>INSERT test VALUES(3,3);</td></tr><tr><td></td><td>Duplicate entry ‘3’ for key ‘PRIMARY’</td></tr><tr><td></td><td>COMMIT</td></tr><tr><td></td><td>BEGIN</td></tr><tr><td></td><td>SELECT * FROM test; <img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-02-%E5%85%B3%E4%BA%8E%E5%B9%BB%E8%AF%BB%E7%90%86%E8%A7%A3/464291-20170929181540762-71659665.png" alt="img" title="null"></td></tr><tr><td></td><td>COMMIT</td></tr><tr><td>幻读，b明明查到没有，插入时候提示主键冲突，刚刚查询没有，出现幻觉？</td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td>begin</td></tr><tr><td></td><td>INSERT test VALUES(4,4);</td></tr><tr><td></td><td>COMMIT</td></tr><tr><td>4．可重复读</td><td></td></tr><tr><td>BEGIN</td><td>BEGIN</td></tr><tr><td>SELECT COUNT(*) FROM test WHERE a&gt;2;<img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-02-%E5%85%B3%E4%BA%8E%E5%B9%BB%E8%AF%BB%E7%90%86%E8%A7%A3/464291-20170929181557512-144452885.png" alt="img" title="null"></td><td>SELECT COUNT(*) FROM test WHERE a&gt;2;<img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-02-%E5%85%B3%E4%BA%8E%E5%B9%BB%E8%AF%BB%E7%90%86%E8%A7%A3/464291-20170929181602075-295796222.png" alt="img" title="null"></td></tr><tr><td></td><td></td></tr><tr><td>INSERT test VALUES(5,5);</td><td></td></tr><tr><td>SELECT COUNT(*) FROM test WHERE a&gt;2;<img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-02-%E5%85%B3%E4%BA%8E%E5%B9%BB%E8%AF%BB%E7%90%86%E8%A7%A3/464291-20170929181607044-1440714700.png" alt="img" title="null"></td><td>SELECT COUNT(*) FROM test WHERE a&gt;2;<img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-02-%E5%85%B3%E4%BA%8E%E5%B9%BB%E8%AF%BB%E7%90%86%E8%A7%A3/464291-20170929181612106-2088479400.png" alt="img" title="null"></td></tr><tr><td></td><td></td></tr><tr><td>COMMIT</td><td></td></tr><tr><td>BEGIN</td><td></td></tr><tr><td>SELECT COUNT(*) FROM test WHERE a&gt;2;</td><td>SELECT COUNT(*) FROM test WHERE a&gt;2;</td></tr><tr><td><img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-02-%E5%85%B3%E4%BA%8E%E5%B9%BB%E8%AF%BB%E7%90%86%E8%A7%A3/464291-20170929181623731-1638952317.png" alt="img" title="null"></td><td><img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-02-%E5%85%B3%E4%BA%8E%E5%B9%BB%E8%AF%BB%E7%90%86%E8%A7%A3/464291-20170929181627950-346414788.png" alt="img" title="null"></td></tr><tr><td>COMMIT</td><td>COMMIT</td></tr><tr><td></td><td></td></tr></tbody></table><p><strong>网上很多说范围啊，count等等都是不对的，不用于幻读</strong></p><p><strong>注：转载自 博客园 crazyYong：<a href="https://www.cnblogs.com/crazylqy/p/7612230.html" target="_blank" rel="noopener">https://www.cnblogs.com/crazylqy/p/7612230.html</a></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先，mysql 幻读并非是”一个事务内进行两次相同操作居然得到了不一样的结果”，因为它根本不可能发生在使用了 read view / MVCC 的 RR 隔离级别下，这种幻读的定义更适合给 Oracle，Oracle 的事务隔离只有两级，RC 和 Serializable
      
    
    </summary>
    
    
      <category term="MySQL" scheme="https://husky-wu.github.io/categories/MySQL/"/>
    
      <category term="锁" scheme="https://husky-wu.github.io/categories/MySQL/%E9%94%81/"/>
    
    
      <category term="MySQL" scheme="https://husky-wu.github.io/tags/MySQL/"/>
    
      <category term="锁" scheme="https://husky-wu.github.io/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>MySQL加锁过程详解-01-基础知识</title>
    <link href="https://husky-wu.github.io/2021/01/04/MySQL/MySQL%E9%94%81%E8%AF%A6%E8%A7%A3/MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://husky-wu.github.io/2021/01/04/MySQL/MySQL%E9%94%81%E8%AF%A6%E8%A7%A3/MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2021-01-04T05:51:02.000Z</published>
    <updated>2021-01-04T06:58:13.318Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、背景"><a href="#1、背景" class="headerlink" title="1、背景"></a>1、背景</h1><p>　　MySQL/InnoDB的加锁分析，一直是一个比较困难的话题。我在工作过程中，经常会有同事咨询这方面的问题。同时，微博上也经常会收到MySQL锁相关的私信，让我帮助解决一些死锁的问题。本文，准备就MySQL/InnoDB的加锁问题，展开较为深入的分析与讨论，主要是介绍一种思路，运用此思路，拿到任何一条SQL语句，都能完整的分析出这条语句会加什么锁？会有什么样的使用风险？甚至是分析线上的一个死锁场景，了解死锁产生的原因。</p><p><strong>注：</strong>MySQL是一个支持插件式存储引擎的数据库系统。本文下面的所有介绍，都是基于InnoDB存储引擎，其他引擎的表现，会有较大的区别。</p><h1 id="2、多版本并发控制MVCC：Snapshot-Read-vs-Current-Read"><a href="#2、多版本并发控制MVCC：Snapshot-Read-vs-Current-Read" class="headerlink" title="2、多版本并发控制MVCC：Snapshot Read vs Current Read"></a>2、多版本并发控制<strong>MVCC：Snapshot Read vs Current Read</strong></h1><p>　　MySQL InnoDB存储引擎，实现的是基于多版本的并发控制协议——MVCC (<a href="http://en.wikipedia.org/wiki/Multiversion_concurrency_control" target="_blank" rel="noopener">Multi-Version Concurrency Control</a>) (注：与MVCC相对的，是基于锁的并发控制，Lock-Based Concurrency Control)。MVCC最大的好处，相信也是耳熟能详：<strong>读不加锁，读写不冲突</strong>。在读多写少的OLTP应用中，读写不冲突是非常重要的，极大的增加了系统的并发性能，这也是为什么现阶段，几乎所有的RDBMS，都支持了MVCC。</p><p>　　在MVCC并发控制中，读操作可以分成两类<strong>：快照读 (snapshot read)与当前读 (current read)</strong>。快照读，读取的是记录的可见版本 (有可能是历史版本)，不用加锁。当前读，读取的是记录的最新版本，并且，当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录。</p><p>　　在一个支持MVCC并发控制的系统中，哪些读操作是快照读？哪些操作又是当前读呢？以MySQL InnoDB为例：</p><p>​    <strong>快照读：</strong>简单的select操作，属于快照读，不加锁。(当然，也有例外，下面会分析)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ?;</span><br></pre></td></tr></table></figure><p>​    <strong>当前读：</strong>特殊的读操作，插入/更新/删除操作，属于当前读，需要加锁。　　</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ? <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ? <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> <span class="keyword">values</span> (…);</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">table</span> <span class="keyword">set</span> ? <span class="keyword">where</span> ?;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ?;</span><br></pre></td></tr></table></figure><p>​        所有以上的语句，都属于当前读，读取记录的最新版本。并且，读取之后，还需要保证其他并发事务不能修改当前记录，对读取记录加锁。其中，除了第一条语句，对读取记录加<strong>S锁 (共享锁)外</strong>，其他的操作，都加的是<strong>X锁 (排它锁)。</strong></p><p>　　为什么将 插入/更新/删除 操作，都归为当前读？可以看看下面这个 更新 操作，在数据库中的执行流程：</p><p>​              <img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/569491-20160531125430289-1207375285.jpg" alt="img" title="null"></p><p>　　从图中，可以看到，一个Update操作的具体流程。当Update SQL被发给MySQL后，MySQL Server会根据where条件，读取第一条满足条件的记录，然后InnoDB引擎会将第一条记录返回，并加锁 (current read)。待MySQL Server收到这条加锁的记录之后，会再发起一个Update请求，更新这条记录。一条记录操作完成，再读取下一条记录，直至没有满足条件的记录为止。因此，Update操作内部，就包含了一个当前读。同理，Delete操作也一样。Insert操作会稍微有些不同，简单来说，就是Insert操作可能会触发Unique Key的冲突检查，也会进行一个当前读。</p><p><strong>注</strong>：根据上图的交互，针对一条当前读的SQL语句，InnoDB与MySQL Server的交互，是一条一条进行的，因此，加锁也是一条一条进行的。先对一条满足条件的记录加锁，返回给MySQL Server，做一些DML操作；然后在读取下一条加锁，直至读取完毕。</p><h1 id="3、Cluster-Index：聚簇索引"><a href="#3、Cluster-Index：聚簇索引" class="headerlink" title="3、Cluster Index：聚簇索引"></a>3、<strong>Cluster Index：聚簇索引</strong></h1><p>　　<strong>InnoDB存储引擎的数据组织方式，是聚簇索引表：完整的记录，存储在主键索引中，通过主键索引，就可以获取记录所有的列。关于聚簇索引表的组织方式，可以参考MySQL的官方文档：<a href="http://dev.mysql.com/doc/refman/5.0/en/innodb-index-types.html" target="_blank" rel="noopener">Clustered and Secondary Indexes</a> 。本文假设读者对这个，已经有了一定的认识，就不再做具体的介绍。接下来的部分，主键索引/聚簇索引 两个名称，会有一些混用，望读者知晓。</strong></p><h1 id="4、2PL：Two-Phase-Locking"><a href="#4、2PL：Two-Phase-Locking" class="headerlink" title="4、2PL：Two-Phase Locking"></a>4、<strong>2PL：Two-Phase Locking</strong></h1><p>　　传统RDBMS加锁的一个原则，就是2PL (二阶段锁)：<a href="http://en.wikipedia.org/wiki/Two-phase_locking" target="_blank" rel="noopener">Two-Phase Locking</a>。相对而言，2PL比较容易理解，说的是锁操作分为两个阶段：加锁阶段与解锁阶段，并且保证加锁阶段与解锁阶段不相交。下面，仍旧以MySQL为例，来简单看看2PL在MySQL中的实现。</p><p>　　　　　　  <img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/569491-20160531125643852-1513515378.jpg" alt="img" title="null"></p><p>　　　　从上图可以看出，2PL就是将加锁/解锁分为两个完全不相交的阶段。加锁阶段：只加锁，不放锁。解锁阶段：只放锁，不加锁。</p><h1 id="5、事务隔离级别Isolation-Level"><a href="#5、事务隔离级别Isolation-Level" class="headerlink" title="5、事务隔离级别Isolation Level"></a>5、事务隔离级别<strong>Isolation Level</strong></h1><p>　　隔离级别：<a href="http://en.wikipedia.org/wiki/Isolation_(database_systems)" target="_blank" rel="noopener">Isolation Level</a>，也是RDBMS的一个关键特性。相信对数据库有所了解的朋友，对于4种隔离级别：Read Uncommited，Read Committed，Repeatable Read，Serializable，都有了深入的认识。本文不打算讨论数据库理论中，是如何定义这4种隔离级别的含义的，而是跟大家介绍一下MySQL/InnoDB是如何定义这4种隔离级别的。</p><p>　　MySQL/InnoDB定义的4种隔离级别：（mysql的级别不是ios定义的级别，iso定义的RR存在幻读）</p><ul><li><ul><li><p>*<em>Read Uncommited<br>*</em></p><p>可以读取未提交记录。此隔离级别，不会使用，忽略。</p></li><li><p>*<em>Read Committed (RC)<br>*</em></p><p>快照读忽略，本文不考虑。</p><p>针对当前读，<strong>RC隔离级别保证对读取到的记录加锁 (记录锁)</strong>，存在幻读现象。</p></li><li><p>*<em>Repeatable Read (RR)<br>*</em></p><p>快照读忽略，本文不考虑。</p><p>针对当前读，<strong>RR隔离级别保证对读取到的记录加锁 (记录锁)，同时保证对读取的范围加锁，新的满足查询条件的记录不能够插入 (间隙锁)</strong>，不存在幻读现象。</p></li><li><p>*<em>Serializable<br>*</em></p><p>从MVCC并发控制退化为基于锁的并发控制。不区别快照读与当前读，所有的读操作均为当前读，读加读锁 (S锁)，写加写锁 (X锁)。</p><p>Serializable隔离级别下，读写冲突，因此并发度急剧下降，在MySQL/InnoDB下不建议使用。</p></li></ul></li></ul><p>在MYSQL的事务引擎中，INNODB是使用范围最广的。它默认的事务隔离级别是REPEATABLE READ(可重复读），在标准的事务隔离级别定义下，REPEATABLE READ是不能防止幻读产生的。INNODB使用了next-key locks实现了防止幻读的发生。</p><h1 id="6、加锁过程分析"><a href="#6、加锁过程分析" class="headerlink" title="6、加锁过程分析"></a>6、加锁过程分析</h1><h2 id="1）一条简单SQL的加锁实现分析"><a href="#1）一条简单SQL的加锁实现分析" class="headerlink" title="1）一条简单SQL的加锁实现分析"></a>1）<strong>一条简单SQL的加锁实现分析</strong></h2><p>　　在介绍完一些背景知识之后，本文接下来将选择几个有代表性的例子，来详细分析MySQL的加锁处理。当然，还是从最简单的例子说起。经常有朋友发给我一个SQL，然后问我，这个SQL加什么锁？就如同下面两条简单的SQL，他们加什么锁？</p><ul><li><strong>SQL1：</strong>select * from t1 where id = 10;</li><li><strong>SQL2：</strong>delete from t1 where id = 10;</li></ul><p>　　针对这个问题，该怎么回答？我能想象到的一个答案是：</p><ul><li><strong>SQL1：</strong>不加锁。因为MySQL是使用多版本并发控制的，读不加锁。</li><li><strong>SQL2：</strong>对id = 10的记录加写锁 (走主键索引)。</li></ul><p>　　这个答案对吗？说不上来。即可能是正确的，也有可能是错误的，已知条件不足，这个问题没有答案。如果让我来回答这个问题，我必须还要知道以下的一些前提，前提不同，我能给出的答案也就不同。要回答这个问题，还缺少哪些前提条件？</p><ul><li><p><strong>前提一：</strong>id列是不是主键？</p></li><li><p><strong>前提二：</strong>当前系统的隔离级别是什么？</p></li><li><p><strong>前提三：</strong>id列如果不是主键，那么id列上有索引吗？</p></li><li><p><strong>前提四：</strong>id列上如果有二级索引，那么这个索引是唯一索引吗？</p></li><li><p><strong>前提五：</strong>两个SQL的执行计划是什么？索引扫描？全表扫描？</p></li></ul><p>没有这些前提，直接就给定一条SQL，然后问这个SQL会加什么锁，都是很业余的表现。而当这些问题有了明确的答案之后，给定的SQL会加什么锁，也就一目了然。下面，我将这些问题的答案进行组合，然后按照从易到难的顺序，逐个分析每种组合下，对应的SQL会加哪些锁？</p><p><strong>注：</strong>下面的这些组合，我做了一个前提假设，也就是有索引时，执行计划一定会选择使用索引进行过滤 (索引扫描)。但实际情况会复杂很多，真正的执行计划，还是需要根据MySQL输出的为准。</p><ul><li><strong>组合一：</strong>id列是主键，RC隔离级别</li><li><strong>组合二：</strong>id列是二级唯一索引，RC隔离级别</li><li><strong>组合三：</strong>id列是二级非唯一索引，RC隔离级别</li><li><strong>组合四：</strong>id列上没有索引，RC隔离级别</li><li><strong>组合五：</strong>id列是主键，RR隔离级别</li><li><strong>组合六：</strong>id列是二级唯一索引，RR隔离级别</li><li><strong>组合七：</strong>id列是二级非唯一索引，RR隔离级别</li><li><strong>组合八：</strong>id列上没有索引，RR隔离级别</li><li><strong>组合九：</strong>Serializable隔离级别</li></ul><p>排列组合还没有列举完全，但是看起来，已经很多了。真的有必要这么复杂吗？事实上，要分析加锁，就是需要这么复杂。但是从另一个角度来说，只要你选定了一种组合，SQL需要加哪些锁，其实也就确定了。接下来，就让我们来逐个分析这9种组合下的SQL加锁策略。</p><p>注：在前面八种组合下，也就是RC，RR隔离级别下<strong>，SQL1：select操作均不加锁，采用的是快照读，因此在下面的讨论中就忽略了</strong>，主要讨论SQL2：delete操作的加锁。</p><h3 id="组合一：id主键-RC"><a href="#组合一：id主键-RC" class="headerlink" title="组合一：id主键+RC"></a><strong>组合一：id主键+RC</strong></h3><p>　　这个组合，是最简单，最容易分析的组合。id是主键，Read Committed隔离级别，给定SQL：delete from t1 where id = 10; 只需要将主键上，id = 10的记录加上X锁即可。如下图所示：</p><p>　　　　　　　　　　　　　　　　　　<img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/569491-20160531125918696-1671805168.jpg" alt="img" title="null">　　　　　　</p><p>　　　　　　<strong>结论：id是主键时，此SQL只需要在id=10这条记录上加X锁即可。</strong></p><p> <strong>组合二：id唯一索引+RC</strong> </p><p>　　这个组合，id不是主键，而是一个Unique的二级索引键值。那么在RC隔离级别下，delete from t1 where id = 10; 需要加什么锁呢？见下图：</p><p>　　　　　           　<img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/569491-20160531130038446-27860841.jpg" alt="img" title="null"></p><p>　　此组合中，id是unique索引，而主键是name列。此时，加锁的情况由于组合一有所不同。由于id是unique索引，因此delete语句会选择走id列的索引进行where条件的过滤，在找到id=10的记录后，首先会将unique索引上的id=10索引记录加上X锁，同时，会根据读取到的name列，回主键索引(聚簇索引)，然后将聚簇索引上的name = ‘d’ 对应的主键索引项加X锁。为什么聚簇索引上的记录也要加锁？试想一下，如果并发的一个SQL，是通过主键索引来更新：update t1 set id = 100 where name = ‘d’; 此时，如果delete语句没有将主键索引上的记录加锁，那么并发的update就会感知不到delete语句的存在，违背了同一记录上的更新/删除需要串行执行的约束。</p><p><strong>结论：若id列是unique列，其上有unique索引。那么SQL需要加两个X锁，一个对应于id unique索引上的id = 10的记录，另一把锁对应于聚簇索引上的[name=’d’,id=10]的记录。</strong></p><h3 id="组合三：id非唯一索引-RC"><a href="#组合三：id非唯一索引-RC" class="headerlink" title="组合三：id非唯一索引+RC"></a><strong>组合三：id非唯一索引+RC</strong></h3><p>　　<strong>相对于组合一、二，组合三又发生了变化，隔离级别仍旧是RC不变，但是id列上的约束又降低了，id列不再唯一，只有一个普通的索引。假设delete from t1 where id = 10; 语句，仍旧选择id列上的索引进行过滤where条件，那么此时会持有哪些锁？同样见下图：</strong></p><p>​        　　　  <img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/569491-20160531130136258-81724917.jpg" alt="img" title="null"></p><p>　　根据此图，可以看到，首先，id列索引上，满足id = 10查询条件的记录，均已加锁。同时，这些记录对应的主键索引上的记录也都加上了锁。与组合二唯一的区别在于，组合二最多只有一个满足等值查询的记录，而组合三会将所有满足查询条件的记录都加锁。</p><p><strong>结论：若id列上有非唯一索引，那么对应的所有满足SQL查询条件的记录，都会被加锁。同时，这些记录在主键索引上的记录，也会被加锁。</strong></p><h3 id="组合四：id无索引-RC"><a href="#组合四：id无索引-RC" class="headerlink" title="组合四：id无索引+RC"></a><strong>组合四：id无索引+RC</strong></h3><p>　　<strong>相对于前面三个组合，这是一个比较特殊的情况。id列上没有索引，where id = 10;这个过滤条件，没法通过索引进行过滤，那么只能走全表扫描做过滤。对应于这个组合，SQL会加什么锁？或者是换句话说，全表扫描时，会加什么锁？这个答案也有很多：有人说会在表上加X锁；有人说会将聚簇索引上，选择出来的id = 10;的记录加上X锁。那么实际情况呢？请看下图：</strong></p><p>​         <img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/569491-20160531130239242-1390195296.jpg" alt="img" title="null"> </p><p>　　由于id列上没有索引，因此只能走聚簇索引，进行全部扫描。从图中可以看到，满足删除条件的记录有两条，但是，聚簇索引上所有的记录，都被加上了X锁。无论记录是否满足条件，全部被加上X锁。既不是加表锁，也不是在满足条件的记录上加行锁。</p><p>　　有人可能会问？为什么不是只在满足条件的记录上加锁呢？这是由于MySQL的实现决定的。如果一个条件无法通过索引快速过滤，那么存储引擎层面就会将所有记录加锁后返回，然后由MySQL Server层进行过滤。因此也就把所有的记录，都锁上了。</p><p>注：在实际的实现中，MySQL有一些改进，在MySQL Server过滤条件，发现不满足后，会调用unlock_row方法，把不满足条件的记录放锁 (违背了2PL的约束)。这样做，保证了最后只会持有满足条件记录上的锁，但是每条记录的加锁操作还是不能省略的。</p><p><strong>结论：若id列上没有索引，SQL会走聚簇索引的全扫描进行过滤，由于过滤是由MySQL Server层面进行的。因此每条记录，无论是否满足条件，都会被加上X锁。但是，为了效率考量，MySQL做了优化，对于不满足条件的记录，会在判断后放锁，最终持有的，是满足条件的记录上的锁，但是不满足条件的记录上的加锁/放锁动作不会省略。同时，优化也违背了2PL的约束。</strong></p><h3 id="组合五：id主键-RR"><a href="#组合五：id主键-RR" class="headerlink" title="组合五：id主键+RR"></a><strong>组合五：id主键+RR</strong></h3><p>　　上面的四个组合，都是在Read Committed隔离级别下的加锁行为，接下来的四个组合，是在Repeatable Read隔离级别下的加锁行为。</p><p>　　组合五，id列是主键列，Repeatable Read隔离级别，针对delete from t1 where id = 10; 这条SQL，加锁与组合一：[<a href="http://hedengcheng.com/?p=771#_组合一：id主键+RC" target="_blank" rel="noopener">id主键，Read Committed</a>]一致。</p><h3 id="组合六：id唯一索引-RR"><a href="#组合六：id唯一索引-RR" class="headerlink" title="组合六：id唯一索引+RR"></a><strong>组合六：id唯一索引+RR</strong></h3><p>　　<strong>与组合五类似，组合六的加锁，与组合二：[<a href="http://hedengcheng.com/?p=771#_组合二：id唯一索引+RC" target="_blank" rel="noopener">id唯一索引，Read Committed</a>]一致。两个X锁，id唯一索引满足条件的记录上一个，对应的聚簇索引上的记录一个。</strong></p><h3 id="组合七：id非唯一索引-RR"><a href="#组合七：id非唯一索引-RR" class="headerlink" title="组合七：id非唯一索引+RR"></a><strong>组合七：id非唯一索引+RR</strong></h3><p>　　还记得前面提到的MySQL的四种隔离级别的区别吗？RC隔离级别允许幻读，而RR隔离级别，不允许存在幻读。但是在组合五、组合六中，加锁行为又是与RC下的加锁行为完全一致。那么RR隔离级别下，</p><p><strong>如何防止幻读呢？问题的答案，就在组合七中揭晓。</strong></p><p>　　组合七，Repeatable Read隔离级别，id上有一个非唯一索引，执行delete from t1 where id = 10; 假设选择id列上的索引进行条件过滤，最后的加锁行为，是怎么样的呢？同样看下面这幅图：</p><p>　　　　　　<img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/569491-20160531130411383-483975821.jpg" alt="img" title="null"></p><p>　　此图，相对于组合三：[<a href="http://hedengcheng.com/?p=771#_组合三：id非唯一索引+RC" target="_blank" rel="noopener">id列上非唯一锁，Read Committed</a>]看似相同，其实却有很大的区别。最大的区别在于，这幅图中多了一个GAP锁，而且GAP锁看起来也不是加在记录上的，倒像是加载两条记录之间的位置，GAP锁有何用？</p><p>　　其实这个多出来的GAP锁，就是RR隔离级别，相对于RC隔离级别，不会出现幻读的关键。确实，GAP锁锁住的位置，也不是记录本身，而是两条记录之间的GAP。</p><p>　　如何保证两次当前读返回一致的记录，那就需要在第一次当前读与第二次当前读之间，其他的事务不会插入新的满足条件的记录并提交。为了实现这个功能，GAP锁应运而生。</p><p>　　如图中所示，有哪些位置可以插入新的满足条件的项 (id = 10)，考虑到B+树索引的有序性，满足条件的项一定是连续存放的。记录[6,c]之前，不会插入id=10的记录；[6,c]与[10,b]间可以插入[10, aa]；[10,b]与[10,d]间，可以插入新的[10,bb],[10,c]等；[10,d]与[11,f]间可以插入满足条件的[10,e],[10,z]等；而[11,f]之后也不会插入满足条件的记录。因此，为了保证[6,c]与[10,b]间，[10,b]与[10,d]间，[10,d]与[11,f]不会插入新的满足条件的记录，MySQL选择了用GAP锁，将这三个GAP给锁起来。</p><p>　　Insert操作，如insert [10,aa]，首先会定位到[6,c]与[10,b]间，然后在插入前，会检查这个GAP是否已经被锁上，如果被锁上，则Insert不能插入记录。因此，通过第一遍的当前读，不仅将满足条件的记录锁上 (X锁)，与组合三类似。同时还是增加3把GAP锁，将可能插入满足条件记录的3个GAP给锁上，保证后续的Insert不能插入新的id=10的记录，也就杜绝了同一事务的第二次当前读，出现幻象的情况。</p><p>　　有心的朋友看到这儿，可以会问：既然防止幻读，需要靠GAP锁的保护，为什么组合五、组合六，也是RR隔离级别，却不需要加GAP锁呢？</p><p>　　首先，这是一个好问题。其次，回答这个问题，也很简单。GAP锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况。而组合五，id是主键；组合六，id是unique键，都能够保证唯一性。一个等值查询，最多只能返回一条记录，而且新的相同取值的记录，一定不会在新插入进来，因此也就避免了GAP锁的使用。其实，针对此问题，还有一个更深入的问题：如果组合五、组合六下，针对SQL：select * from t1 where id = 10 for update; 第一次查询，没有找到满足查询条件的记录，那么GAP锁是否还能够省略？此问题留给大家思考。</p><p><strong>结论：Repeatable Read隔离级别下，id列上有一个非唯一索引，对应SQL：delete from t1 where id = 10; 首先，通过id索引定位到第一条满足查询条件的记录，加记录上的X锁，加GAP上的GAP锁，然后加主键聚簇索引上的记录X锁，然后返回；然后读取下一条，重复进行。直至进行到第一条不满足条件的记录[11,f]，此时，不需要加记录X锁，但是仍旧需要加GAP锁，最后返回结束。</strong></p><p> <strong>什么时候会取得gap lock或nextkey lock 这和隔离级别有关,只在REPEATABLE READ或以上的隔离级别下的特定操作才会取得gap lock或nextkey lock。</strong></p><h3 id="组合八：id无索引-RR"><a href="#组合八：id无索引-RR" class="headerlink" title="组合八：id无索引+RR"></a><strong>组合八：id无索引+RR</strong></h3><p>　　<strong>组合八，Repeatable Read隔离级别下的最后一种情况，id列上没有索引。此时SQL：delete from t1 where id = 10; 没有其他的路径可以选择，只能进行全表扫描。最终的加锁情况，如下图所示：</strong></p><p>  　　　    <strong><img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/569491-20160531130526352-188149774.jpg" alt="img" title="null"></strong></p><p>　　如图，这是一个很恐怖的现象。首先，聚簇索引上的所有记录，都被加上了X锁。其次，聚簇索引每条记录间的间隙(GAP)，也同时被加上了GAP锁。这个示例表，只有6条记录，一共需要6个记录锁，7个GAP锁。试想，如果表上有1000万条记录呢？</p><p>　　在这种情况下，这个表上，除了不加锁的快照度，其他任何加锁的并发SQL，均不能执行，不能更新，不能删除，不能插入，全表被锁死。</p><p>　　当然，跟组合四：[<a href="http://hedengcheng.com/?p=771#_组合四：id无索引+RC" target="_blank" rel="noopener">id无索引, Read Committed</a>]类似，这个情况下，MySQL也做了一些优化，就是所谓的semi-consistent read。semi-consistent read开启的情况下，对于不满足查询条件的记录，MySQL会提前放锁。针对上面的这个用例，就是除了记录[d,10]，[g,10]之外，所有的记录锁都会被释放，同时不加GAP锁。semi-consistent read如何触发：要么是read committed隔离级别；要么是Repeatable Read隔离级别，同时设置了<a href="http://dev.mysql.com/doc/refman/5.5/en/innodb-parameters.html" target="_blank" rel="noopener">innodb_locks_unsafe_for_binlog</a> 参数。更详细的关于semi-consistent read的介绍，可参考我之前的一篇博客：<a href="http://hedengcheng.com/?p=220" target="_blank" rel="noopener">MySQL+InnoDB semi-consitent read原理及实现分析</a> 。</p><p><strong>结论：在Repeatable Read隔离级别下，如果进行全表扫描的当前读，那么会锁上表中的所有记录，同时会锁上聚簇索引内的所有GAP，杜绝所有的并发 更新/删除/插入 操作。当然，也可以通过触发semi-consistent read，来缓解加锁开销与并发影响，但是semi-consistent read本身也会带来其他问题，不建议使用。</strong></p><h3 id="组合九：Serializable"><a href="#组合九：Serializable" class="headerlink" title="组合九：Serializable"></a><strong>组合九：Serializable</strong></h3><p>　　针对前面提到的简单的SQL，最后一个情况：Serializable隔离级别。对于SQL2：delete from t1 where id = 10; 来说，Serializable隔离级别与Repeatable Read隔离级别完全一致，因此不做介绍。</p><p>　　Serializable隔离级别，影响的是SQL1：select * from t1 where id = 10; 这条SQL，在RC，RR隔离级别下，都是快照读，不加锁。但是在Serializable隔离级别，SQL1会加读锁，也就是说快照读不复存在，MVCC并发控制降级为Lock-Based CC。</p><p><strong>结论：在MySQL/InnoDB中，所谓的读不加锁，并不适用于所有的情况，而是隔离级别相关的。Serializable隔离级别，读不加锁就不再成立，所有的读操作，都是当前读。</strong></p><h2 id="2）一条复杂的sql语句"><a href="#2）一条复杂的sql语句" class="headerlink" title="2）一条复杂的sql语句"></a>2）一条复杂的sql语句</h2><p>　　写到这里，其实MySQL的加锁实现也已经介绍的八八九九。只要将本文上面的分析思路，大部分的SQL，都能分析出其会加哪些锁。而这里，再来看一个稍微复杂点的SQL，用于说明MySQL加锁的另外一个逻辑。SQL用例如下：</p><p>　　　　　　<img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/569491-20160531130813461-508526456.jpg" alt="img" title="null"></p><p>　　　　如图中的SQL，会加什么锁？假定在Repeatable Read隔离级别下 (Read Committed隔离级别下的加锁情况，留给读者分析。)，同时，假设SQL走的是idx_t1_pu索引。</p><p>　　　　在详细分析这条SQL的加锁情况前，还需要有一个知识储备，那就是一个SQL中的where条件如何拆分？具体的介绍，建议阅读我之前的一篇文章：<a href="http://hedengcheng.com/?p=577" target="_blank" rel="noopener">SQL中的where条件，在数据库中提取与应用浅析</a> 。在这里，我直接给出分析后的结果：</p><ul><li><ul><li>　　<strong>Index key：</strong>pubtime &gt; 1 and puptime &lt; 20。此条件，用于确定SQL在idx_t1_pu索引上的查询范围。</li></ul></li></ul><ul><li>　　<strong>Index Filter：</strong>userid = ‘hdc’ 。此条件，可以在idx_t1_pu索引上进行过滤，但不属于Index Key。</li></ul><ul><li><ul><li>　　<strong>Table Filter：</strong>comment is not NULL。此条件，在idx_t1_pu索引上无法过滤，只能在聚簇索引上过滤。</li></ul></li></ul><p>　　在分析出SQL where条件的构成之后，再来看看这条SQL的加锁情况 (RR隔离级别)，如下图所示：</p><p> 　　　<strong><img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/569491-20160531130852930-842188790.jpg" alt="img" title="null"></strong></p><p>　　从图中可以看出，在Repeatable Read隔离级别下，由Index Key所确定的范围，被加上了GAP锁；Index Filter锁给定的条件 (userid = ‘hdc’)何时过滤，视MySQL的版本而定，在MySQL 5.6版本之前，不支持<a href="http://dev.mysql.com/doc/refman/5.6/en/index-condition-pushdown-optimization.html" target="_blank" rel="noopener">Index Condition Pushdown</a>(ICP)，因此Index Filter在MySQL Server层过滤，在5.6后支持了Index Condition Pushdown，则在index上过滤。若不支持ICP，不满足Index Filter的记录，也需要加上记录X锁，若支持ICP，则不满足Index Filter的记录，无需加记录X锁 (图中，用红色箭头标出的X锁，是否要加，视是否支持ICP而定)；而Table Filter对应的过滤条件，则在聚簇索引中读取后，在MySQL Server层面过滤，因此聚簇索引上也需要X锁。最后，选取出了一条满足条件的记录[8,hdc,d,5,good]，但是加锁的数量，要远远大于满足条件的记录数量。</p><p><strong>结论：在Repeatable Read隔离级别下，针对一个复杂的SQL，首先需要提取其where条件。Index Key确定的范围，需要加上GAP锁；Index Filter过滤条件，视MySQL版本是否支持ICP，若支持ICP，则不满足Index Filter的记录，不加X锁，否则需要X锁；Table Filter过滤条件，无论是否满足，都需要加X锁。</strong></p><h1 id="7、死锁原理与分析"><a href="#7、死锁原理与分析" class="headerlink" title="7、死锁原理与分析"></a>7、<strong>死锁原理与分析</strong></h1><p>　　本文前面的部分，基本上已经涵盖了MySQL/InnoDB所有的加锁规则。深入理解MySQL如何加锁，有两个比较重要的作用：</p><ul><li>可以根据MySQL的加锁规则，写出不会发生死锁的SQL；</li></ul><ul><li>可以根据MySQL的加锁规则，定位出线上产生死锁的原因；</li></ul><p>　　下面，来看看两个死锁的例子 (一个是两个Session的两条SQL产生死锁；另一个是两个Session的一条SQL，产生死锁)：</p><p>　　　　<strong><img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/569491-20160531131107930-1938279375.jpg" alt="img" title="null"></strong></p><p>　　　　<img src="../MySQL%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/569491-20160531131120930-2048731464.jpg" alt="img" title="null"></p><p>　　上面的两个死锁用例。第一个非常好理解，也是最常见的死锁，每个事务执行两条SQL，分别持有了一把锁，然后加另一把锁，产生死锁。</p><p>　　第二个用例，虽然每个Session都只有一条语句，仍旧会产生死锁。要分析这个死锁，首先必须用到本文前面提到的MySQL加锁的规则。针对Session 1，从name索引出发，读到的[hdc, 1]，[hdc, 6]均满足条件，不仅会加name索引上的记录X锁，而且会加聚簇索引上的记录X锁，加锁顺序为先[1,hdc,100]，后[6,hdc,10]。而Session 2，从pubtime索引出发，[10,6],[100,1]均满足过滤条件，同样也会加聚簇索引上的记录X锁，加锁顺序为[6,hdc,10]，后[1,hdc,100]。发现没有，跟Session 1的加锁顺序正好相反，如果两个Session恰好都持有了第一把锁，请求加第二把锁，死锁就发生了。　　</p><p><strong>结论：死锁的发生与否，并不在于事务中有多少条SQL语句，死锁的关键在于：两个(或以上)的Session加锁的顺序不一致。而使用本文上面提到的，分析MySQL每条SQL语句的加锁规则，分析出每条语句的加锁顺序，然后检查多个并发SQL间是否存在以相反的顺序加锁的情况，就可以分析出各种潜在的死锁情况，也可以分析出线上死锁发生的原因。</strong></p><h1 id="8、总结"><a href="#8、总结" class="headerlink" title="8、总结"></a>8、总结</h1><p>　　写到这儿，本文也告一段落，做一个简单的总结，要做的完全掌握MySQL/InnoDB的加锁规则，甚至是其他任何数据库的加锁规则，需要具备以下的一些知识点：</p><ul><li>了解数据库的一些基本理论知识：数据的存储格式 (堆组织表 vs 聚簇索引表)；并发控制协议 (MVCC vs Lock-Based CC)；Two-Phase Locking；数据库的隔离级别定义 (Isolation Level)；</li><li>了解SQL本身的执行计划 (主键扫描 vs 唯一键扫描 vs 范围扫描 vs 全表扫描)；</li><li>了解数据库本身的一些实现细节 (过滤条件提取；Index Condition Pushdown；Semi-Consistent Read)；</li><li>了解死锁产生的原因及分析的方法 (加锁顺序不一致；分析每个SQL的加锁顺序)</li></ul><p>　　有了这些知识点，再加上适当的实战经验，全面掌控MySQL/InnoDB的加锁规则，当不在话下。</p><p><strong>注：转载自 博客园 crazyYong：<a href="https://www.cnblogs.com/crazylqy/p/7611069.html" target="_blank" rel="noopener">https://www.cnblogs.com/crazylqy/p/7611069.html</a></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1、背景&quot;&gt;&lt;a href=&quot;#1、背景&quot; class=&quot;headerlink&quot; title=&quot;1、背景&quot;&gt;&lt;/a&gt;1、背景&lt;/h1&gt;&lt;p&gt;　　MySQL/InnoDB的加锁分析，一直是一个比较困难的话题。我在工作过程中，经常会有同事咨询这方面的问题。同时，微博上
      
    
    </summary>
    
    
      <category term="MySQL" scheme="https://husky-wu.github.io/categories/MySQL/"/>
    
      <category term="锁" scheme="https://husky-wu.github.io/categories/MySQL/%E9%94%81/"/>
    
    
      <category term="MySQL" scheme="https://husky-wu.github.io/tags/MySQL/"/>
    
      <category term="锁" scheme="https://husky-wu.github.io/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>数据混合存储</title>
    <link href="https://husky-wu.github.io/2020/12/29/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E6%95%B0%E6%8D%AE%E6%B7%B7%E5%90%88%E5%AD%98%E5%82%A8/"/>
    <id>https://husky-wu.github.io/2020/12/29/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E6%95%B0%E6%8D%AE%E6%B7%B7%E5%90%88%E5%AD%98%E5%82%A8/</id>
    <published>2020-12-29T07:00:03.000Z</published>
    <updated>2020-12-29T07:05:47.943Z</updated>
    
    <content type="html"><![CDATA[<p>课程链接：</p><p><a href="https://developer.aliyun.com/course/32?spm=a2c6h.17661847.0.0.42686fb2saW1fD" target="_blank" rel="noopener">https://developer.aliyun.com/course/32?spm=a2c6h.17661847.0.0.42686fb2saW1fD</a></p><p><a href="https://developer.aliyun.com/lesson_32_642#_642" target="_blank" rel="noopener">https://developer.aliyun.com/lesson_32_642#_642</a></p><p><img src="../%E6%95%B0%E6%8D%AE%E6%B7%B7%E5%90%88%E5%AD%98%E5%82%A8/image-20201229150055974.png" alt="image-20201229150055974" title="null"></p><p>当前存储架构中：内存+本地存储才能达到极致性能</p><p>从前：</p><p><img src="../%E6%95%B0%E6%8D%AE%E6%B7%B7%E5%90%88%E5%AD%98%E5%82%A8/image-20201229150148077.png" alt="image-20201229150148077" title="null"></p><p>当前</p><p><img src="../%E6%95%B0%E6%8D%AE%E6%B7%B7%E5%90%88%E5%AD%98%E5%82%A8/image-20201229150203677.png" alt="image-20201229150203677" title="null"></p><p>移动数据时</p><p><img src="../%E6%95%B0%E6%8D%AE%E6%B7%B7%E5%90%88%E5%AD%98%E5%82%A8/image-20201229150415502.png" alt="image-20201229150415502" title="null"></p><p>连续写入数据时，写入SSD，后续再同步到sata盘中</p><p><img src="../%E6%95%B0%E6%8D%AE%E6%B7%B7%E5%90%88%E5%AD%98%E5%82%A8/image-20201229150515483.png" alt="image-20201229150515483" title="null"></p><p><img src="../%E6%95%B0%E6%8D%AE%E6%B7%B7%E5%90%88%E5%AD%98%E5%82%A8/image-20201229150526791.png" alt="image-20201229150526791" title="null"></p><p>RAMCLOOUD内存存储</p><p><img src="../%E6%95%B0%E6%8D%AE%E6%B7%B7%E5%90%88%E5%AD%98%E5%82%A8/image-20201229150547244.png" alt="image-20201229150547244" title="null"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;课程链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.aliyun.com/course/32?spm=a2c6h.17661847.0.0.42686fb2saW1fD&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https:
      
    
    </summary>
    
    
      <category term="分布式存储" scheme="https://husky-wu.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    
      <category term="分布式" scheme="https://husky-wu.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="https://husky-wu.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="分布式存储" scheme="https://husky-wu.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>元数据管理的可扩展性</title>
    <link href="https://husky-wu.github.io/2020/12/29/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7/"/>
    <id>https://husky-wu.github.io/2020/12/29/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7/</id>
    <published>2020-12-29T06:53:35.000Z</published>
    <updated>2020-12-29T06:59:35.753Z</updated>
    
    <content type="html"><![CDATA[<p>课程链接：</p><p><a href="https://developer.aliyun.com/course/32?spm=a2c6h.17661847.0.0.42686fb2saW1fD" target="_blank" rel="noopener">https://developer.aliyun.com/course/32?spm=a2c6h.17661847.0.0.42686fb2saW1fD</a></p><p><a href="https://developer.aliyun.com/lesson_32_641#_641" target="_blank" rel="noopener">https://developer.aliyun.com/lesson_32_641#_641</a></p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7/image-20201229145809484.png" alt="image-20201229145809484" title="null"></p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7/image-20201229145847014.png" alt="image-20201229145847014" title="null"></p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7/image-20201229145915281.png" alt="image-20201229145915281" title="null"></p><p>动态分块</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;课程链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.aliyun.com/course/32?spm=a2c6h.17661847.0.0.42686fb2saW1fD&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https:
      
    
    </summary>
    
    
      <category term="分布式存储" scheme="https://husky-wu.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    
      <category term="分布式" scheme="https://husky-wu.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="https://husky-wu.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="分布式存储" scheme="https://husky-wu.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>元数据管理的高可用性</title>
    <link href="https://husky-wu.github.io/2020/12/29/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/"/>
    <id>https://husky-wu.github.io/2020/12/29/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/</id>
    <published>2020-12-29T06:32:25.000Z</published>
    <updated>2020-12-29T06:53:05.466Z</updated>
    
    <content type="html"><![CDATA[<p>课程链接：</p><p><a href="https://developer.aliyun.com/course/32?spm=a2c6h.17661847.0.0.42686fb2saW1fD" target="_blank" rel="noopener">https://developer.aliyun.com/course/32?spm=a2c6h.17661847.0.0.42686fb2saW1fD</a></p><p><a href="https://developer.aliyun.com/lesson_32_640#_640" target="_blank" rel="noopener">https://developer.aliyun.com/lesson_32_640#_640</a></p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/image-20201229143335480.png" alt="image-20201229143335480" title="null"></p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/image-20201229143348235.png" alt="image-20201229143348235" title="null"></p><p>主从方式</p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/image-20201229143420012.png" alt="image-20201229143420012" title="null"></p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/image-20201229143434662.png" alt="image-20201229143434662" title="null"></p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/image-20201229143456067.png" alt="image-20201229143456067" title="null"></p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/image-20201229143610485.png" alt="image-20201229143610485" title="null"></p><p>分布式协议</p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/image-20201229143516471.png" alt="image-20201229143516471" title="null"></p><p>主从方式和分布式协议对比</p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/image-20201229143646282.png" alt="image-20201229143646282" title="null"></p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/image-20201229143657168.png" alt="image-20201229143657168" title="null"></p><p>HDFS NAMENODE 共享存储</p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/image-20201229143724494.png" alt="image-20201229143724494" title="null"></p><p>盘古 元数据服务  Raft</p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/image-20201229143757833.png" alt="image-20201229143757833" title="null"></p><p>选举状态</p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/image-20201229144001997.png" alt="image-20201229144001997" title="null"></p><p>发起选举请求</p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/image-20201229144017791.png" alt="image-20201229144017791" title="null"></p><p>其他节点接收到请求将进入锁定状态</p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/image-20201229144031224.png" alt="image-20201229144031224" title="null"></p><p>如果一个节点的请求被大多数节点接受，则发起publish，将自己的选举结果发送给其余节点</p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/image-20201229144142825.png" alt="image-20201229144142825" title="null"></p><p>锁定中的elector接收到publish通知则变为secondary状态</p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/image-20201229144251549.png" alt="image-20201229144251549" title="null"></p><p>发送出publish请求后，节点进入primary状态，并提供主节点服务</p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/image-20201229144357899.png" alt="image-20201229144357899" title="null"></p><p>主节点与辅助节点间有心跳连接，如果主节点异常，心跳丢失，从节点接收不到心跳会认为主节点宕机</p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/image-20201229144551139.png" alt="image-20201229144551139" title="null"></p><p>从节点会降级为选举状态，重新进行选举</p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/image-20201229144622545.png" alt="image-20201229144622545" title="null"></p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/image-20201229144643267.png" alt="image-20201229144643267" title="null"></p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/image-20201229144652189.png" alt="image-20201229144652189" title="null"></p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/image-20201229144659694.png" alt="image-20201229144659694" title="null"></p><p>之前异常的节点恢复后如何重新加入集群</p><p>依旧会选举自己为主节点发起propose</p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/image-20201229144738763.png" alt="image-20201229144738763" title="null"></p><p>当前主节点拒绝该请求，同时将自己是主节点这个信息publish给elector节点</p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/image-20201229144811943.png" alt="image-20201229144811943" title="null"></p><p>让其升级为secondary状态，重新加入服务</p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/image-20201229144914718.png" alt="image-20201229144914718" title="null"></p><p>Ceph Metadata Server</p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/image-20201229144954863.png" alt="image-20201229144954863" title="null"></p><p>数据一致性的保证</p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/image-20201229145019814.png" alt="image-20201229145019814" title="null"></p><p>Paxos</p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/image-20201229145111257.png" alt="image-20201229145111257" title="null"></p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/image-20201229145142337.png" alt="image-20201229145142337" title="null"></p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/image-20201229145212782.png" alt="image-20201229145212782" title="null"></p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/image-20201229145222215.png" alt="image-20201229145222215" title="null"></p><p><img src="../%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/image-20201229145231700.png" alt="image-20201229145231700" title="null"></p><p>Raft协议演示过程：</p><p><a href="https://raftconsensus.github.io/" target="_blank" rel="noopener">https://raftconsensus.github.io/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;课程链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.aliyun.com/course/32?spm=a2c6h.17661847.0.0.42686fb2saW1fD&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https:
      
    
    </summary>
    
    
      <category term="分布式存储" scheme="https://husky-wu.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    
      <category term="分布式" scheme="https://husky-wu.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="https://husky-wu.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="分布式存储" scheme="https://husky-wu.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统功能设计-ErasureCoding</title>
    <link href="https://husky-wu.github.io/2020/12/29/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-ErasureCoding/"/>
    <id>https://husky-wu.github.io/2020/12/29/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-ErasureCoding/</id>
    <published>2020-12-29T06:01:18.000Z</published>
    <updated>2020-12-29T06:31:37.434Z</updated>
    
    <content type="html"><![CDATA[<p>课程链接：</p><p><a href="https://developer.aliyun.com/course/32?spm=a2c6h.17661847.0.0.42686fb2saW1fD" target="_blank" rel="noopener">https://developer.aliyun.com/course/32?spm=a2c6h.17661847.0.0.42686fb2saW1fD</a></p><p><a href="https://developer.aliyun.com/lesson_32_639#_639" target="_blank" rel="noopener">https://developer.aliyun.com/lesson_32_639#_639</a></p><p>ErasureCoding数据压缩存储</p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-ErasureCoding/image-20201229142934482.png" alt="image-20201229142934482" title="null"></p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-ErasureCoding/image-20201229143017282.png" alt="image-20201229143017282" title="null"></p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-ErasureCoding/image-20201229143039900.png" alt="image-20201229143039900" title="null"></p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-ErasureCoding/image-20201229143108800.png" alt="image-20201229143108800" title="null"></p><p>劣势：当出现异常节点时，比较耗费网络节点流量</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;课程链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.aliyun.com/course/32?spm=a2c6h.17661847.0.0.42686fb2saW1fD&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https:
      
    
    </summary>
    
    
      <category term="分布式存储" scheme="https://husky-wu.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    
      <category term="分布式" scheme="https://husky-wu.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="https://husky-wu.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="分布式存储" scheme="https://husky-wu.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统功能设计-GC</title>
    <link href="https://husky-wu.github.io/2020/12/29/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-GC/"/>
    <id>https://husky-wu.github.io/2020/12/29/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-GC/</id>
    <published>2020-12-29T05:57:07.000Z</published>
    <updated>2020-12-29T06:00:46.866Z</updated>
    
    <content type="html"><![CDATA[<p>课程链接：</p><p><a href="https://developer.aliyun.com/course/32?spm=a2c6h.17661847.0.0.42686fb2saW1fD" target="_blank" rel="noopener">https://developer.aliyun.com/course/32?spm=a2c6h.17661847.0.0.42686fb2saW1fD</a></p><p><a href="https://developer.aliyun.com/lesson_32_638#_638" target="_blank" rel="noopener">https://developer.aliyun.com/lesson_32_638#_638</a></p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-GC/image-20201229135817761.png" alt="image-20201229135817761" title="null"></p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-GC/image-20201229135829989.png" alt="image-20201229135829989" title="null"></p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-GC/image-20201229135843596.png" alt="image-20201229135843596" title="null"></p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-GC/image-20201229135920043.png" alt="image-20201229135920043" title="null"></p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-GC/image-20201229135931511.png" alt="image-20201229135931511" title="null"></p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-GC/image-20201229140013784.png" alt="image-20201229140013784" title="null"></p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-GC/image-20201229140031002.png" alt="image-20201229140031002" title="null"></p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-GC/image-20201229140043476.png" alt="image-20201229140043476" title="null"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;课程链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.aliyun.com/course/32?spm=a2c6h.17661847.0.0.42686fb2saW1fD&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https:
      
    
    </summary>
    
    
      <category term="分布式存储" scheme="https://husky-wu.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    
      <category term="分布式" scheme="https://husky-wu.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="https://husky-wu.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="分布式存储" scheme="https://husky-wu.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统功能设计-Rebalance</title>
    <link href="https://husky-wu.github.io/2020/12/29/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-Rebalance/"/>
    <id>https://husky-wu.github.io/2020/12/29/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-Rebalance/</id>
    <published>2020-12-29T05:53:57.000Z</published>
    <updated>2020-12-29T05:55:42.993Z</updated>
    
    <content type="html"><![CDATA[<p>课程链接：</p><p><a href="https://developer.aliyun.com/course/32?spm=a2c6h.17661847.0.0.42686fb2saW1fD" target="_blank" rel="noopener">https://developer.aliyun.com/course/32?spm=a2c6h.17661847.0.0.42686fb2saW1fD</a></p><p><a href="https://developer.aliyun.com/lesson_32_637#_637" target="_blank" rel="noopener">https://developer.aliyun.com/lesson_32_637#_637</a></p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-Rebalance/image-20201229135442950.png" alt="image-20201229135442950" title="null"></p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-Rebalance/image-20201229135452256.png" alt="image-20201229135452256" title="null"></p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-Rebalance/image-20201229135500251.png" alt="image-20201229135500251" title="null"></p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-Rebalance/image-20201229135515211.png" alt="image-20201229135515211" title="null"></p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-Rebalance/image-20201229135535576.png" alt="image-20201229135535576" title="null"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;课程链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.aliyun.com/course/32?spm=a2c6h.17661847.0.0.42686fb2saW1fD&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https:
      
    
    </summary>
    
    
      <category term="分布式存储" scheme="https://husky-wu.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    
      <category term="分布式" scheme="https://husky-wu.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="https://husky-wu.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="分布式存储" scheme="https://husky-wu.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统功能设计-Replication</title>
    <link href="https://husky-wu.github.io/2020/12/29/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-Replication/"/>
    <id>https://husky-wu.github.io/2020/12/29/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-Replication/</id>
    <published>2020-12-29T05:47:30.000Z</published>
    <updated>2020-12-29T05:53:26.960Z</updated>
    
    <content type="html"><![CDATA[<p>课程链接：</p><p><a href="https://developer.aliyun.com/course/32?spm=a2c6h.17661847.0.0.42686fb2saW1fD" target="_blank" rel="noopener">https://developer.aliyun.com/course/32?spm=a2c6h.17661847.0.0.42686fb2saW1fD</a></p><p><a href="https://developer.aliyun.com/lesson_32_636#_636" target="_blank" rel="noopener">https://developer.aliyun.com/lesson_32_636#_636</a></p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-Replication/image-20201229134817085.png" alt="image-20201229134817085" title="null"></p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-Replication/image-20201229134834078.png" alt="image-20201229134834078" title="null"></p><p>如何保证数据不丢失</p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-Replication/image-20201229134856431.png" alt="image-20201229134856431" title="null"></p><p>如何及时发现磁盘错误？</p><p>盘古中每隔15s会回报一次在从上的心跳</p><p>当发现错误后，会去访问master获取从盘中错误文件的信息，并发起较高优先级的恢复</p><p>复制中需要考虑网络流量</p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-Replication/image-20201229135132635.png" alt="image-20201229135132635" title="null"></p><p>流量控制-防止复制风暴，不能因为</p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-Replication/image-20201229135302163.png" alt="image-20201229135302163" title="null"></p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-Replication/image-20201229135324663.png" alt="image-20201229135324663" title="null"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;课程链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.aliyun.com/course/32?spm=a2c6h.17661847.0.0.42686fb2saW1fD&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https:
      
    
    </summary>
    
    
      <category term="分布式存储" scheme="https://husky-wu.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    
      <category term="分布式" scheme="https://husky-wu.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="https://husky-wu.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="分布式存储" scheme="https://husky-wu.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统功能设计-Checksum</title>
    <link href="https://husky-wu.github.io/2020/12/29/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-Checksum/"/>
    <id>https://husky-wu.github.io/2020/12/29/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-Checksum/</id>
    <published>2020-12-29T05:38:23.000Z</published>
    <updated>2020-12-29T05:48:02.056Z</updated>
    
    <content type="html"><![CDATA[<p>课程链接：</p><p><a href="https://developer.aliyun.com/course/32?spm=a2c6h.17661847.0.0.42686fb2saW1fD" target="_blank" rel="noopener">https://developer.aliyun.com/course/32?spm=a2c6h.17661847.0.0.42686fb2saW1fD</a></p><p>https:/developer.aliyun.com/lesson_32_635#_635</p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-Checksum/image-20201229133923948.png" alt="image-20201229133923948" title="null"></p><p>数据包将会构造三元组</p><p>放在buffer中 记录length数据长度 进行CRC校验</p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-Checksum/image-20201229133959862.png" alt="image-20201229133959862" title="null"></p><p>在网络传输中由于数据包可能比较大，将会把这个数据包进行网络分包处理，</p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-Checksum/image-20201229134212309.png" alt="image-20201229134212309" title="null"></p><p>每个分包都会构造这样的三元组</p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-Checksum/image-20201229134254498.png" alt="image-20201229134254498" title="null"></p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-Checksum/image-20201229134306108.png" alt="image-20201229134306108" title="null"></p><p>传输中以及传输完成后均要对分包以及合并后的整包的CRC值进行校验</p><p>CRC值将会和数据一起存储于磁盘中</p><p>为保证在使用过程中磁盘数据的一致性以及可用性，将会启用checksum进程，间断性的对数据块中的CRC值进行校验</p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-Checksum/image-20201229134540981.png" alt="image-20201229134540981" title="null"></p><p>如有错误将通知盘古进行修复</p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-Checksum/image-20201229134605042.png" alt="image-20201229134605042" title="null"></p><p>弊端：</p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-Checksum/image-20201229134648105.png" alt="image-20201229134648105" title="null"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;课程链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.aliyun.com/course/32?spm=a2c6h.17661847.0.0.42686fb2saW1fD&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https:
      
    
    </summary>
    
    
      <category term="分布式存储" scheme="https://husky-wu.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    
      <category term="分布式" scheme="https://husky-wu.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="https://husky-wu.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="分布式存储" scheme="https://husky-wu.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统功能设计-QoS</title>
    <link href="https://husky-wu.github.io/2020/12/29/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-QoS/"/>
    <id>https://husky-wu.github.io/2020/12/29/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-QoS/</id>
    <published>2020-12-29T05:34:27.000Z</published>
    <updated>2020-12-29T05:37:56.878Z</updated>
    
    <content type="html"><![CDATA[<p>课程链接：</p><p><a href="https://developer.aliyun.com/course/32?spm=a2c6h.17661847.0.0.42686fb2saW1fD" target="_blank" rel="noopener">https://developer.aliyun.com/course/32?spm=a2c6h.17661847.0.0.42686fb2saW1fD</a></p><p><a href="https://developer.aliyun.com/lesson_32_634?spm=5176.10731542.0.0.622d12a7NMPHbC#_634" target="_blank" rel="noopener">https://developer.aliyun.com/lesson_32_634?spm=5176.10731542.0.0.622d12a7NMPHbC#_634</a></p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-QoS/image-20201229133533202.png" alt="image-20201229133533202" title="null"></p><p>多用户共存的QoS请求</p><p>每个用户用户组都将会标记权重</p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-QoS/image-20201229133613445.png" alt="image-20201229133613445" title="null"></p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-QoS/image-20201229133622010.png" alt="image-20201229133622010" title="null"></p><p>采用轮询方式从不同用户的请求池中执行请求，以保证每个用户的访问质量</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;课程链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.aliyun.com/course/32?spm=a2c6h.17661847.0.0.42686fb2saW1fD&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https:
      
    
    </summary>
    
    
      <category term="分布式存储" scheme="https://husky-wu.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    
      <category term="分布式" scheme="https://husky-wu.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="https://husky-wu.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="分布式存储" scheme="https://husky-wu.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统功能设计-读取流程</title>
    <link href="https://husky-wu.github.io/2020/12/29/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-%E8%AF%BB%E5%8F%96%E6%B5%81%E7%A8%8B/"/>
    <id>https://husky-wu.github.io/2020/12/29/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-%E8%AF%BB%E5%8F%96%E6%B5%81%E7%A8%8B/</id>
    <published>2020-12-29T05:27:11.000Z</published>
    <updated>2020-12-29T05:34:51.543Z</updated>
    
    <content type="html"><![CDATA[<p>课程链接：</p><p><a href="https://developer.aliyun.com/course/32?spm=a2c6h.17661847.0.0.42686fb2saW1fD" target="_blank" rel="noopener">https://developer.aliyun.com/course/32?spm=a2c6h.17661847.0.0.42686fb2saW1fD</a></p><p><a href="https://developer.aliyun.com/lesson_32_633#_633" target="_blank" rel="noopener">https://developer.aliyun.com/lesson_32_633#_633</a></p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-%E8%AF%BB%E5%8F%96%E6%B5%81%E7%A8%8B/image-20201229132824442.png" alt="image-20201229132824442" title="null"></p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-%E8%AF%BB%E5%8F%96%E6%B5%81%E7%A8%8B/image-20201229132945223.png" alt="image-20201229132945223" title="null"></p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-%E8%AF%BB%E5%8F%96%E6%B5%81%E7%A8%8B/image-20201229133010826.png" alt="image-20201229133010826" title="null"></p><p>backupread解决慢节点</p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-%E8%AF%BB%E5%8F%96%E6%B5%81%E7%A8%8B/image-20201229133049912.png" alt="image-20201229133049912" title="null"></p><p>读流程优化-规避慢节点</p><p>间段性统计返回期望</p><p>优先选择请求返回期望小的节点</p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-%E8%AF%BB%E5%8F%96%E6%B5%81%E7%A8%8B/image-20201229133147508.png" alt="image-20201229133147508" title="null"></p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-%E8%AF%BB%E5%8F%96%E6%B5%81%E7%A8%8B/image-20201229133257577.png" alt="image-20201229133257577" title="null"></p><p><img src="../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-%E8%AF%BB%E5%8F%96%E6%B5%81%E7%A8%8B/image-20201229133318207.png" alt="image-20201229133318207" title="null"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;课程链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.aliyun.com/course/32?spm=a2c6h.17661847.0.0.42686fb2saW1fD&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https:
      
    
    </summary>
    
    
      <category term="分布式存储" scheme="https://husky-wu.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    
      <category term="分布式" scheme="https://husky-wu.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="https://husky-wu.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="分布式存储" scheme="https://husky-wu.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
</feed>
